}
#| label: fig-abundancia-resex-cazumba-iracema-combinada
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'
#| fig-cap: "Variação na abundância das tribos de borboletas frugívoras na RESEX do Cazumbá-Iracema no período de 2020 a 2022."
# Combine todos os gráficos em uma única imagem
imagem_combinada <- grid.arrange(grobs = lista_graficos, ncol = 3)
# Salvar a imagem combinada usando ggsave()
# ggsave(filename = "todos_graficos_cazumba_iracema.png",  # Escolha um nome adequado para o arquivo
#        plot = imagem_combinada,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Cazumba-Iracema",  # Especifique o diretório onde você deseja salvar a imagem
#        dpi = 300,  # Define a resolução (DPI)
#        width = 14, height = 12, units = "in")  # Define o tamanho da imagem
#| label: fig-abundancia-resex-cazumba-iracema-combinada
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'
#| fig-cap: "Variação na abundância das tribos de borboletas frugívoras na RESEX do Cazumbá-Iracema no período de 2020 a 2022."
# Combine todos os gráficos em uma única imagem
imagem_combinada <- grid.arrange(grobs = lista_graficos, ncol = 3)
# Salvar a imagem combinada usando ggsave()
# ggsave(filename = "todos_graficos_cazumba_iracema.png",  # Escolha um nome adequado para o arquivo
#        plot = imagem_combinada,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Cazumba-Iracema",  # Especifique o diretório onde você deseja salvar a imagem
#        dpi = 300,  # Define a resolução (DPI)
#        width = 14, height = 12, units = "in")  # Define o tamanho da imagem
#| label: fig-abundancia-resex-cazumba-iracema
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'
# Análise  de efeito da queda do tabocal nas tribos de borboletas frugívoras - AUTOMATIZADO
# RESEX do Cazumbá-Iracema
# Script: Isabela Freitas Oliveira
library(dplyr)
library(tidyr)
library(ggplot2)
library(car)
#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
dados_borboletas <- read.table("data/dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
dados_borboletas$ano <- as.factor(dados_borboletas$ano)
dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]
dados_borboletas <- dados_borboletas[!is.na(dados_borboletas$tribo), ]
dados_regiao_especifica <- dados_borboletas %>%
filter(uc == 'Resex_do_Cazumba-Iracema')
# Calcular o esforço amostral para cada combinação de uc_ea, expedicao e ano
esforco_por_expedicao <- dados_regiao_especifica %>%
group_by(uc_ea, uc, expedicao, ano) %>%
summarize(
max_dia_amostragem = max(dia_amostragem) - 1,
.groups = 'drop'
) %>%
mutate(
esforco_amostral = 16 * max_dia_amostragem
)
# Agregar o esforço de amostragem para cada uc_ea e ano
esforco_total_por_ea_ano <- esforco_por_expedicao %>%
group_by(uc_ea, ano) %>%
summarize(
esforco_total_ano = sum(esforco_amostral),
.groups = 'drop'
)
# Agregar o esforço de amostragem para cada uc e ano
esforco_total_por_uc_ano <- esforco_por_expedicao %>%
group_by(uc, ano) %>%
summarize(
esforco_total_ano = sum(esforco_amostral),
.groups = 'drop'
)
# Agregação para obter o esforço total por ano
esforco_por_ano <- esforco_total_por_uc_ano %>%
group_by(ano,uc) %>%
summarize(
esforco = sum(esforco_total_ano),
.groups = 'drop'
)
# Agregação para obter o número total de indivíduos por ano
num_ind_por_ano <- dados_regiao_especifica %>%
group_by(ano) %>%
summarize(
num_ind = sum(individuos, na.rm = TRUE),
.groups = 'drop'
)
#criando uma coluna de UA e selecionando somente as colunas interessadas pra analise
dados_regiao_especifica <- dados_regiao_especifica %>%
mutate(ua = paste(uc_ea, transeccao, sep = "_"))
#combinando os dados por UA por ano = 12 (3 ea x 4 parcelas)
df_abu_ano <- dados_regiao_especifica %>%
group_by(tribo, ua, uc_ea,uc, ano) %>%
summarise(abundancia = sum(individuos, na.rm = TRUE)) %>%
ungroup()
# Transforma o df para colocar os zeros
df_tabocal <- df_abu_ano %>%
spread(key = tribo, value = abundancia, fill = 0)
# Retorna ao formato longo para as análises
df_long <- df_tabocal %>%
pivot_longer(cols = Ageroniini:Satyrini, names_to = "tribo", values_to = "individuos")
# Agregação para obter a abundância total de cada tribo por ano
abundancia_por_ano <- df_long %>%
group_by(tribo, ano) %>%
summarize(
abundancia_total = sum(individuos)
)
# Juntar as tabelas pela coluna 'ano' e 'uc'
df_long_com_esforco <- left_join(df_long, esforco_por_ano, by = c("ano", "uc"))
# Calcular a abundância padronizada pelo esforço amostral
df_long <- df_long_com_esforco %>%
mutate(abundancia_padronizada = (individuos / esforco) * 100)
#
library(tidyverse)
# Realizar análise e gerar gráficos para cada tribo
tribos <- unique(df_long$tribo)
for (tribo_atual in tribos) {
cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
# Filtrar os dados para a tribo atual
df_tribo <- df_long %>%
filter(tribo == tribo_atual)
# Verificar se há dados para a tribo atual
if (nrow(df_tribo) == 0) {
cat("Não há dados para a tribo:", tribo_atual, "\n")
cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
next
}
}
# Calcular a mediana anual para cada ano
medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
# Adicione o ano de 2020, mesmo que não haja dados
medianas_anuais <- c(medianas_anuais, NA)
names(medianas_anuais)[length(medianas_anuais)] <- "2020"
# Calcular a mediana geral das medianas anuais
mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
# Remover os anos com NA das medianas anuais
medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
# Crie um vetor para armazenar os resultados dos testes
resultados_teste_anual <- numeric(length(medianas_anuais))
# Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
for (ano_atual in names(medianas_anuais)) {
# Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
# Armazena o valor p do teste no vetor de resultados
resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
}
# Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
df_plot <- data.frame(Ano = as.character(unique(c(names(medianas_anuais), "2020"))), MedianaAnual = c(medianas_anuais, NA))
df_plot$MedianaGeral <- mediana_geral_anual
df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
# Calcule os erros padrão para cada ano
erros_padrao <- sapply(names(medianas_anuais), function(ano) {
dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
return(erro_padrao_ano)
})
# Adicione os intervalos de confiança ao data frame
df_plot$ErroPadrao <- c(erros_padrao, NA)
df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
# Definir os limites do eixo y de acordo com os valores das medianas
y_limit <- max(df_plot$IntervaloConfiancaSup)*1.1
# Definir a cor de acordo com a tribo
cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
"#35978f"
} else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
"gray40"
} else {
"#bf812d"
}
# Crie o gráfico ajustado com pontos e linhas
p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
geom_point(color = cor_tribo, size = .7) +
geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
labs(title = paste("", tribo_atual),
x = "Ano",
y = "Mediana da Abundância / Esforço Amostral") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5, size = 8),
axis.title = element_text(size = 6),
axis.text = element_text(size = 6),
axis.line = element_line(color = "black"),
axis.ticks.y = element_line(color = "black"),
panel.grid.minor = element_blank(),
axis.line.x = element_blank(),
legend.position = "none") +  # Remover a legenda
ylim(0, y_limit) +  # Ajuste os limites conforme necessário
geom_text(data = df_plot[df_plot$ValorP < 0.05, ],
aes(x = Ano, y = IntervaloConfiancaSup, label = "*"),
vjust = -0.5,
size = 3)
# Exiba o gráfico ajustado
print(p_tribo)
# Salvar a imagem usando ggsave()
#   ggsave(filename = paste("mediana_", gsub(" ", "_", tolower(tribo_atual)), "_ajustado_pontos_linha_2020.png", sep = ""),  # Escolha um nome adequado para o arquivo
#          plot = p_tribo,  # O objeto ggplot
#          device = "png",  # Pode ser "jpeg", "tiff", etc.
#          path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Cazumba-Iracema",  # Especifique o diretório onde você deseja salvar o gráfico
#          dpi = 300,  # Define a resolução (DPI)
#          width = 6, height = 5, units = "in")  # Define o tamanho da imagem
# }
library(gridExtra)
# Definir uma lista para armazenar os gráficos
lista_graficos <- list()
# Defina a ordem das tribos
ordem_tribos <- c("Brassolini", "Morphini", "Haeterini", "Preponini", "Melanitini", "Anaeini",
"Epicaliini", "Epiphilini", "Coeini", "Satyrini", "Callicorini", "Biblidini", "Ageroniini")
for (tribo_atual in ordem_tribos) {
cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
# Filtrar os dados para a tribo atual
df_tribo <- df_long %>%
filter(tribo == tribo_atual)
# Verificar se há dados para a tribo atual
if (nrow(df_tribo) == 0) {
cat("Não há dados para a tribo:", tribo_atual, "\n")
cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
next
}
# Calcular a mediana anual para cada ano
medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
# Adicione o ano de 2020, mesmo que não haja dados
medianas_anuais <- c(medianas_anuais, NA)
names(medianas_anuais)[length(medianas_anuais)] <- "2020"
# Calcular a mediana geral das medianas anuais
mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
# Remover os anos com NA das medianas anuais
medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
# Crie um vetor para armazenar os resultados dos testes
resultados_teste_anual <- numeric(length(medianas_anuais))
# Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
for (ano_atual in names(medianas_anuais)) {
# Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
# Armazena o valor p do teste no vetor de resultados
resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
}
# Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
df_plot <- data.frame(Ano = as.character(unique(c(names(medianas_anuais), "2020"))), MedianaAnual = c(medianas_anuais, NA))
df_plot$MedianaGeral <- mediana_geral_anual
df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
# Calcule os erros padrão para cada ano
erros_padrao <- sapply(names(medianas_anuais), function(ano) {
dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
return(erro_padrao_ano)
})
# Adicione os intervalos de confiança ao data frame
df_plot$ErroPadrao <- c(erros_padrao, NA)
df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
# Definir os limites do eixo y de acordo com os valores das medianas
y_limit <- max(df_plot$IntervaloConfiancaSup) * 1.1
# Definir a cor de acordo com a tribo
cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
"#35978f"
} else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
"gray40"
} else {
"#bf812d"
}
# Crie o gráfico ajustado com pontos e linhas
p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
geom_point(color = cor_tribo, size = 1) +
geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
labs(title = paste("", tribo_atual),
x = "",
y = "Mediana da Abundância
/ Esforço Amostral") +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5, size = 8),
axis.title = element_text(size = 6),
axis.text = element_text(size = 6),
axis.line = element_line(color = "black"),
axis.ticks.y = element_line(color = "black"),
panel.grid.minor = element_blank(),
axis.line.x = element_blank(),
legend.position = "none") +  # Remover a legenda
ylim(0, y_limit) +  # Ajuste os limites conforme necessário
geom_text(data = df_plot[df_plot$ValorP < 0.05, ],
aes(x = Ano, y = IntervaloConfiancaSup, label = "*"),
vjust = -0.5,
size = 3)
# Adicionar o gráfico atual à lista
lista_graficos[[tribo_atual]] <- p_tribo
}
#| label: fig-abundancia-resex-cazumba-iracema-combinada
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'
#| fig-cap: "Variação na abundância das tribos de borboletas frugívoras na RESEX do Cazumbá-Iracema no período de 2020 a 2022."
# Combine todos os gráficos em uma única imagem
imagem_combinada <- grid.arrange(grobs = lista_graficos, ncol = 3)
# Salvar a imagem combinada usando ggsave()
# ggsave(filename = "todos_graficos_cazumba_iracema.png",  # Escolha um nome adequado para o arquivo
#        plot = imagem_combinada,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Cazumba-Iracema",  # Especifique o diretório onde você deseja salvar a imagem
#        dpi = 300,  # Define a resolução (DPI)
#        width = 14, height = 12, units = "in")  # Define o tamanho da imagem
#| label: fig-abundancia-resex-cazumba-iracema-combinada
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '80%'
#| fig-cap: "Variação na abundância das tribos de borboletas frugívoras na RESEX do Cazumbá-Iracema no período de 2020 a 2022."
# Combine todos os gráficos em uma única imagem
imagem_combinada <- grid.arrange(grobs = lista_graficos, ncol = 3)
# Salvar a imagem combinada usando ggsave()
# ggsave(filename = "todos_graficos_cazumba_iracema.png",  # Escolha um nome adequado para o arquivo
#        plot = imagem_combinada,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Cazumba-Iracema",  # Especifique o diretório onde você deseja salvar a imagem
#        dpi = 300,  # Define a resolução (DPI)
#        width = 14, height = 12, units = "in")  # Define o tamanho da imagem
#| label: fig-abundancia-resex-cazumba-iracema-combinada
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '90%'
#| fig-cap: "Variação na abundância das tribos de borboletas frugívoras na RESEX do Cazumbá-Iracema no período de 2020 a 2022."
# Combine todos os gráficos em uma única imagem
imagem_combinada <- grid.arrange(grobs = lista_graficos, ncol = 3)
# Salvar a imagem combinada usando ggsave()
# ggsave(filename = "todos_graficos_cazumba_iracema.png",  # Escolha um nome adequado para o arquivo
#        plot = imagem_combinada,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Cazumba-Iracema",  # Especifique o diretório onde você deseja salvar a imagem
#        dpi = 300,  # Define a resolução (DPI)
#        width = 14, height = 12, units = "in")  # Define o tamanho da imagem
knitr::opts_chunk$set(echo = TRUE, fig.pos = 'H')
if(!require(pacman)){install.packages("pacman")}
pacman::p_load(tidyverse,
tibble,
lubridate,
janitor,
descr,
knitr,
forcats,
treemapify,
reshape2,
DT,
data.table,
kableExtra,
plotly,
viridis,
cols4all,
ggExtra,
ggpubr,
patchwork,
gridExtra,
ggthemes,
plotly,
leaflet,
tmap,
mapview,
geobr,
sf,
rgdal,
sp,
htmltools,
htmlwidgets,
RColorBrewer,
randomcoloR
)
library(geobr)
mamiferos <- masto_aves |>
filter(classe == "Aves")
unique(mamiferos$taxon_validado)
mamiferos <- masto_aves |>
filter(classe == "Mammalia")
unique(mamiferos$taxon_validado)
mamiferos <- masto_aves |>
filter(classe == "Mammalia")
unique(mamiferos$taxon_validado)
knitr::opts_chunk$set(echo = TRUE)
#| label: tbl-lista-mamiferos
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| tab-cap: "Mamíferos registrados nas amostragens diurnas em transecções lineares do Programa Monitora, no período de 2014 a 2022. Os números entre parênteses correspondem ao número de espécies registradas para o táxon. Em vermelho estão os táxons ameaçados e sua respectiva categoria de ameaça. As espécies 'Deficientes em Dados (DD)' também estão indicadas."
tabela_mamiferos <- read.csv2("dados/tabelas/tabela_apendice_mamiferos.csv", encoding="UTF-8")
tab_mamiferos <- kbl(tabela_mamiferos,
booktabs = TRUE,
longtable = TRUE,
# caption = "Espécies de aves migratórias e seus respectivos escores de vulnerabilidade usados na análise do Zonation.*",
col.names = c("Ordem", "Família", "Táxon", "Categoria")) %>%
column_spec(3, italic = TRUE) %>%
kable_styling(full_width = F, bootstrap_options = c("striped", "hover", "condensed", "responsive"), latex_options = c("repeat_header"), repeat_header_text = "\\textit{(continuação)}")
knitr::opts_chunk$set(echo = TRUE, fig.pos = 'H')
if(!require(pacman)){install.packages("pacman")}
pacman::p_load(tidyverse,
tibble,
lubridate,
janitor,
descr,
knitr,
forcats,
treemapify,
reshape2,
DT,
data.table,
kableExtra,
plotly,
viridis,
cols4all,
ggExtra,
ggpubr,
patchwork,
gridExtra,
ggthemes,
plotly,
leaflet,
tmap,
mapview,
geobr,
sf,
rgdal,
sp,
htmltools,
htmlwidgets,
RColorBrewer,
randomcoloR
)
library(geobr)
#| label: tbl-lista-aves
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| tab-cap: "Táxons (gêneros e espécies) de aves registrados nas unidades de conservação amostradas no período de 2014 a 2022."
tabela_aves <- read.csv2("dados/tabelas/tabela_apendice_aves.csv", encoding="UTF-8")
tab_aves <- kbl(tabela_aves,
booktabs = TRUE,
longtable = TRUE,
# caption = "Espécies de aves migratórias e seus respectivos escores de vulnerabilidade usados na análise do Zonation.*",
col.names = c("Ordem", "Família", "Táxon", "Categoria")) %>%
column_spec(3, italic = TRUE) %>%
kable_styling(full_width = F, bootstrap_options = c("striped", "hover", "condensed", "responsive"), latex_options = c("repeat_header"), repeat_header_text = "\\textit{(continuação)}")
tab_aves
#| label: tbl-lista-mamiferos
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| tab-cap: "Mamíferos registrados nas amostragens diurnas em transecções lineares do Programa Monitora, no período de 2014 a 2022. Os números entre parênteses correspondem ao número de espécies registradas para o táxon. Em vermelho estão os táxons ameaçados e sua respectiva categoria de ameaça. As espécies 'Deficientes em Dados (DD)' também estão indicadas."
tabela_mamiferos <- read.csv2("dados/tabelas/tabela_apendice_mamiferos.csv", encoding="UTF-8")
tab_mamiferos <- kbl(tabela_mamiferos,
booktabs = TRUE,
longtable = TRUE,
# caption = "Espécies de aves migratórias e seus respectivos escores de vulnerabilidade usados na análise do Zonation.*",
col.names = c("Ordem", "Família", "Táxon", "Categoria")) %>%
column_spec(3, italic = TRUE) %>%
kable_styling(full_width = F, bootstrap_options = c("striped", "hover", "condensed", "responsive"), latex_options = c("repeat_header"), repeat_header_text = "\\textit{(continuação)}")
tab_mamiferos
mamiferos <- masto_aves |>
filter(classe == "Mammalia")
unique(mamiferos$taxon_validado)
masto_aves <- masto_aves %>%
mutate(
taxon_validado = case_when(
taxon_validado == "Mico spp" ~ "Mico sp",
taxon_validado == "Callicebus spp" ~ "Callicebus sp",
taxon_validado == "Lagothrix cana" ~ "Lagothrix lagothricha cana",
taxon_validado == "Lagothrix poeppigii" ~ "Lagothrix lagothricha poeppigii",
TRUE ~ taxon_validado))
mamiferos <- masto_aves |>
filter(classe == "Mammalia")
unique(mamiferos$taxon_validado)
ucs <- unique(masto_aves$ucs)
ucs <- unique(masto_aves$uc)
View(ucs)
masto_aves <- masto_aves %>%
mutate(
taxon_validado = case_when(
uc == "Esec de Maracá" & taxon_validado == "Ozotocerus bezoarticus" ~ "Mazama sp",
TRUE ~ taxon_validado))
mazama_maraca <- masto_aves |>
filter(uc == "Esec de Maracá" & taxon_validado == "Mazama sp")
View(mazama_maraca)
mamiferos <- masto_aves |>
filter(classe == "Mammalia")
unique(mamiferos$taxon_validado)
View(masto_aves)
unique(masto_aves$uc)
