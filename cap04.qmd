```{r library, echo=FALSE, message=FALSE, warning=FALSE}

library(tidyverse)
library(data.table)
library(descr)
library(RColorBrewer)
library(kableExtra)
library(knitr)
library(DT)
library(plotly)
library(ggthemes)
library(forcats)
library(leaflet)
library(sf)
library(rgdal)
library(treemapify)
library(reshape2)
library(randomcoloR)
library(gridExtra)
```


# Borboletas frugívoras 

</br>

**Isabela Freitas Oliveira**^1-2^ & **Onildo João Marini Filho**^1^


1. Centro Nacional de Pesquisa e Conservação da Biodiversidade do Cerrado e Restauração Ecológica - CBC  
*Instituto Chico Mendes de Conservação da Biodiversidade – ICMBio*  
*Parque Nacional de Brasília*  
*Via Epia, BR-450, Km 8,5*  
*70635-800 Brasília, DF*  

2. Coordenação de Monitoramento da Biodiversidade - COMOB  
*Instituto Chico Mendes de Conservação da Biodiversidade – ICMBio*  
*Complexo Administrativo EQSW 103/104 s/n*  
*70670-350 Brasília, DF*  

</br>


Em alguns grupos de insetos, a variação na riqueza, abundância e composição de espécies das comunidades ao longo do tempo vem sendo utilizada como indicador de alteração ambiental (@Gerlach_2013, @Arenhardt_2021, @Rodrigues_2019). No caso de borboletas, além desses parâmetros, a frequência relativa de ocorrência em nível de tribo também tem sido usada em estudos pontuais e programas de monitoramento (@Monitora_2018a). Esse indicador está relacionado tanto a alterações na vegetação (@Uehara_Prado_2006, @Ribeiro_2010) e eventos extremos climáticos, quanto a mudanças menos perceptíveis, como a redução na qualidade do ar (especialmente devido à presença de agrotóxicos) (@Smilanich_2012, @Ndakidemi_2016) e variações graduais do clima (temperatura e umidade) (@Devictor_2012). 

A abordagem que vem sendo utilizada no Programa Monitora considera a existência de um gradiente na associação entre as tribos de borboletas frugívoras e a estrutura das formações florestais, variando das florestas mais alteradas e/ou abertas até florestas mais adensadas e fechadas. O protocolo adotado pelo grupo de especialistas em borboletas considera que as tribos registradas estão relacionadas aos seguintes tipos de ambiente: 

- florestas fechadas/conservadas: Brassolini, Haeterini e Morphini. Em situações de perturbação da floresta a abundância relativa dessas tribos diminui consistentemente; 

- florestas abertas/alteradas (com abertura significativa no dossel): Ageroniini, Callicorini e Biblidini. As espécies dessas tribos são favorecidas por alterações na estrutura da floresta e suas abundâncias aumentam consistentemente com perturbações locais. 

As tribos Preponini, Melanitini, Anaeini, Epicaliini, Epiphilini, Coeini e Satyrini não apresentam associação clara com ambientes florestais ou não demonstram tendência definida. A abundância dessas tribos pode aumentar ou diminuir em resposta a perturbações da floresta, como abertura de clareiras ou eventuais alterações no dossel. 



</br>

## Implementação

</br>

No período de 2014 a 2022 o protocolo amostral de borboletas frugívoras foi aplicado de forma integral ou parcial em 50 UCs federais, totalizando 134 estações amostrais (EAs) e 536 unidades amostrais (UAs - transecções com quatro armadilhas atrativas do tipo Van Someren-Rydon) em operação. A maior parte das amostragens (39 UCs, - 78%) foi realizada no bioma Amazônico, seis UCs (12%) foram amostradas na Mata Atlântica e cinco UCs (10%) no Cerrado. O PARNA da Chapada dos Veadeiros, no bioma Cerrado, teve suas amostragens interrompidas, pois constatou-se que as EA haviam sido implantadas em ambientes savânicos.  Com a realocação dessas EAs em ambiente florestal (mata de galeria) as amostragens deverão ser retomadas e a UC será reintegrada ao Programa. No PARNA de Brasília as amostragens ainda estão sendo realizadas em ambiente savânico, mas estas deverão ser consideradas parte do componente Campestre e Savânico do Programa.  Os dados brutos validados do alvo global Borboletas Frugívoras - Componente Florestal totalizam atualmente 82.349 registros. 

Em 2022 foram amostradas apenas duas UCs (PARNA de Pacaás Novos e REBIO do Uatumã), mas os dados não foram enviados à Coordenação Geral de Pesquisa e Monitoramento da Biodiversidade - COMOB a tempo de comporem este relatório. O PARNA de Brasília realizou a campanha de 2022 no *Open Data Kit - ODK*, com os dados inseridos no *i-naturalist* e em planilha *google drive*. Portanto, esses dados não foram incorporados neste relatório, sendo necessária sua futura conversão e configuração para o formato padronizado da planilha .xls atualmente utilizada no Programa. 

 

Em 11 de março de 2020 a Organização Mundial de Saúde decretou estado de pandemia pela COVID-19 (doença respiratória causada pelo vírus SARS-CoV-2), situação que se estendeu até o início de 2023. As rigorosas restrições de locomoção e interação social impostas nos dois primeiros anos de disseminação da doença (2020-2021) impactaram negativamente as atividades de campo do Programa Monitora, com interrupção ou redução no esforço amostral do alvo borboletas frugívoras (@fig-evolucao-implementacao e @fig-esforco-amostral). 

 

Das 50 UCs federais com coleta de dados de borboletas frugívoras, 33 (66%) já estão consolidadas, com pelo menos três unidades amostrais (transecções lineares) em operação. Três UCs (x%) retomaram as amostragens em 2022 (PARNA do Superagui, ESEC Marac e ESEC da Terra do Meio), seis UCs (x% - PARNA da Bocaina, PARNA da Bodoquena, PARNA da Serra dos Órgãos, PARNA do Juruena, REBIO Guaribas e RESEXChico Mendes) não estão em operação (UCs com mais de dois anos consecutivos sem amostragem) e apenas uma UC (x% - RESEX Renascer) interrompeu a amostragem em 2022. 

 

Em 2022, a amostragem de borboletas frugívoras foi realizada em 40 das 50 UCs integrantes do Programa Monitora, nos três biomas florestais (Tabela x). O ano de 2022 teve 21 UCs a mais do que 2021, com um aumento de 26% na quantidade de Estações Amostrais (EAs) implementadas (@fig-evolucao-implementacao). Todas as oito novas UCs que aderiram ao Monitora e iniciaram a amostragem de borboletas são amazônicas e apoiadas pelo Programa ARPA. As ? UCs apoiadas pelo ARPA apresentam os melhores índices de implementação dos protocolos de borboletas, sendo que ?? delas (??%) já estão consolidadas, com pelo menos três UAs sendo amostradas.  




```{r grafico ucs_ativas_taxa_acumulado}
#| label: fig-evolucao-implementacao
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Evolução do número de unidades de conservação (UCs) e de estações amostrais (EAs) com amostragem de borboletas frugívoras no Programa Monitora de 2014 a 2022."

# Numero de UC's e EA's implementadas 214-2022
# Script: Isabela Freitas Oliveira

library(tidyverse)
library(ggplot2)
library(stringr)

dados_borboletas <- read.table("data/dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
dados_borboletas$ano <- factor(dados_borboletas$ano)
dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]


# Preparar os dados para o gráfico
contagem_uc_ea <- dados_borboletas %>%
  group_by(ano) %>%
  summarise(
    num_uc = n_distinct(uc),
    num_ea = n_distinct(uc_ea)
  )

dados_long <- contagem_uc_ea %>%
  pivot_longer(
    cols = -ano,
    names_to = "categoria",
    values_to = "contagem"
  )

dados_long$categoria <- factor(dados_long$categoria, levels = c("num_uc","num_ea"))
grafico_amostragens <- ggplot(dados_long, aes(x = ano, y = contagem, fill = categoria)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(
    aes(label = contagem), 
    position = position_dodge(width = 0.9), # ajustar 'width' para alinhar com as barras
    vjust = -0.40, # ajustar 'vjust' para mover o texto um pouco acima das barras
    size = 3
  ) +
  scale_fill_manual(
    values = c("num_uc" = "#35978f", "num_ea" = "#c7eae5"),
    labels = c("UC", "EA")) +
  labs(
    x = "",
    y = "Número de UC's e EA's amostradas",
    fill = "",
    title = str_wrap("", width = 35) # Quebra o título em duas linhas
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, hjust = 0, lineheight = 1.3),
    legend.position = c(0.1, 1), # Define a posição da legenda no canto superior esquerdo
    legend.justification = c(0, 1), # Define a justificação da legenda para o canto superior esquerdo
    legend.box.just = "left", # Alinha a legenda à esquerda
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    axis.title.x = element_text(size = 14), 
    axis.text.x = element_text(size = 10),  
    axis.line = element_line(colour = "gray40"),
    axis.line.x = element_blank(),
    axis.text.y = element_text(size = 10),
    axis.ticks.y = element_line(color = "black"),
    panel.grid.major = element_blank(),  # remove as linhas principais da grade
    panel.grid.minor = element_blank() 
  ) +
  scale_y_continuous(limits = c(0, 115))

print(grafico_amostragens)

#knitr::include_graphics("imagens/cap04/bo_evolucao_implementacao.JPG")

```


O esforço amostral vem aumentando quase linearmente a uma taxa de 15-20% ao ano, desde o início da implementação do Programa Monitora. O número de registros aumentou desproporcionalmente ao esforço em 2016, aparentemente devido a fatores climáticos. O número acumulado de registros de borboletas amostradas em nível de tribo (protocolo básico) totalizou ?? indivíduos (@fig-esforco-amostral). 


```{r grafico ucs_ativas_taxa_acumulado}
#| label: fig-esforco-amostral
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no número de registros de borboletas frugívoras e esforço amostral (dias*armadilhas) somada para todas as UCs participantes do Programa Monitora."


#Script: Isabela Freitas Oliveira

library(dplyr)

# Ler e limpar dados_borboletas
dados_borboletas <- read.table("data/dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
dados_borboletas <- dados_borboletas %>%
  filter(ano != "2023", !is.na(tribo))


# Calcular o esforço amostral para cada combinação de uc_ea, expedicao e ano
esforco_por_expedicao <- dados_borboletas %>%
  group_by(uc_ea, uc, expedicao, ano) %>%
  summarize(
    max_dia_amostragem = max(dia_amostragem) - 1,
    .groups = 'drop'
  ) %>%
  mutate(
    esforco_amostral = 16 * max_dia_amostragem
  )

# Agregar o esforço de amostragem para cada uc_ea e ano
esforco_total_por_ea_ano <- esforco_por_expedicao %>%
  group_by(uc_ea, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregar o esforço de amostragem para cada uc e ano
esforco_total_por_uc_ano <- esforco_por_expedicao %>%
  group_by(uc, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )


# Agregação para obter o esforço total por ano por uc
esforco_por_ano_uc <- esforco_total_por_uc_ano %>%
  group_by(ano,uc) %>%
  summarize(
    esforco = sum(esforco_total_ano),
    .groups = 'drop'
  )

# Agregação para obter o esforço total por ano
esforco_por_ano <- esforco_total_por_uc_ano %>%
  group_by(ano) %>%
  summarize(
    esforco = sum(esforco_total_ano),
    .groups = 'drop'
  )

# Agregação para obter o número total de indivíduos por ano
num_ind_por_ano <- dados_borboletas %>%
  group_by(ano) %>%
  summarize(
    num_ind = sum(individuos, na.rm = TRUE),
    .groups = 'drop'
  )


# Juntar as duas tabelas agregadas
tabela_final_esfoco <- left_join(esforco_por_ano, num_ind_por_ano, by = "ano")
#write.csv(tabela_final_esfoco, "tabela_final_esfoco.csv", row.names = FALSE)


#####Fazer o gráfico de Abundancia e esforço
# Definindo os dados para cada série separadamente
dados_esforco <- tabela_final_esfoco[, c("ano", "esforco")]
names(dados_esforco)[2] <- "valor"
dados_esforco$tipo <- "Esforço"

dados_abundancia <- tabela_final_esfoco[, c("ano", "num_ind")]
names(dados_abundancia)[2] <- "valor"
dados_abundancia$tipo <- "Abundância"

# Juntando os dados
dados_plot <- rbind(dados_esforco, dados_abundancia)

# Criando o gráfico
grafico <- ggplot(data = dados_plot, aes(x = ano, y = valor, colour = tipo, linetype = tipo, shape = tipo)) +
  geom_line(size = 1.0) +
  geom_point(size = 3) +
  scale_colour_manual(values = c("Esforço" = "#35978f", "Abundância" = "#dfc27d")) +
  scale_linetype_manual(values = c("Esforço" = "solid", "Abundância" = "solid")) +
  scale_shape_manual(values = c("Esforço" = 16, "Abundância" = 17)) +
  scale_y_continuous(
    "Esforço Amostral e Abundância",
    labels = scales::label_number(big.mark = ".", decimal.mark = ","),
    limits = c(0, 25000)
  ) +
  scale_x_continuous(breaks = tabela_final_esfoco$ano) +
  labs(
    title = "",
    x = "Ano",
    y = "Esforço Amostral e Abundância",
    colour = "",
    shape = "", # Isso ajuda a garantir que as formas correspondam na legenda
    linetype = "" # Isso ajuda a garantir que os tipos de linha correspondam na legenda
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = -0.5, size = 18, lineheight = 1.5), # Ajuste o lineheight conforme necessário
    legend.position = c(0.10, 0.93), # Define a posição da legenda no canto superior esquerdo
    legend.justification = c(0, 1), # Define a justificação da legenda para o canto superior esquerdo
    legend.box.just = "left", # Alinha a legenda à esquerda
    legend.box.background = element_rect(fill = "white", color = "white"),
    axis.ticks.y = element_line(color = "black"),
    axis.text.y = element_text(margin = margin(r = 5)),
    axis.text.x = element_text(margin = margin(r = 12)),
    axis.title.y = element_text(size = 10, margin = margin(r = 10)),
    axis.title.x = element_text(size = 10, margin = margin(t = 10)),
    axis.text = element_text(size = 10),
    axis.line = element_line(colour = "gray40"),
    legend.text = element_text(size = 10),
    axis.line.x = element_blank(),
    panel.grid.minor = element_blank()
  )

print(grafico)


#knitr::include_graphics("imagens/cap04/bo_esforco.JPG")

```



### Considerações sobre as amostragens na Mata Atlântica

</br>

Poucos indivíduos vêm sendo capturados nas UCs da Mata Atlântica. Esse padrão de baixa taxa de capturas vem sendo observado nas UCs da Serra do Mar e baixada litorânea (PARNAs da Serra dos Órgãos, da Serra da Bocaina e do Superagui). Ainda não sabemos o motivo do método não estar gerando resultados similares aos obtidos para UCs em outros ambientes. É possível que o período ideal de coleta seja o final da estação seca, devido ao padrão bimodal de ocorrência de borboletas nesses ambientes (@Ribeiro_2010; @Santos_2017), bem como em outras regiões montanhosas da Mata Atlântica.  

Nesse sentido, recomendamos que sejam exploradas outras possibilidades de desenho amostral para a Mata Atlântica, que possam ajudar a ampliar a quantidade de dados. Sugerimos implementar experimentalmente uma amostragem adicional no final da estação seca, nas UCs em que a logística permitir. Essa sugestão pode ser estendida para matas paludosas e sazonalmente alagadas. Outra questão importante a ser considerada na escolha do local de instalação das unidades amostrais é evitar a implantação das estações amostrais na face sul das montanhas nessas UCs.  Pode-se também avaliar a possibilidade de se amostrar no dossel das matas paludosas e sazonalmente alagadas, uma vez que a comunidade de sub-bosque de matas muito sombreadas e alagadas frequentemente se mostra pouco diversa (@Bellaver_2012; @DeVries_1987).  

</br>

## Resultados

</br>

### Amazônia

</br>

#### Síntese por região climática

</br>


O objetivo dessa seção é apresentar análises integrativas mostrando padrões regionais ou geográficos, indicando alterações na biodiversidade em escala ampla. Neste período inicial do Programa Monitora estão sendo estabelecidos os padrões normais de riqueza, abundância, composição e frequência relativa para cada UC e, possivelmente, para cada região (marco zero). Os primeiros resultados apresentados constituem a abundância relativa, representada pela proporção de registros de cada tribo, por região climática (@fig-regiao-climatica-central-amazonica a @fig-regiao-climatica-sudeste-amazonica). 

Ainda não temos dados populacionais para borboletas, uma vez que nas poucas UCs que iniciaram a aplicação do protocolo avançado os indivíduos capturados ainda não foram identificados, não sendo possível gerar tendências em nível de espécie. Uma das formas pretendidas para apresentação desse tipo de resultado é por meio de um índice de abundância, considerando o esforço amostral para cada população monitorada – igual ou similar ao Índice Planeta Vivo (@Pereira_2006). Para isso, necessitamos de dados populacionais coletados em amostragens anuais consecutivas para cada uma das espécies em cada unidade de conservação ou estação amostral. Com esse tipo de dado, poderemos obter tendências de aumento ou diminuição de populações em EAs, UCs ou regiões climáticas (@WWF_2018). 

Mesmo não tendo ainda acesso a dados populacionais, iremos utilizar o índice de abundância em nível de tribos, para servir de base para futuras análises. Este método já foi utilizado no relatório anterior do Programa Monitora (@Monitora_2018a).  


Os períodos de amostragem propostos no protocolo do Programa Monitora para borboletas frugívoras na Amazônia seguem a mesma lógica aplicada para as regiões Central e Sudeste do Brasil, onde temos alta abundância populacional e maior diversidade de espécies de borboletas frugívoras no final do período de chuvas intensas (@Checa_2009). Os períodos de amostragem para as regiões amazônicas apresentados a seguir baseiam-se na caracterização climática associada ao padrão de chuvas em toda a Amazônia (@fig-regioes-climaticas, reproduzida de @Marengo_2001). A partir da determinação dos regimes de chuva regionais, delimitamos alguns polígonos  contemplando as UCs integrantes do Programa Monitora, possibilitando estabelecer  a melhor época para amostragem (Tabela x),  considerando o regime de chuvas como uma característica regional importante para as borboletas frugívoras (Figura 4.4). 

</br>



```{r grafico ucs_ativas_taxa_acumulado}
#| label: fig-regioes_climaticas
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Regiões climáticas e regimes de chuva na Amazônia (@Marengo_2001)."

#knitr::include_graphics("imagens/cap04/bo_regioes_climaticas.JPG")

```


</br>

```{r grafico ucs_ativas_taxa_acumulado}
#| label: fig-regioes-climaticas
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '60%'
#| fig-cap: "Mapa mostrando a proposta de distribuição das UCs participantes do Programa Monitora nos polígonos das regiões climáticas da Amazônia definidos em função do regime de chuvas."

knitr::include_graphics("imagens/cap04/bo_mapa_ucs.jpeg")

```


</br>

Tabela x. Localização das UCs em relação às regiões climáticas da Amazônia, incluindo o período sugerido de amostragens de borboletas indicado como o final das chuvas. As UCs com \* situam-se entre duas ou mais regiões climáticas (q. = quinzena). As UCs marcadas com \# ainda não iniciaram a amostragem de borboletas.  

</br>


#### Representação de UCs nas regiões climáticas amazônicas

</br>


A região Amazônica concentra a maior parte do esforço amostral de borboletas frugívoras no Programa Monitora, com um crescimento gradativo de 2014 a 2022 no número de UCs e de EAs em quase todas as regiões climáticas (@fig-numero-ucs-eas-amostradas).  


```{r numero-ucs-amostradas}
#| label: fig-numero-ucs-amostradas
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '60%'



library(tidyverse)
library(ggplot2)
library(stringr)

# Carregar os dados
dados_borboletas <- read.table("data/dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]

# Converter o ano para fator
dados_borboletas$ano <- factor(dados_borboletas$ano)

# Filtrar os dados para incluir apenas regiões da Amazônia
dados_amazonia <- dados_borboletas %>%
  filter(regiao %in% c("central", "sudoeste", "sudeste", "norte", "leste"))

# Preparar os dados para o gráfico
contagem_uc_amazonia <- dados_amazonia %>%
  group_by(ano, regiao) %>%
  summarise(num_uc = n_distinct(uc))

# Cores para cada região da Amazônia
cores_amazonia <- c(
  "#c7eae5",
  "#80cdc1",
  "#35978f",
  "#01665e",
  "#003c30"
)

# Gráfico
grafico_uc_amazonia <- ggplot(contagem_uc_amazonia, aes(x = ano, y = num_uc, fill = regiao)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = cores_amazonia) + # Definindo as cores manualmente
  labs(
    x = "",
    y = "Número de UCs amostradas",
    fill = "",
    title = ""
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, hjust = 0, lineheight = 1.3),
    legend.position = c(0.1, 0.80), # Define a posição da legenda no canto superior esquerdo
    #legend.justification = c(0.1, 1), # Define a justificação da legenda para o canto superior esquerdo
    legend.box.just = "left", # Alinha a legenda à esquerda
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 8),
    axis.title.x = element_text(size = 12), 
    axis.text.x = element_text(size = 10),  
    #axis.line = element_line(colour = "gray40"),
    axis.line.x = element_blank(),
    #axis.text.y = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "gray40"),
    axis.ticks.y = element_line(color = "black")
    
  ) +
  scale_y_continuous(limits = c(0, 15))

# Exibir o gráfico
print(grafico_uc_amazonia)

##f1
grafico_uc_amazonia <- ggplot(contagem_uc_amazonia, aes(x = ano, y = num_uc, fill = regiao)) +
  geom_bar(stat = "identity", position = "dodge") +
  #geom_text(aes(label = num_uc), position = position_dodge(width = 0.9), vjust = -0.5, size = 3) + # Adicionando os valores
  scale_fill_manual(values = cores_amazonia) + # Definindo as cores manualmente
  labs(
    x = "",
    y = "Número de UCs amostradas",
    fill = "",
    title = "Número de UCs"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, hjust = 0.5, lineheight = 1.3),
    legend.position = c(0.1, 0.80), # Define a posição da legenda no canto superior esquerdo
    #legend.justification = c(0.1, 1), # Define a justificação da legenda para o canto superior esquerdo
    legend.box.just = "left", # Alinha a legenda à esquerda
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 8),
    axis.title.x = element_text(size = 12), 
    axis.text.x = element_text(size = 10),  
    #axis.line = element_line(colour = "gray40"),
    axis.line.x = element_blank(),
    #axis.text.y = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.line = element_line(colour = "gray40"),
    axis.ticks.y = element_line(color = "black")
    
  ) +
  scale_y_continuous(limits = c(0, 15))

# Exibir o gráfico
print(grafico_uc_amazonia)


# Salvar a imagem usando ggsave()
# ggsave(
#   filename = "grafico_numeros_de_uc_amazonia_f1.png",
#   plot = grafico_uc_amazonia,
#   device = "png",
#   path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",
#   dpi = 300,
#   width = 12,
#   height = 8,
#   units = "in"
# )


```




</br>

```{r numero-eas-amostradas}
#| label: fig-numero-eas-amostradas
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '60%'


# Carregar os dados
dados_borboletas <- read.table("data/dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]

# Converter o ano para fator
dados_borboletas$ano <- factor(dados_borboletas$ano)

# Filtrar os dados para incluir apenas regiões da Amazônia
dados_amazonia <- dados_borboletas %>%
  filter(regiao %in% c("central", "sudoeste", "sudeste", "norte", "leste"))

# Preparar os dados para o gráfico
contagem_ea_amazonia <- dados_amazonia %>%
  group_by(ano, regiao) %>%
  summarise(num_ea = n_distinct(uc_ea))

# Cores para cada região da Amazônia
cores_amazonia <- c(
  "#f6e8c3",
  "#dfc27d",
  "#bf812d",
  "#8c510a",
  "#543005"
)

# Gráfico
grafico_ea_amazonia <- ggplot(contagem_ea_amazonia, aes(x = ano, y = num_ea, fill = regiao)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = cores_amazonia) + # Definindo as cores manualmente
  labs(
    x = "Ano",
    y = "Número de EAs amostradas",
    fill = "",
    title = "Número de EAs"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, hjust = 0.5, lineheight = 1.3),
    legend.position = c(0.1, 0.8),
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 8),
    axis.title.x = element_text(size = 12),
    axis.text.x = element_text(size = 10),
    axis.title.y = element_text(size = 10),
    axis.text.y = element_text(size = 8),
    axis.line = element_line(colour = "gray40"),
    axis.line.x = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.ticks.y = element_line(color = "black")
  ) +
  scale_y_continuous(limits = c(0, 40))

# Exibir o gráfico
print(grafico_ea_amazonia)

# Salvar a imagem usando ggsave()
# ggsave(
#   filename = "grafico_numeros_de_ea_amazonia.png",
#   plot = grafico_ea_amazonia,
#   device = "png",
#   path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",
#   dpi = 300,
#   width = 12,
#   height = 8,
#   units = "in"
# )

```

</br>


```{r numero-ucs-eas-amostradas}
#| label: fig-numero-ucs-eas-amostradas
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'
#| fig-cap: "Número de unidades de conservação (UCs) e estações amostrais (EAs) do Programa Monitora na região amazônica por região climática com amostragem de borboletas frugívoras implementadas de 2014 a 2022."



library(gridExtra)
combinado<-grid.arrange (grafico_uc_amazonia, grafico_ea_amazonia, ncol=1)

# ggsave(
#   filename = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/ucs_eas_combinados.png",
#   plot = combinado,
#   device = "png",
#   dpi = 300,
#   width = 14,
#   height = 12,
#   units = "in"
# )

```


</br>


As amostragens de borboletas frugívoras na região climática Central Amazônica foram realizadas em 12 UCs: PARNA da Amazônia, PARNA dos Campos Amazônicos, PARNA do Jaú, PARNA Nascentes do Lago Jari, REBIO do Jaru, REBIO do Uatumã, ESEC da Terra do Meio, FLONA de Tapajós, RESEX do Lago do Capanã Grande, RESEX Riozinho do Anfrísio, RESEX Tapajós-Arapiuns e RESEX Verde para Sempre. Nessa região, 41 EAs foram amostradas de 2014 a 2022.  

```{r ajustes dos gráficos de assinaturas}
#| label: ajustes-graficos-assinaturas
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true


# Gráficos de dados Borboletas - Protocolo básico - Regiões da Amazônia - individual
### Tribos com asterisco estão ausentes nos dados
## Script: Isabela Freitas Oliveira

# Carregar bibliotecas
library(ggplot2)
library(dplyr)
library(scales)
library(tools)

# Definir o diretório de trabalho
#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")

# Função auxiliar para ajustar o título
ajustar_titulo <- function(titulo) {
  palavras <- strsplit(titulo, " ")[[1]]
  
  # Palavras que necessitam de correção de acentuação
  correcoes <- list(
    "leste" = "Região climática Leste Amazônica", "sudoeste" = "Região climática Sudoeste Amazônica", "central" = "Região climática Central Amazônica",
    "norte" = "Região climática Norte Amazônica", "sudeste" = "Região climática Sudeste Amazônica"
  )
  
  palavras <- sapply(palavras, function(palavra) {
    # Aplicar regras específicas para certas palavras
    if (tolower(palavra) %in% c("esec", "flona", "rebio", "resex", "parna")) {
      return(toupper(palavra))
    } else if (tolower(palavra) %in% c("de", "da", "do", "dos", "das")) {
      return(tolower(palavra))
    } else {
      # Corrigir acentuação, se necessário
      palavra_corrigida <- tolower(palavra)
      if (palavra_corrigida %in% names(correcoes)) {
        return(correcoes[[palavra_corrigida]])
      } else {
        return(tools::toTitleCase(palavra))
      }
    }
  })
  
  return(paste(palavras, collapse = " "))
}

# Função para gerar o gráfico para cada região
gerar_grafico_por_regiao <- function(dados, nome_regiao) {
  # Preparar o título
  titulo <- ajustar_titulo(nome_regiao)  # Utilizando a função de ajuste de título aqui
  
  # Filtrar os dados para a região atual
  dados_regiao <- subset(dados, regiao == nome_regiao & bioma == "Amazonia")
  dados_regiao <- dados_regiao[!is.na(dados_regiao$tribo), ] #tirar os dados 'NA' que estão na tribo
  
  # Calcular o total de indivíduos por ano para a região atual
  total_individuos_por_ano <- dados_regiao %>%
    group_by(ano) %>%
    summarise(total = sum(soma_individuos), .groups = 'drop')
  
  # Agregar dados por ano e tribo
  dados_agregados <- dados_regiao %>%
    group_by(ano, tribo) %>%
    summarize(frequencia = sum(soma_individuos), .groups = 'drop')
  
  # Calcular totais e proporções
  total_por_ano <- dados_agregados %>%
    group_by(ano) %>%
    summarize(total = sum(frequencia), .groups = 'drop')
  
  dados_agregados <- left_join(dados_agregados, total_por_ano, by = "ano") %>%
    mutate(proporcao = frequencia / total * 100)
  
  # Ajustar proporções
  dados_agregados <- dados_agregados %>%
    group_by(ano) %>%
    mutate(diferenca = 100 - sum(proporcao),
           proporcao_ajustada = ifelse(proporcao == max(proporcao), proporcao + diferenca, proporcao)) %>%
    ungroup() %>%
    dplyr::select(-diferenca, -proporcao) %>%
    rename(proporcao = proporcao_ajustada)
  
  # Ordem específica das tribos
  ordem_tribos <- c(
    "Brassolini", "Morphini", "Haeterini", 
    "Preponini", "Melanitini", "Anaeini", 
    "Epicaliini","Epiphilini", "Coeini",
    "Satyrini",
    "Callicorini", "Biblidini","Ageroniini"
  )
  
  # Cores correspondentes às tribos - BLINDSAFE colors (3 categorias de verde, 7 categorias de cinza e 3 categorias de marrom)
  cores_tribos <- c(
    "Brassolini" = "#35978f", "Morphini" = "#80cdc1", "Haeterini" = "#c7eae5", 
    "Preponini" = "gray65", "Melanitini" = "gray70", "Anaeini" = "gray75", 
    "Epicaliini" = "gray80", "Epiphilini" = "gray85", "Coeini" = "gray90",
    "Satyrini" = "gray95",
    "Callicorini" = "#f6e8c3", "Biblidini" = "#dfc27d","Ageroniini" = "#bf812d"
  )
  
  # Ajustar a ordem e as cores das tribos com base nas tribos presentes
  cores_tribos <- cores_tribos[ordem_tribos]
  
  # Assegurar que a coluna 'tribo_clean' respeite a ordem definida
  dados_agregados$tribo <- factor(dados_agregados$tribo, levels = ordem_tribos)
  
  # Criar um data frame com a frequência agregada por tribo
  #frequencias_por_tribo_ano <- aggregate(frequencia ~ tribo + ano, dados_agregados, sum)
  
  # Criar um data frame com a frequência agregada por tribo
  frequencias_por_tribo_ano <- aggregate(frequencia ~ tribo, dados_agregados, sum)
  
  # Criar uma função para determinar se um asterisco deve ser adicionado ao nome da tribo
  adicionar_asterisco <- function(nome_tribo) {
    # Verificar se existe alguma frequência igual a zero para essa tribo em qualquer ano
    if (any(frequencias_por_tribo_ano$tribo == nome_tribo & frequencias_por_tribo_ano$frequencia == 0)) {
      return(paste0(nome_tribo, "*"))
    } else {
      return(nome_tribo)
    }
  }
  
  # Aplicar a função a cada tribo para criar o vetor de rótulos
  labels_tribos <- sapply(ordem_tribos, adicionar_asterisco)
  
  # Construir o gráfico
  gg <- ggplot(dados_agregados) +
    geom_bar(aes(x = ano, y = proporcao, fill = tribo), stat = "identity", position = position_stack(reverse = FALSE)) +
    geom_text(data = total_individuos_por_ano, aes(x = ano, y = 100, label = total), vjust = -0.5, size = 3, hjust = 0.5)+
    scale_y_continuous(labels = scales::number_format(scale = 1, accuracy = 1), limits = c(0, 100))+
    scale_x_discrete(expand = c(0, 0)) +
    scale_fill_manual(values = cores_tribos, 
                      labels = labels_tribos,
                      breaks = ordem_tribos) +
    labs(title = titulo,
         x = "Ano",
         y = "Frequência relativa de ocorrência (%)",
         fill = "Tribo") +
    theme_minimal() +
    theme(legend.position = "right", 
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 10), 
          plot.title = element_text(hjust = 0.5, size = 16), 
          plot.subtitle = element_text(hjust = 0.5, size = 14),
          axis.text = element_text(size = 12), 
          axis.title = element_text(size = 12),
          axis.ticks.y = element_line(color = "black"),
          axis.line = element_line(colour = "gray40"),
          axis.line.x = element_blank()) +
    guides(fill = guide_legend(title = "Tribos", reverse = FALSE))
  
  
  # Exibir o gráfico
  print(gg)
}

# Carregar e preparar os dados
resultado_final <- read.csv("data/resultado_final.csv", header = TRUE)
resultado_final$ano <- factor(resultado_final$ano)
resultado_final$tribo <- gsub("\\*", "", resultado_final$tribo)
#resultado_final <- resultado_final[resultado_final$ano != "2023", ]


#------------------------------------------------
# # Função auxiliar para ajustar o título
# ajustar_titulo <- function(titulo) {
#   palavras <- strsplit(titulo, " ")[[1]]
# 
#   # Palavras que necessitam de correção de acentuação
#   correcoes <- list(
#     "leste" = "Região climática Leste Amazônica", "sudoeste" = "Região climática Sudoeste Amazônica", "central" = "Região climática Central Amazônica",
#     "norte" = "Região climática Norte Amazônica", "sudeste" = "Região climática Sudeste Amazônica"
#   )
# 
#   palavras <- sapply(palavras, function(palavra) {
#     # Aplicar regras específicas para certas palavras
#     if (tolower(palavra) %in% c("esec", "flona", "rebio", "resex", "parna")) {
#       return(toupper(palavra))
#     } else if (tolower(palavra) %in% c("de", "da", "do", "dos", "das")) {
#       return(tolower(palavra))
#     } else {
#       # Corrigir acentuação, se necessário
#       palavra_corrigida <- tolower(palavra)
#       if (palavra_corrigida %in% names(correcoes)) {
#         return(correcoes[[palavra_corrigida]])
#       } else {
#         return(tools::toTitleCase(palavra))
#       }
#     }
#   })
# 
#   return(paste(palavras, collapse = " "))
# }
# 
# # Função para gerar o gráfico para cada região
# gerar_grafico_por_regiao <- function(dados, nome_regiao) {
#   # Preparar o título
#   titulo <- ajustar_titulo(nome_regiao)  # Utilizando a função de ajuste de título aqui
# 
#   # Filtrar os dados para a região atual
#   dados_regiao <- subset(dados, regiao == nome_regiao & bioma == "Amazonia")
#   dados_regiao <- dados_regiao[!is.na(dados_regiao$tribo), ] #tirar os dados 'NA' que estão na tribo
# 
#   # Calcular o total de indivíduos por ano para a região atual
#   total_individuos_por_ano <- dados_regiao %>%
#     group_by(ano) %>%
#     summarise(total = sum(soma_individuos), .groups = 'drop')
# 
#   # Agregar dados por ano e tribo
#   dados_agregados <- dados_regiao %>%
#     group_by(ano, tribo) %>%
#     summarize(frequencia = sum(soma_individuos), .groups = 'drop')
# 
#   # Calcular totais e proporções
#   total_por_ano <- dados_agregados %>%
#     group_by(ano) %>%
#     summarize(total = sum(frequencia), .groups = 'drop')
# 
#   dados_agregados <- left_join(dados_agregados, total_por_ano, by = "ano") %>%
#     mutate(proporcao = frequencia / total * 100)
# 
#   # Ajustar proporções
#   dados_agregados <- dados_agregados %>%
#     group_by(ano) %>%
#     mutate(diferenca = 100 - sum(proporcao),
#            proporcao_ajustada = ifelse(proporcao == max(proporcao), proporcao + diferenca, proporcao)) %>%
#     ungroup() %>%
#     dplyr::select(-diferenca, -proporcao) %>%
#     rename(proporcao = proporcao_ajustada)
# 
#   # Ordem específica das tribos
#   ordem_tribos <- c(
#     "Brassolini", "Morphini", "Haeterini",
#     "Satyrini", "Coeini", "Epiphilini",
#     "Epicaliini", "Anaeini", "Melanitini",
#     "Preponini", "Callicorini", "Biblidini",
#     "Ageroniini"
#   )
# 
#   # Cores correspondentes às tribos - BLINDSAFE colors (3 categorias de verde, 7 categorias de cinza e 3 categorias de marrom)
#   cores_tribos <- c(
#     "Brassolini" = "#35978f", "Morphini" = "#80cdc1", "Haeterini" = "#c7eae5",
#     "Satyrini" = "gray95", "Coeini" = "gray90", "Epiphilini" = "gray85",
#     "Epicaliini" = "gray80", "Anaeini" = "gray75", "Melanitini" = "gray70",
#     "Preponini" = "gray65", "Callicorini" = "#f6e8c3", "Biblidini" = "#dfc27d",
#     "Ageroniini" = "#bf812d"
#   )
# 
#   # Ajustar a ordem e as cores das tribos com base nas tribos presentes
#   cores_tribos <- cores_tribos[ordem_tribos]
# 
#   # Assegurar que a coluna 'tribo_clean' respeite a ordem definida
#   dados_agregados$tribo <- factor(dados_agregados$tribo, levels = ordem_tribos)
# 
#   # Criar um data frame com a frequência agregada por tribo
#   #frequencias_por_tribo_ano <- aggregate(frequencia ~ tribo + ano, dados_agregados, sum)
# 
#   # Criar um data frame com a frequência agregada por tribo
#   frequencias_por_tribo_ano <- aggregate(frequencia ~ tribo, dados_agregados, sum)
# 
#   # Criar uma função para determinar se um asterisco deve ser adicionado ao nome da tribo
#   adicionar_asterisco <- function(nome_tribo) {
#     # Verificar se existe alguma frequência igual a zero para essa tribo em qualquer ano
#     if (any(frequencias_por_tribo_ano$tribo == nome_tribo & frequencias_por_tribo_ano$frequencia == 0)) {
#       return(paste0(nome_tribo, "*"))
#     } else {
#       return(nome_tribo)
#     }
#   }
# 
#   # Aplicar a função a cada tribo para criar o vetor de rótulos
#   labels_tribos <- sapply(ordem_tribos, adicionar_asterisco)
# 
#   # Construir o gráfico
#   gg <- ggplot(dados_agregados) +
#     geom_bar(aes(x = ano, y = proporcao, fill = tribo), stat = "identity", position = position_stack(reverse = FALSE)) +
#     geom_text(data = total_individuos_por_ano, aes(x = ano, y = 100, label = total), vjust = -0.5, size = 3, hjust = 0.5)+
#     scale_y_continuous(labels = scales::number_format(scale = 1, accuracy = 1), limits = c(0, 100))+
#     scale_x_discrete(expand = c(0, 0)) +
#     scale_fill_manual(values = cores_tribos,
#                       labels = labels_tribos,
#                       breaks = ordem_tribos) +
#     labs(title = titulo,
#          x = "Ano",
#          y = "Proporção relativa de ocorrência (%)",
#          fill = "Tribo") +
#     theme_minimal() +
#     theme(legend.position = "right",
#           legend.title = element_text(size = 14),
#           legend.text = element_text(size = 12),
#           plot.title = element_text(hjust = 0.5, size = 16),
#           plot.subtitle = element_text(hjust = 0.5, size = 14),
#           axis.text = element_text(size = 12),
#           axis.title = element_text(size = 13),
#           axis.line = element_line(colour = "gray40"),
#           axis.line.x = element_blank()) +
#     guides(fill = guide_legend(title = "Tribos", reverse = FALSE))
# 
# 
#   # Exibir o gráfico
#   print(gg)
# }
# 
# # Carregar e preparar os dados
# resultado_final <- read_csv("data/resultado_final.csv")
# resultado_final$ano <- factor(resultado_final$ano)
# resultado_final$tribo <- gsub("\\*", "", resultado_final$tribo)
# #resultado_final <- resultado_final[resultado_final$ano != "2023", ]


```

</br>

Apesar de termos uma boa representatividade de UCs e um número considerável de borboletas amostradas nos últimos anos, ainda observamos grandes variações nas proporções de tribos entre anos (@fig-regiao-climatica-central-amazonica). Considerando as variações na proporção de indivíduos, enquanto a tribo Brassolini apresentou tendência de diminuição de 2014 a 2017, Epicaliini mostrou tendência oposta. Por outro lado, as tribos Satyrini e Coeini tiveram comportamento errático, variando amplamente entre anos nesse período. Satyrini é a tribo com maior contribuição para o total de indivíduos e uma das que sofrem maiores flutuações. As tribos Callicorini, Biblidini e Ageroniini, características de ambientes alterados, tiveram baixíssima representação no conjunto de UCs da região climática central amazônica. Considerando esse conjunto de variações nas proporções das tribos, a assinatura regional sofreu consideráveis alterações de 2014 a 2018 (@fig-regiao-climatica-central-amazonica). 


</br>


```{r grafico regiao-climatica-central-amazonica}
#| label: fig-regiao-climatica-central-amazonica
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Padrões de bandas de abundância relativa de tribos de borboletas frugívoras para o período de 2014 a 2022 na região climática central da Amazônia. Números de indivíduos amostrados são indicados sobre as barras verticais."

# Definir a região de interesse - colocar as regiões 'norte', 'sudoeste', 'sudeste', 'leste', 'central'
regiao_interesse <- "central"

# Gerar o gráfico para a região de interesse
gerar_grafico_por_regiao(resultado_final, regiao_interesse)

```

</br>

Não foram coletados dados de borboletas frugívoras em UCs da região climática noroeste amazônica. Essa região é extremamente chuvosa e que praticamente não possui um período de estiagem, dificultando a definição do melhor período de amostragem de borboletas. Mesmo assim, seria importante implementar a amostragem de borboletas em, pelo menos, três EAs da RESEXdo Baixo Juruá, valendo-se dos parâmetros estabelecidos para a região climática norte amazônica (Tabela x). A identificação de ao menos mais duas UCs nessa região para compor o Programa Monitora seria bastante benéfica para conferir maior robustez ao conjunto de dados gerados em nível regional amazônico. 

As outras quatro regiões climáticas amazônicas possuem dois ou três anos a menos de amostragem do que a região Central. Desta forma, considerando o curto tempo de coleta, as análises dos dados dessas regiões ainda são pouco informativas e os resultados gerados não indicam tendências significativas a serem destacadas. 

Na região climática norte amazônica três UCs estão sendo amostradas: PARNA Serra da Mocidade, ESEC de Maracá e ESEC Niquiá. As amostragens nessa região começaram em 2017, resultando em menos tempo para definição das frequências normais (@fig-regiao-climatica-norte-amazonica).  


</br>


```{r grafico regiao-climatica-norte-amazonica}
#| label: fig-regiao-climatica-norte-amazonica
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Padrões de bandas de abundância relativa de tribos de borboletas frugívoras para o período de 2014 a 2022 na região climática norte da Amazônia. Números de indivíduos amostrados são indicados sobre as barras verticais."

# Definir a região de interesse - colocar as regiões 'norte', 'sudoeste', 'sudeste', 'leste', 'central'
regiao_interesse <- "norte"

# Gerar o gráfico para a região de interesse
gerar_grafico_por_regiao(resultado_final, regiao_interesse)

```

</br>

Já na região climática leste amazônica dados de borboletas frugívoras estão sendo coletados em quatro UCs: PARNA do Cabo Orange, PARNA Montanhas do Tumucumaque, REBIO do Gurupi e RESEXRenascer. A região apresentou menores variações nas proporções de tribos de 2016 a 2022. Essa é uma característica desejável para dados de monitoramento, pois menores variâncias aumentam o poder de discriminação entre amostras (@fig-regiao-climatica-leste-amazonica).  


</br>


```{r grafico regiao-climatica-leste-amazonica}
#| label: fig-regiao-climatica-leste-amazonica
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Padrões de bandas de abundância relativa de tribos de borboletas frugívoras para o período de 2017 a 2022 na região climática leste da Amazônia. Números de indivíduos amostrados são indicados sobre as barras verticais."

# Definir a região de interesse - colocar as regiões 'norte', 'sudoeste', 'sudeste', 'leste', 'central'
regiao_interesse <- "leste"

# Gerar o gráfico para a região de interesse
gerar_grafico_por_regiao(resultado_final, regiao_interesse)

```

</br>

Na região climática sudoeste amazônica, 13 UCs e 41 EAs foram amostradas até 2022: ESEC Rio Acre, FLONA de Jamari, PARNA da Serra da Cutia, PARNA da Serra do Divisor, PARNA de Pacaás Novos, PARNA Mapinguari, RESEX Arapixi, RESEX Barreiro das Antas, RESEX do Alto Tarauacá, RESEX do Cazumbá-Iracema, RESEX do Rio Cautário, RESEX Rio Ouro Preto e RESEX Riozinho da Liberdade. A região possui um padrão de assinatura de tribos diferente das demais, com maiores proporções das tribos associadas a ambientes perturbados, especialmente Ageroniini. A grande variação na proporção de Satyrini e, em menor grau, Morphini e Brassolini, gerou assinaturas bastante diferentes em anos consecutivos na região. Isso também pode ser um artefato estatístico relacionado ao aumento do número de estações amostrais e de borboletas amostradas no período, uma vez que estas variáveis aumentaram mais de seis vezes nesse período (@fig-regiao-climatica-sudoeste-amazonica).  


</br>


```{r grafico regiao-climatica-sudoeste-amazonica}
#| label: fig-regiao-climatica-sudoeste-amazonica
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Padrões de bandas de abundância relativa de tribos de borboletas frugívoras para o período de 2014 a 2022 na região climática sudoeste da Amazônia. Números de indivíduos amostrados são indicados sobre as barras verticais."

# Definir a região de interesse - colocar as regiões 'norte', 'sudoeste', 'sudeste', 'leste', 'central'
regiao_interesse <- "sudoeste"

# Gerar o gráfico para a região de interesse
gerar_grafico_por_regiao(resultado_final, regiao_interesse)

```


</br>

Na região climática sudeste amazônica dados de borboletas frugívoras estão coletados em apenas duas UCs: PARNA do Juruena e REBIO do Tapirapé. Apesar da baixa representação, houve grande homogeneidade nos resultados das áreas amostradas, com assinaturas bastante similares. Considerando que a metade sul da ESEC da Terra do Meio encontra-se nessa região, novas EAs que vierem a ser implementadas nessa porção da UC poderão ser adicionadas a esse conjunto regional (@fig-regiao-climatica-sudeste-amazonica). 

</br>

```{r grafico regiao-climatica-sudeste-amazonica}
#| label: fig-regiao-climatica-sudeste-amazonica
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Padrões de bandas de abundância relativa de tribos de borboletas frugívoras para o período de 2016 a 2022 na região climática sudeste da Amazônia. Números de indivíduos amostrados são indicados sobre as barras verticais."

# Definir a região de interesse - colocar as regiões 'norte', 'sudoeste', 'sudeste', 'leste', 'central'
regiao_interesse <- "sudeste"

# Gerar o gráfico para a região de interesse
gerar_grafico_por_regiao(resultado_final, regiao_interesse)

```

</br>



### Cerrado e Mata Atlântica  




```{r grafico-assinatura-cerrado}
#| label: fig-regiao-cerrado
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Padrões de bandas de abundância relativa de tribos de borboletas frugívoras para o período de 2014 a 2022 no bioma Cerrado. Números de indivíduos amostrados são indicados sobre as barras verticais."

##### Gráficos de dados Borboletas - Protocolo básico - Cerrado
### Tribos com asterisco estão ausentes no gráfico
## Script: Isabela Freitas Oliveira

# Função auxiliar para ajustar o título
ajustar_titulo <- function(titulo) {
  palavras <- strsplit(titulo, " ")[[1]]
  
  # Palavras que necessitam de correção de acentuação
  #correcoes <- list(
   # "Cerrado" = "Cerrado")
  
}

# Função para gerar o gráfico para cada unidade de conservação
gerar_grafico_por_bioma <- function(dados, nome_bioma) {
  # Preparar o título com as novas regras
  titulo <- gsub("_", " ", nome_bioma)
  titulo <- ajustar_titulo(titulo)  # Utilizando a função de ajuste de título aqui
  
  # Filtrar os dados para a unidade de conservação atual
  dados_bioma <- subset(dados, bioma == nome_bioma & bioma == "Cerrado")
  dados_bioma <- dados_bioma[!is.na(dados_bioma$tribo), ] #tirar os dados 'NA' que estão na tribo
  
  # Calcular o total de indivíduos por ano para a região atual
  total_individuos_por_ano <- dados_bioma %>%
    group_by(ano) %>%
    summarise(total = sum(soma_individuos), .groups = 'drop')
  
  # Agregar dados por ano e tribo
  dados_agregados <- dados_bioma %>%
    group_by(ano, tribo) %>%
    summarize(frequencia = sum(soma_individuos), .groups = 'drop')
  
  # Calcular totais e proporções
  total_por_ano <- dados_agregados %>%
    group_by(ano) %>%
    summarize(total = sum(frequencia), .groups = 'drop')
  
  dados_agregados <- left_join(dados_agregados, total_por_ano, by = "ano") %>%
    mutate(proporcao = frequencia / total * 100)
  
  # Ajustar proporções
  dados_agregados <- dados_agregados %>%
    group_by(ano) %>%
    mutate(diferenca = 100 - sum(proporcao),
           proporcao_ajustada = ifelse(proporcao == max(proporcao), proporcao + diferenca, proporcao)) %>%
    ungroup() %>%
    dplyr::select(-diferenca, -proporcao) %>%
    rename(proporcao = proporcao_ajustada)
  
  # Ordem específica das tribos
  ordem_tribos <- c(
    "Brassolini", "Morphini", "Haeterini", 
    "Preponini", "Melanitini", "Anaeini", 
    "Epicaliini","Epiphilini", "Coeini",
    "Satyrini",
    "Callicorini", "Biblidini","Ageroniini"
  )
  
  # Cores correspondentes às tribos - BLINDSAFE colors (3 categorias de verde, 7 categorias de cinza e 3 categorias de marrom)
  cores_tribos <- c(
    "Brassolini" = "#35978f", "Morphini" = "#80cdc1", "Haeterini" = "#c7eae5", 
    "Preponini" = "gray65", "Melanitini" = "gray70", "Anaeini" = "gray75", 
    "Epicaliini" = "gray80", "Epiphilini" = "gray85", "Coeini" = "gray90",
    "Satyrini" = "gray95",
    "Callicorini" = "#f6e8c3", "Biblidini" = "#dfc27d","Ageroniini" = "#bf812d"
  )
  
  # Ajustar a ordem e as cores das tribos com base nas tribos presentes
  cores_tribos <- cores_tribos[ordem_tribos]
  
  # Assegurar que a coluna 'tribo_clean' respeite a ordem definida
  dados_agregados$tribo <- factor(dados_agregados$tribo, levels = ordem_tribos)
  
  # Criar um data frame com a frequência agregada por tribo
  #frequencias_por_tribo_ano <- aggregate(frequencia ~ tribo + ano, dados_agregados, sum)
  
  # Criar um data frame com a frequência agregada por tribo
  frequencias_por_tribo_ano <- aggregate(frequencia ~ tribo, dados_agregados, sum)
  
  # Criar uma função para determinar se um asterisco deve ser adicionado ao nome da tribo
  adicionar_asterisco <- function(nome_tribo) {
    # Verificar se existe alguma frequência igual a zero para essa tribo em qualquer ano
    if (any(frequencias_por_tribo_ano$tribo == nome_tribo & frequencias_por_tribo_ano$frequencia == 0)) {
      return(paste0(nome_tribo, "*"))
    } else {
      return(nome_tribo)
    }
  }
  
  # Aplicar a função a cada tribo para criar o vetor de rótulos
  labels_tribos <- sapply(ordem_tribos, adicionar_asterisco)
  
  # Construir o gráfico
  gg <- ggplot(dados_agregados) +
    geom_bar(aes(x = ano, y = proporcao, fill = tribo), stat = "identity", position = position_stack(reverse = FALSE)) +
    geom_text(data = total_individuos_por_ano, aes(x = ano, y = 100, label = total), vjust = -0.5, size = 3, hjust = 0.5)+
    scale_y_continuous(labels = scales::number_format(scale = 1, accuracy = 1), limits = c(0, 100))+
    scale_x_discrete(expand = c(0, 0)) +
    scale_fill_manual(values = cores_tribos, 
                      labels = labels_tribos,
                      breaks = ordem_tribos) +
    labs(title = titulo,
         x = "Ano",
         y = "Frequência relativa de ocorrência (%)",
         fill = "Tribo") +
    theme_minimal() +
    theme(legend.position = "right", 
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 10), 
          plot.title = element_text(hjust = 0.5, size = 16), 
          plot.subtitle = element_text(hjust = 0.5, size = 12),
          axis.text = element_text(size = 12), 
          axis.title = element_text(size = 12),
          axis.ticks.y = element_line(color = "black"),
          axis.line = element_line(colour = "gray40"),
          axis.line.x = element_blank()) +
    guides(fill = guide_legend(title = "Tribos", reverse = FALSE))
  
  
  # Exibir o gráfico
  print(gg)
  
  # Retorna o gráfico para que possa ser salvo externamente
  return(gg)
  
}

# Carregar e preparar os dados
resultado_final<-read.csv("data/resultado_final.csv", header=T)
resultado_final$ano <- factor(resultado_final$ano)
resultado_final$tribo <- gsub("\\*", "", resultado_final$tribo)
#resultado_final <- resultado_final[resultado_final$ano != "2023", ]


# Obter todas as UC's do bioma Cerrado
biomas <- unique(resultado_final$bioma[resultado_final$bioma == "Cerrado"])

# Aplicar a função
 #lapply(biomas, function(bioma) gerar_grafico_por_bioma(resultado_final, bioma))
# 
 gerar_grafico_por_bioma(resultado_final, biomas)

```


</br>



</br>


```{r grafico regiao-mata-atlantica}
#| label: fig-regiao-mata-atlantica
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Padrões de bandas de abundância relativa de tribos de borboletas frugívoras para o período de 2015 a 2022 no bioma Mata Atlântica. Números de indivíduos amostrados são indicados sobre as barras verticais."

##### Gráficos de dados Borboletas - Protocolo básico - Mata Atlantica
### Tribos com asterisco estão ausentes no gráfico
## Script: Isabela Freitas Oliveira

# Carregar bibliotecas
library(ggplot2)
library(dplyr)
library(scales)
library(tools)

# Definir o diretório de trabalho
#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")

# Função auxiliar para ajustar o título
ajustar_titulo <- function(titulo) {
  palavras <- strsplit(titulo, " ")[[1]]
  
  # Palavras que necessitam de correção de acentuação
  correcoes <- list(
    "Mata_Atlantica" = "Mata Atlântica")
  
}

# Função para gerar o gráfico para cada unidade de conservação
gerar_grafico_por_bioma <- function(dados, nome_bioma) {
  # Preparar o título com as novas regras
  titulo <- gsub("_", " ", nome_bioma)
  titulo <- ajustar_titulo(titulo)  # Utilizando a função de ajuste de título aqui
  
  # Filtrar os dados para a unidade de conservação atual
  dados_bioma <- subset(dados, bioma == nome_bioma & bioma == "Mata_Atlantica")
  dados_bioma <- dados_bioma[!is.na(dados_bioma$tribo), ] #tirar os dados 'NA' que estão na tribo
  
  # Calcular o total de indivíduos por ano para a região atual
  total_individuos_por_ano <- dados_bioma %>%
    group_by(ano) %>%
    summarise(total = sum(soma_individuos), .groups = 'drop')
  
  # Agregar dados por ano e tribo
  dados_agregados <- dados_bioma %>%
    group_by(ano, tribo) %>%
    summarize(frequencia = sum(soma_individuos), .groups = 'drop')
  
  # Calcular totais e proporções
  total_por_ano <- dados_agregados %>%
    group_by(ano) %>%
    summarize(total = sum(frequencia), .groups = 'drop')
  
  dados_agregados <- left_join(dados_agregados, total_por_ano, by = "ano") %>%
    mutate(proporcao = frequencia / total * 100)
  
  # Ajustar proporções
  dados_agregados <- dados_agregados %>%
    group_by(ano) %>%
    mutate(diferenca = 100 - sum(proporcao),
           proporcao_ajustada = ifelse(proporcao == max(proporcao), proporcao + diferenca, proporcao)) %>%
    ungroup() %>%
    dplyr::select(-diferenca, -proporcao) %>%
    rename(proporcao = proporcao_ajustada)
  
  # Ordem específica das tribos
  ordem_tribos <- c(
    "Brassolini", "Morphini", "Haeterini", 
    "Preponini", "Melanitini", "Anaeini", 
    "Epicaliini","Epiphilini", "Coeini",
    "Satyrini",
    "Callicorini", "Biblidini","Ageroniini"
  )
  
  # Cores correspondentes às tribos - BLINDSAFE colors (3 categorias de verde, 7 categorias de cinza e 3 categorias de marrom)
  cores_tribos <- c(
    "Brassolini" = "#35978f", "Morphini" = "#80cdc1", "Haeterini" = "#c7eae5", 
    "Preponini" = "gray65", "Melanitini" = "gray70", "Anaeini" = "gray75", 
    "Epicaliini" = "gray80", "Epiphilini" = "gray85", "Coeini" = "gray90",
    "Satyrini" = "gray95",
    "Callicorini" = "#f6e8c3", "Biblidini" = "#dfc27d","Ageroniini" = "#bf812d"
  )
  
  # Ajustar a ordem e as cores das tribos com base nas tribos presentes
  cores_tribos <- cores_tribos[ordem_tribos]
  
  # Assegurar que a coluna 'tribo_clean' respeite a ordem definida
  dados_agregados$tribo <- factor(dados_agregados$tribo, levels = ordem_tribos)
  
  # Criar um data frame com a frequência agregada por tribo
  #frequencias_por_tribo_ano <- aggregate(frequencia ~ tribo + ano, dados_agregados, sum)
  
  # Criar um data frame com a frequência agregada por tribo
  frequencias_por_tribo_ano <- aggregate(frequencia ~ tribo, dados_agregados, sum)
  
  # Criar uma função para determinar se um asterisco deve ser adicionado ao nome da tribo
  adicionar_asterisco <- function(nome_tribo) {
    # Verificar se existe alguma frequência igual a zero para essa tribo em qualquer ano
    if (any(frequencias_por_tribo_ano$tribo == nome_tribo & frequencias_por_tribo_ano$frequencia == 0)) {
      return(paste0(nome_tribo, "*"))
    } else {
      return(nome_tribo)
    }
  }
  
  # Aplicar a função a cada tribo para criar o vetor de rótulos
  labels_tribos <- sapply(ordem_tribos, adicionar_asterisco)
  
  # Construir o gráfico
  gg <- ggplot(dados_agregados) +
    geom_bar(aes(x = ano, y = proporcao, fill = tribo), stat = "identity", position = position_stack(reverse = FALSE)) +
    geom_text(data = total_individuos_por_ano, aes(x = ano, y = 100, label = total), vjust = -0.5, size = 3, hjust = 0.5)+
    scale_y_continuous(labels = scales::number_format(scale = 1, accuracy = 1), limits = c(0, 100))+
    scale_x_discrete(expand = c(0, 0)) +
    scale_fill_manual(values = cores_tribos, 
                      labels = labels_tribos,
                      breaks = ordem_tribos) +
    labs(title = titulo,
         x = "Ano",
         y = "Frequência relativa de ocorrência (%)",
         fill = "Tribo") +
    theme_minimal() +
    theme(legend.position = "right", 
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 10), 
          plot.title = element_text(hjust = 0.5, size = 16), 
          plot.subtitle = element_text(hjust = 0.5, size = 12),
          axis.text = element_text(size = 12), 
          axis.title = element_text(size = 12),
          axis.ticks.y = element_line(color = "black"),
          axis.line = element_line(colour = "gray40"),
          axis.line.x = element_blank()) +
    guides(fill = guide_legend(title = "Tribos", reverse = FALSE))
  
  
  # Exibir o gráfico
  print(gg)
}

# Carregar e preparar os dados
resultado_final<-read.csv("data/resultado_final.csv", header=T)
resultado_final$ano <- factor(resultado_final$ano)
resultado_final$tribo <- gsub("\\*", "", resultado_final$tribo)
#resultado_final <- resultado_final[resultado_final$ano != "2023", ]

# Obter todas as UC's do bioma Cerrado
biomas <- unique(resultado_final$bioma[resultado_final$bioma == "Mata_Atlantica"])

# Aplicar a função
graficos<-lapply(biomas, function(bioma) gerar_grafico_por_bioma(resultado_final, bioma))

# Salvar a imagem usando ggsave()
# ggsave(filename = "MA.png",  # Escolha um nome adequado para o arquivo
#        plot = graficos[[1]],  # Especifique qual gráfico da lista deseja salvar
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Tribos por Ano/Relatório/Regional",  # Especifique o diretório onde você deseja salvar o gráfico
#        dpi = 300,  # Define a resolução (DPI)
#        width = 10, height = 8, units = "in")  # Define o tamanho da imagem

```


</br>


### Índice de abundância de tribos

</br>


A análise a seguir está em fase de teste conceitual, tanto do modelo estatístico quanto do significado biológico. Esse tipo de análise geralmente é feito com dados populacionais (abundância de indivíduos), estando seu cálculo e seu significado biológico já consagrados em diversos países (e.g., @Van_2019). Assim, nessa abordagem criamos um índice de abundância aplicável em nível de tribo e geramos análises para testar a sua viabilidade para o Programa Monitora. Caso adotado, esse índice poderá servir de base para o monitoramento de flutuações de abundância, complementando a abordagem das assinaturas, que tem um enfoque qualitativo. Entendemos que o Programa Monitora necessita de abordagens mais quantitativas, que possibilitem a mensuração e definição de níveis de variação sobre os quais possam ser gerados alertas para atenção ou verificação pela gestão da UC. 

</br>

#### Cálculo do índice  

</br>

O índice de abundância tem como base o número acumulado de indivíduos de cada tribo em cada ano numa dada área. Partindo da frequência absoluta de indivíduos por tribo por ano (*n*), fazemos inicialmente uma correção, somando um número muito pequeno a cada frequência absoluta, de forma a evitar a presença de zeros na matriz. Desta forma é obtida a frequência absoluta corrigida (*f* = *n* + 0,00001). Em seguida, é calculada a frequência, corrigida pelo esforço amostral (*fe* = número de armadilhas * dias de amostragem). Considerando que essa frequência mostra grandes variações, às vezes em duas ordens de grandeza, optamos por realizar uma transformação logarítmica para normalizar os dados. Assim, o próximo passo é calcular o *log10* da *fe*. O índice é finalmente calculado, comparando-se as variações da fe em anos consecutivos, considerando-se sempre o índice igual a 1,0 para o primeiro ano em que aquela “população” foi registrada. A Tabela x mostra o produto desse cálculo. Note que o ano base para algumas tribos difere do ano base da maioria das outras. 


</b>



Tabela x. Matriz resultante do cálculo das frequências absolutas divididas pelo esforço amostral, normalizadas (Log10) e transformadas em índice "populacional" para rastrear as variações a partir do ano em que uma "população" foi detectada (*i* = 1,000); *i* = índice de abundância a partir do ano base.

</br>


### Análises regionais

</br>

Assim como foi feito na seção anterior, utilizaremos os mesmos conjuntos de dados regionais para explorar a viabilidade do uso do índice proposto. A região climática central foi analisada separadamente por ser a única que possui dados para cinco anos consecutivos. Apesar de tanto a composição de UCs quanto o esforço amostral terem se multiplicado cinco vezes nesse período (Tabela x), ainda assim este é o melhor conjunto de dados que possuímos para gerar tais análises. 

Considerando que a visualização das 13 tribos em um mesmo gráfico impede a identificação do comportamento das curvas individualmente, optamos por apresentar dois gráficos para cada região, com as tribos mais representativas de ambientes bem preservados e de ambientes mais perturbados. As variações do índice para cada uma dessas tribos para a região climática central amazônica podem ser observadas na @fig-IA-regiao-climatica-central-amazonica-graficos-juntos, @fig-IA-regiao-climatica-sudeste-amazonica-graficos-juntos. O ano base mostra o valor inicial da “população” monitorada e é sempre igual a 1,0. As mudanças subsequentes mostram variações baseadas nessa população inicial, sendo que variações acima da linha de base indicam crescimento populacional e, abaixo, diminuição. Quase todas as tribos apresentaram o mesmo padrão de variação. Houve uma pequena diminuição em 2015 e 2016, seguida de um grande aumento em 2017 e um decréscimo posterior em 2018. É interessante observar que a tribo que apresentou menor variação no período foi Ageroniini, seguida de Morphini. 

Já para as demais regiões climáticas amazônicas, o esforço amostral e a quantidade de dados obtidos até 2022 foram inferiores aos obtidos para a região central, sendo ainda insuficientes para mostrar alterações significativas. A região norte passou a gerar dados apenas a partir de 2017 e ainda possui EAs suficientes para possibilitar essa análise. As regiões leste e sudoeste já possuem um bom número de EAs e, em poucos anos, terão dados suficientes para análise. A região sudeste ainda está em processo de implementação, sendo necessária a adesão de novas UCs ao Programa para a obtenção de um conjunto de dados adequado para análise. Essa região vem apresentando os melhores retornos de captura por unidade de esforço (CPUE), com muito mais indivíduos amostrados do que as outras regiões para um mesmo nível de esforço realizado (Tabela x), exceto pela região central (Tabela x). 

A abundância das tribos variou sem uma tendência predominante de 2016 a 2018 nas regiões climáticas norte, leste, sudoeste e sudeste amazônicas. Algumas tribos apresentaram picos de abundância para cima ou para baixo durante esses primeiros anos, como Callicorini, na região sudoeste, em 2017, e Biblidini, nas regiões leste e sudeste, também em 2017. Porém, a maioria das tribos encontravam-se, em 2018, próximas do valor original (1,0) (Figura x). Essas tribos apresentaram tamanhos populacionais muito pequenos em quase todas as UCs durante esse período. 

De forma geral, qualquer variação na quantidade de borboletas capturadas causou grandes variações no índice de abundância. Portanto, concluímos que o uso desse índice para “populações” pequenas não é aconselhável. Cabe avaliar se, com o aumento no esforço amostral e uma suposta ampliação na quantidade de dados acumulados, com reflexos no tamanho das populações analisadas, o método nos permitirá discriminar entre variações biologicamente significativas, associadas a algum tipo de alteração ambiental, de meras pequenas oscilações naturais casuais e erráticas nessas populações. 

</br>


Tabela x. Soma do número de indivíduos e esforço amostral (nº de EAs x nº de armadilhas x 12 dias de amostragem) no conjunto de sete UCs da região climática central amazônica. Esforço amostral em armadilhas x dia.


</br>


```{r grafico IA-regiao-climatica-central-amazonica-calculos}
#| label: fig-IA-regiao-climatica-central-amazonica
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true


##### Índices de abundância de tribos ao longo dos anos - Amazonia central
## Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)
library(scales)
library(vegan)


# Definir o diretório de trabalho
#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
df_indice<-read.csv("data/resultado_final_com_esforco.csv", header=T, sep = ';') # dataframe para fazer os gráficos
df_indice <- df_indice[!is.na(df_indice$tribo), ]

dados_regiao_especifica <- df_indice %>%
  filter(bioma == "Amazonia", regiao == "central")

# Agregar soma_individuos por tribo e ano
soma_individuos_por_tribo_ano <- dados_regiao_especifica %>%
  filter(soma_individuos > 0 ) %>%
  group_by(tribo, ano) %>%
  summarize(soma_individuos = sum(soma_individuos, na.rm = TRUE)) %>%
  ungroup()

# Verificar o esforço individual por uc_ea e expedicao
esforco_individual <- dados_regiao_especifica %>%
  group_by(uc, uc_ea, ano, expedicao) %>%
  summarize(esforco_individual = unique(esforco_amostral), na.rm = TRUE) %>%
  ungroup()

# Somar os esforços por expedicao
esforco_por_expedicao <- esforco_individual %>%
  group_by(uc, ano, expedicao) %>%
  summarize(esforco_total_expedicao = sum(esforco_individual, na.rm = TRUE)) %>%
  ungroup()

# Calcular o esforço total anual para cada ano
esforco_total_anual <- esforco_por_expedicao %>%
  group_by(ano) %>%
  summarize(esforco_total_anual = sum(esforco_total_expedicao, na.rm = TRUE)) %>%
  ungroup()

# Juntar com soma_individuos_por_tribo_ano
df_agregado <- soma_individuos_por_tribo_ano %>%
  left_join(esforco_total_anual, by = "ano") %>%
  ungroup()

# Calcular o índice de abundância
df_agregado <- df_agregado %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         log_frequencia_corrigida = log10(frequencia_corrigida)) %>%
  group_by(tribo) %>%
  arrange(ano) %>%
  mutate(indice_abundancia = if_else(row_number() == 1, 1, 
                                     log_frequencia_corrigida / lag(log_frequencia_corrigida))) %>%
  ungroup()

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo # tabela geral dos índices
df_tribo_ano_largo <- df_agregado %>%
  select(tribo, ano, indice_abundancia) %>% # Selecionar as colunas relevantes
  pivot_wider(names_from = ano, values_from = indice_abundancia) # Transformar para o formato largo

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))
#write.csv(df_tribo_ano_largo, "tabela_índice_tribo_ano_AM_Central.csv", row.names = FALSE)

```





```{r fig-IA-regiao-climatica-central-amazonica-floresta}
#| label: fig-IA-regiao-climatica-central-amazonica-floresta
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) na região climática central da Amazônia, no período de 2014 a 2022."

############
#Gráficos
library(ggplot2)

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Brassolini" = "#003C30", "Morphini" = "#23867E", "Haeterini" = "#97D6CD")
tipos_linhas <- c("Brassolini" = "solid", "Morphini" = "dashed", "Haeterini" = "twodash")

# Filtrar tribos florestais
tribos_selecionadas <- df_tribo_ano_largo %>%
  filter(tribo %in% c("Brassolini", "Morphini", "Haeterini")) %>%
  mutate(tribo = factor(tribo, levels = c("Brassolini", "Morphini", "Haeterini")))

# Transformar 'ano' para o formato longo e garantir que é numérico
dados_longos <- tribos_selecionadas %>%
  pivot_longer(cols = -tribo, names_to = "ano", values_to = "indice_abundancia")

# Certifique-se de que cada 'tribo' tem um 'tipo_linha' correspondente
dados_longos$tipo_linha <- ifelse(dados_longos$tribo == "Brassolini", "solid",
                                  ifelse(dados_longos$tribo == "Morphini","dashed","twodash"))

# Crie o gráfico
gg_florestal <- ggplot(dados_longos, aes(x = ano, y = indice_abundancia, group = tribo, color = tribo, linetype = tribo)) +
  geom_line(size = 0.7) +
  scale_color_manual(values = cores_linhas) +
  scale_y_continuous(limits = c(0, 2))+
  scale_linetype_manual(values = tipos_linhas) +
  geom_hline(yintercept = 1.0, linetype = "dashed", color = "darkgray", size = 0.7) +
  theme_minimal() +
  labs(title = "Região Climática Central Amazônica",
       subtitle = "Borboletas de áreas fechadas",
       x = "Ano",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = "Tribo",
       linetype = "Tribo") +
   theme(plot.title = element_text(hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        axis.title = element_text(size = 10),
        axis.text = element_text(size = 8),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        axis.line = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.minor = element_blank(),
        axis.line.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(linetype = tipos_linhas)))

# Exibir o gráfico
print(gg_florestal)

# Salvar a imagem usando ggsave()
#ggsave(filename = "indice de abundancia AM_Central_florestal_linhas_.png",  # Escolha um nome adequado para o arquivo
 #      plot = gg_florestal,  # O objeto ggplot
  #     device = "png",  # Pode ser "jpeg", "tiff", etc.
   #    path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",  # Especifique o diretório onde você deseja salvar o gráfico
    #   dpi = 300,  # Define a resolução (DPI)
     #  width = 12, height = 8, units = "in")  # Define o tamanho da imagem

```





```{r fig-IA-regiao-climatica-central-amazonica-areas-abertas}
#| label: fig-IA-regiao-climatica-central-amazonica-areas-abertas
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) na região climática central da Amazônia, no período de 2014 a 2022."

#Gráficos Borboletas de areas abertas

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Callicorini" = "#CFA154", "Biblidini" = "#824B09", "Ageroniini" = "#543005")
tipos_linhas <- c("Callicorini" = "twodash", "Biblidini" = "dashed", "Ageroniini" = "solid")

# Filtrar tribos florestais
tribos_selecionadas <- df_tribo_ano_largo %>%
  filter(tribo %in% c("Callicorini", "Biblidini", "Ageroniini")) %>%
  mutate(tribo = factor(tribo, levels = c("Callicorini", "Biblidini", "Ageroniini")))

# Transformar 'ano' para o formato longo e garantir que é numérico
dados_longos <- tribos_selecionadas %>%
  pivot_longer(cols = -tribo, names_to = "ano", values_to = "indice_abundancia")

# Certifique-se de que cada 'tribo' tem um 'tipo_linha' correspondente
dados_longos$tipo_linha <- ifelse(dados_longos$tribo == "Ageroniini", "solid",
                                  ifelse(dados_longos$tribo == "Biblidini","dashed","twodash"))

# Crie o gráfico
gg_aberto <- ggplot(dados_longos, aes(x = ano, y = indice_abundancia, group = tribo, color = tribo, linetype = tribo)) +
  geom_line(size = 0.7) +
  scale_y_continuous(limits = c(0, 2.0))+
  scale_color_manual(values = cores_linhas) +
  scale_linetype_manual(values = tipos_linhas) +
  geom_hline(yintercept = 1.0, linetype = "dashed", color = "darkgray", size = 0.7) +
  theme_minimal() +
  labs(title = "",
       subtitle = "Borboletas de áreas abertas",
       x = "",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = "Tribo",
       linetype = "Tribo") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        axis.title = element_text(size = 10),
        axis.text = element_text(size = 8),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        axis.line = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.minor = element_blank(),
        axis.line.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(linetype = tipos_linhas)))

# Exibir o gráfico
print(gg_aberto)

# Salvar a imagem usando ggsave()
#ggsave(filename = "indice de abundancia_AM_Central_aberto_linhas_.png",  # Escolha um nome adequado para o arquivo
 #      plot = gg_aberto,  # O objeto ggplot
  ##     device = "png",  # Pode ser "jpeg", "tiff", etc.
    #   path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",  # Especifique o diretório onde você deseja salvar o gráfico
     #  dpi = 300,  # Define a resolução (DPI)
      # width = 12, height = 8, units = "in")  # Define o tamanho da imagem



```




```{r fig-IA-regiao-climatica-central-amazonica-graficos-juntos}
#| label: fig-IA-regiao-climatica-central-amazonica-graficos-juntos
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) na região climática central da Amazônia, no período de 2014 a 2022."

######
#Gráficos juntos
library(gridExtra)
# Gráficos combinados
g <- grid.arrange(gg_florestal, gg_aberto, ncol = 1, heights = c(3, 3))

# ggsave("graficos_combinados_indice_AM_Central_linhas.png", 
#        grid.arrange(gg_florestal, gg_aberto, ncol = 1, heights = c(3,3)), 
#        device = "png", 
#        width = 12, height = 10, units = "in", 
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")



#knitr::include_graphics("imagens/cap04/bo_IA_regiao_climatica_central_amazonica.JPG")

```


</br>


```{r grafico IA-regiao-climatica-norte-amazonica-calculo}
#| label: fig-IA-regiao-climatica-norte-amazonica-calculo
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true

##### Índices de abundância de tribos ao longo dos anos - Amazonia Norte
## Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)


# Definir o diretório de trabalho
#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
df_indice<-read.csv("data/resultado_final_com_esforco.csv", header=T, sep = ';') # dataframe para fazer os gráficos
df_indice <- df_indice[!is.na(df_indice$tribo), ]

dados_regiao_especifica <- df_indice %>%
  filter(bioma == "Amazonia", regiao == "norte")

# Agregar soma_individuos por tribo e ano
soma_individuos_por_tribo_ano <- dados_regiao_especifica %>%
  filter(soma_individuos > 0 ) %>%
  group_by(tribo, ano) %>%
  summarize(soma_individuos = sum(soma_individuos, na.rm = TRUE)) %>%
  ungroup()

# Verificar o esforço individual por uc_ea e expedicao
esforco_individual <- dados_regiao_especifica %>%
  group_by(uc, uc_ea, ano, expedicao) %>%
  summarize(esforco_individual = unique(esforco_amostral), na.rm = TRUE) %>%
  ungroup()

# Somar os esforços por expedicao
esforco_por_expedicao <- esforco_individual %>%
  group_by(uc, ano, expedicao) %>%
  summarize(esforco_total_expedicao = sum(esforco_individual, na.rm = TRUE)) %>%
  ungroup()

# Calcular o esforço total anual para cada ano
esforco_total_anual <- esforco_por_expedicao %>%
  group_by(ano) %>%
  summarize(esforco_total_anual = sum(esforco_total_expedicao, na.rm = TRUE)) %>%
  ungroup()

# Juntar com soma_individuos_por_tribo_ano
df_agregado <- soma_individuos_por_tribo_ano %>%
  left_join(esforco_total_anual, by = "ano") %>%
  ungroup()

# Calcular o índice de abundância
df_agregado <- df_agregado %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         log_frequencia_corrigida = log10(frequencia_corrigida)) %>%
  group_by(tribo) %>%
  arrange(ano) %>%
  mutate(indice_abundancia = if_else(row_number() == 1, 1, 
                                     log_frequencia_corrigida / lag(log_frequencia_corrigida))) %>%
  ungroup()

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo # tabela geral dos índices
df_tribo_ano_largo <- df_agregado %>%
  select(tribo, ano, indice_abundancia) %>% # Selecionar as colunas relevantes
  pivot_wider(names_from = ano, values_from = indice_abundancia) # Transformar para o formato largo

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))
#write.csv(df_tribo_ano_largo, "tabela_índice_tribo_ano_MataAtlantica.csv", row.names = FALSE)

```




```{r grafico IA-regiao-climatica-norte-amazonica-floresta}
#| label: fig-IA-regiao-climatica-norte-amazonica-floresta
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) na região climática norte da Amazônia, no período de 2014 a 2022."


############
#Gráficos
library(ggplot2)

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Brassolini" = "#003C30", "Morphini" = "#23867E", "Haeterini" = "#97D6CD")
tipos_linhas <- c("Brassolini" = "solid", "Morphini" = "dashed", "Haeterini" = "twodash")

# Filtrar tribos florestais
tribos_selecionadas <- df_tribo_ano_largo %>%
  filter(tribo %in% c("Brassolini", "Morphini", "Haeterini")) %>%
  mutate(tribo = factor(tribo, levels = c("Brassolini", "Morphini", "Haeterini")))

# Transformar 'ano' para o formato longo e garantir que é numérico
dados_longos <- tribos_selecionadas %>%
  pivot_longer(cols = -tribo, names_to = "ano", values_to = "indice_abundancia")

# Certifique-se de que cada 'tribo' tem um 'tipo_linha' correspondente
dados_longos$tipo_linha <- ifelse(dados_longos$tribo == "Brassolini", "solid",
                                  ifelse(dados_longos$tribo == "Morphini","dashed","twodash"))

# Crie o gráfico
gg_florestal <- ggplot(dados_longos, aes(x = ano, y = indice_abundancia, group = tribo, color = tribo, linetype = tribo)) +
  geom_line(size = 0.7) +
  scale_y_continuous(limits = c(0.5, 1.5))+
  scale_color_manual(values = cores_linhas) +
  scale_linetype_manual(values = tipos_linhas) +
  geom_hline(yintercept = 1.0, linetype = "dashed", color = "darkgray", size = 0.7) +
  theme_minimal() +
  labs(title = "Região Climática Norte Amazônica",
       subtitle = "Borboletas de áreas fechadas",
       x = "Ano",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = "Tribo",
       linetype = "Tribo") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        axis.title = element_text(size = 10),
        axis.text = element_text(size = 8),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        axis.line = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.minor = element_blank(),
        axis.line.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(linetype = tipos_linhas)))

# Exibir o gráfico
print(gg_florestal)

# Salvar a imagem usando ggsave()
# ggsave(filename = "indice de abundancia AM_Norte_florestal_linhas_.png",  # Escolha um nome adequado para o arquivo
#        plot = gg_florestal,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",  # Especifique o diretório onde você deseja salvar o gráfico
#        dpi = 300,  # Define a resolução (DPI)
#        width = 12, height = 8, units = "in")  # Define o tamanho da imagem
######
```




```{r grafico IA-regiao-climatica-norte-amazonica-area-aberta}
#| label: fig-IA-regiao-climatica-norte-amazonica-area-aberta
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) na região climática norte da Amazônia, no período de 2014 a 2022."

#Gráficos Borboletas de areas abertas

# Definir as cores e tipos de linha para cada tribo # norte nao tem biblidinae
cores_linhas <- c("Callicorini" = "#CFA154", "Ageroniini" = "#543005")
tipos_linhas <- c("Callicorini" = "twodash", "Ageroniini" = "solid")

# Filtrar tribos florestais
tribos_selecionadas <- df_tribo_ano_largo %>%
  filter(tribo %in% c("Callicorini", "Ageroniini")) %>%
  mutate(tribo = factor(tribo, levels = c("Callicorini", "Ageroniini")))

# Transformar 'ano' para o formato longo e garantir que é numérico
dados_longos <- tribos_selecionadas %>%
  pivot_longer(cols = -tribo, names_to = "ano", values_to = "indice_abundancia")

# Certifique-se de que cada 'tribo' tem um 'tipo_linha' correspondente
dados_longos$tipo_linha <- ifelse(dados_longos$tribo == "Ageroniini", "solid",
                                  ifelse(dados_longos$tribo == "Callicorini","dotted", "twodash"))

# Crie o gráfico
gg_aberto <- ggplot(dados_longos, aes(x = ano, y = indice_abundancia, group = tribo, color = tribo, linetype = tribo)) +
  geom_line(size = 0.7) +
  scale_y_continuous(limits = c(0.5,1.5))+
  scale_color_manual(values = cores_linhas) +
  scale_linetype_manual(values = tipos_linhas) +
  geom_hline(yintercept = 1.0, linetype = "dashed", color = "darkgray", size = 0.7) +
  theme_minimal() +
  labs(title = "",
       subtitle = "Borboletas de áreas abertas",
       x = "",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = "Tribo",
       linetype = "Tribo") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        axis.title = element_text(size = 10),
        axis.text = element_text(size = 8),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        axis.line = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.minor = element_blank(),
        axis.line.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(linetype = tipos_linhas)))

# Exibir o gráfico
print(gg_aberto) #callicorini só tem 1 registro em 2022, por isso nao tem linha

# Salvar a imagem usando ggsave()
# ggsave(filename = "indice de abundancia_AM_Norte_aberto_linhas_.png",  # Escolha um nome adequado para o arquivo
#        plot = gg_aberto,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",  # Especifique o diretório onde você deseja salvar o gráfico
#        dpi = 300,  # Define a resolução (DPI)
#        width = 12, height = 8, units = "in")  # Define o tamanho da imagem


```


```{r grafico IA-regiao-climatica-norte-amazonica-graficos-juntos}
#| label: fig-IA-regiao-climatica-norte-amazonica-area-aberta-graficos-juntos
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) na região climática norte da Amazônia, no período de 2014 a 2022."

#Gráficos juntos
library(gridExtra)

grid.arrange(gg_florestal, gg_aberto, ncol = 1, heights = c(3,3))
# ggsave("graficos_combinados_indice_AM_Norte_linhas.png", 
#        grid.arrange(gg_florestal, gg_aberto, ncol = 1, heights = c(3,3)), 
#        device = "png", 
#        width = 12, height = 10, units = "in", 
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")


# knitr::include_graphics("imagens/cap04/bo_IA_areas_abertas_regiao_climatica_norte_amazonica.JPG")

```

</b>

```{r grafico IA-regiao-climatica-leste-amazonica-calculo}
#| label: fig-IA-regiao-climatica-leste-amazonica-calculo
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true


##### Índices de abundância de tribos ao longo dos anos - Mata Atlântica
## Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)


# Definir o diretório de trabalho
#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
df_indice<-read.csv("data/resultado_final_com_esforco.csv", header=T, sep = ';') # dataframe para fazer os gráficos
df_indice <- df_indice[!is.na(df_indice$tribo), ]

dados_regiao_especifica <- df_indice %>%
  filter(bioma == "Amazonia", regiao == "leste")

# Agregar soma_individuos por tribo e ano
soma_individuos_por_tribo_ano <- dados_regiao_especifica %>%
  filter(soma_individuos > 0 ) %>%
  group_by(tribo, ano) %>%
  summarize(soma_individuos = sum(soma_individuos, na.rm = TRUE)) %>%
  ungroup()

# Verificar o esforço individual por uc_ea e expedicao
esforco_individual <- dados_regiao_especifica %>%
  group_by(uc, uc_ea, ano, expedicao) %>%
  summarize(esforco_individual = unique(esforco_amostral), na.rm = TRUE) %>%
  ungroup()

# Somar os esforços por expedicao
esforco_por_expedicao <- esforco_individual %>%
  group_by(uc, ano, expedicao) %>%
  summarize(esforco_total_expedicao = sum(esforco_individual, na.rm = TRUE)) %>%
  ungroup()

# Calcular o esforço total anual para cada ano
esforco_total_anual <- esforco_por_expedicao %>%
  group_by(ano) %>%
  summarize(esforco_total_anual = sum(esforco_total_expedicao, na.rm = TRUE)) %>%
  ungroup()

# Juntar com soma_individuos_por_tribo_ano
df_agregado <- soma_individuos_por_tribo_ano %>%
  left_join(esforco_total_anual, by = "ano") %>%
  ungroup()

# Calcular o índice de abundância
df_agregado <- df_agregado %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         log_frequencia_corrigida = log10(frequencia_corrigida)) %>%
  group_by(tribo) %>%
  arrange(ano) %>%
  mutate(indice_abundancia = if_else(row_number() == 1, 1, 
                                     log_frequencia_corrigida / lag(log_frequencia_corrigida))) %>%
  ungroup()

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo # tabela geral dos índices
df_tribo_ano_largo <- df_agregado %>%
  select(tribo, ano, indice_abundancia) %>% # Selecionar as colunas relevantes
  pivot_wider(names_from = ano, values_from = indice_abundancia) # Transformar para o formato largo

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))
#write.csv(df_tribo_ano_largo, "tabela_índice_tribo_ano_MataAtlantica.csv", row.names = FALSE)


```



```{r grafico IA-regiao-climatica-leste-amazonica-floresta}
#| label: fig-IA-regiao-climatica-leste-amazonica-floresta
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) na região climática leste da Amazônia, no período de 2014 a 2022."

#Gráficos
library(ggplot2)

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Brassolini" = "#003C30", "Morphini" = "#23867E", "Haeterini" = "#97D6CD")
tipos_linhas <- c("Brassolini" = "solid", "Morphini" = "dashed", "Haeterini" = "twodash")

# Filtrar tribos florestais
tribos_selecionadas <- df_tribo_ano_largo %>%
  filter(tribo %in% c("Brassolini", "Morphini", "Haeterini")) %>%
  mutate(tribo = factor(tribo, levels = c("Brassolini", "Morphini", "Haeterini")))

# Transformar 'ano' para o formato longo e garantir que é numérico
dados_longos <- tribos_selecionadas %>%
  pivot_longer(cols = -tribo, names_to = "ano", values_to = "indice_abundancia")

# Certifique-se de que cada 'tribo' tem um 'tipo_linha' correspondente
dados_longos$tipo_linha <- ifelse(dados_longos$tribo == "Brassolini", "solid",
                                  ifelse(dados_longos$tribo == "Morphini","dashed","twodash"))

# Crie o gráfico
gg_florestal <- ggplot(dados_longos, aes(x = ano, y = indice_abundancia, group = tribo, color = tribo, linetype = tribo)) +
  geom_line(size = 0.7) +
  scale_y_continuous(limits = c(0.5, 2.0))+
  scale_color_manual(values = cores_linhas) +
  scale_linetype_manual(values = tipos_linhas) +
  geom_hline(yintercept = 1.0, linetype = "dashed", color = "darkgray", size = 0.7) +
  theme_minimal() +
  labs(title = "Região Climática Leste Amazônica",
       subtitle = "Borboletas de áreas fechadas",
       x = "Ano",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = "Tribo",
       linetype = "Tribo") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        axis.title = element_text(size = 10),
        axis.text = element_text(size = 8),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        axis.line = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.minor = element_blank(),
        axis.line.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(linetype = tipos_linhas)))

# Exibir o gráfico
print(gg_florestal)

# Salvar a imagem usando ggsave()
# ggsave(filename = "indice de abundancia AM_Leste_florestal_linhas_.png",  # Escolha um nome adequado para o arquivo
#        plot = gg_florestal,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",  # Especifique o diretório onde você deseja salvar o gráfico
#        dpi = 300,  # Define a resolução (DPI)
#        width = 12, height = 8, units = "in")  # Define o tamanho da imagem

```



```{r grafico IA-regiao-climatica-leste-amazonica-area-aberta}
#| label: fig-IA-regiao-climatica-leste-amazonica-area-aberta
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) na região climática leste da Amazônia, no período de 2014 a 2022."

######
#Gráficos Borboletas de areas abertas

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Callicorini" = "#CFA154", "Biblidini" = "#824B09", "Ageroniini" = "#543005")
tipos_linhas <- c("Callicorini" = "twodash", "Biblidini" = "dashed", "Ageroniini" = "solid")

# Filtrar tribos florestais
tribos_selecionadas <- df_tribo_ano_largo %>%
  filter(tribo %in% c("Callicorini", "Biblidini", "Ageroniini")) %>%
  mutate(tribo = factor(tribo, levels = c("Callicorini", "Biblidini", "Ageroniini")))

# Transformar 'ano' para o formato longo e garantir que é numérico
dados_longos <- tribos_selecionadas %>%
  pivot_longer(cols = -tribo, names_to = "ano", values_to = "indice_abundancia")

# Certifique-se de que cada 'tribo' tem um 'tipo_linha' correspondente
dados_longos$tipo_linha <- ifelse(dados_longos$tribo == "Ageroniini", "solid",
                                  ifelse(dados_longos$tribo == "Biblidini","dashed","twodash"))

# Crie o gráfico
gg_aberto <- ggplot(dados_longos, aes(x = ano, y = indice_abundancia, group = tribo, color = tribo, linetype = tribo)) +
  geom_line(size = 0.7) +
  scale_y_continuous(limits = c(0.5, 2.0))+
  scale_color_manual(values = cores_linhas) +
  scale_linetype_manual(values = tipos_linhas) +
  geom_hline(yintercept = 1.0, linetype = "dashed", color = "darkgray", size = 0.7) +
  theme_minimal() +
  labs(title = "",
       subtitle = "Borboletas de áreas abertas",
       x = "",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = "Tribo",
       linetype = "Tribo") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        axis.title = element_text(size = 10),
        axis.text = element_text(size = 8),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        axis.line = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.minor = element_blank(),
        axis.line.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(linetype = tipos_linhas)))

# Exibir o gráfico
print(gg_aberto)

# Salvar a imagem usando ggsave()
# ggsave(filename = "indice de abundancia_AM_Leste_aberto_linhas_.png",  # Escolha um nome adequado para o arquivo
#        plot = gg_aberto,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",  # Especifique o diretório onde você deseja salvar o gráfico
#        dpi = 300,  # Define a resolução (DPI)
#        width = 12, height = 8, units = "in")  # Define o tamanho da imagem


```



```{r grafico IA-regiao-climatica-leste-amazonica-graficos-juntos}
#| label: fig-IA-regiao-climatica-leste-amazonica-graficos-juntos
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) na região climática leste da Amazônia, no período de 2014 a 2022."

######
#Gráficos juntos
library(gridExtra)

grid.arrange(gg_florestal, gg_aberto, ncol = 1,  heights = c(3,3))
# ggsave("graficos_combinados_indice_AM_Leste_linhas.png", 
#        grid.arrange(gg_florestal, gg_aberto, ncol = 1,  heights = c(3,3)), 
#        device = "png", 
#        width = 12, height = 10, units = "in", 
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")

#knitr::include_graphics("imagens/cap04/bo_IA_areas_abertas_regiao_climatica_leste_amazonica.JPG")

```

</br>


```{r grafico IA-regiao-climatica-sudoeste-amazonica-calculo}
#| label: fig-IA-regiao-climatica-sudoeste-amazonica-calculo
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true

##### Índices de abundância de tribos ao longo dos anos - Sudoeste Amazônico
## Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)


# Definir o diretório de trabalho
#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
df_indice<-read.csv("data/resultado_final_com_esforco.csv", header=T, sep = ';') # dataframe para fazer os gráficos
df_indice <- df_indice[!is.na(df_indice$tribo), ]

dados_regiao_especifica <- df_indice %>%
  filter(bioma == "Amazonia", regiao == "sudoeste")

# Agregar soma_individuos por tribo e ano
soma_individuos_por_tribo_ano <- dados_regiao_especifica %>%
  filter(soma_individuos > 0 ) %>%
  group_by(tribo, ano) %>%
  summarize(soma_individuos = sum(soma_individuos, na.rm = TRUE)) %>%
  ungroup()

# Verificar o esforço individual por uc_ea e expedicao
esforco_individual <- dados_regiao_especifica %>%
  group_by(uc, uc_ea, ano, expedicao) %>%
  summarize(esforco_individual = unique(esforco_amostral), na.rm = TRUE) %>%
  ungroup()

# Somar os esforços por expedicao
esforco_por_expedicao <- esforco_individual %>%
  group_by(uc, ano, expedicao) %>%
  summarize(esforco_total_expedicao = sum(esforco_individual, na.rm = TRUE)) %>%
  ungroup()

# Calcular o esforço total anual para cada ano
esforco_total_anual <- esforco_por_expedicao %>%
  group_by(ano) %>%
  summarize(esforco_total_anual = sum(esforco_total_expedicao, na.rm = TRUE)) %>%
  ungroup()

# Juntar com soma_individuos_por_tribo_ano
df_agregado <- soma_individuos_por_tribo_ano %>%
  left_join(esforco_total_anual, by = "ano") %>%
  ungroup()

# Calcular o índice de abundância
df_agregado <- df_agregado %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         log_frequencia_corrigida = log10(frequencia_corrigida)) %>%
  group_by(tribo) %>%
  arrange(ano) %>%
  mutate(indice_abundancia = if_else(row_number() == 1, 1, 
                                     log_frequencia_corrigida / lag(log_frequencia_corrigida))) %>%
  ungroup()

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo # tabela geral dos índices
df_tribo_ano_largo <- df_agregado %>%
  select(tribo, ano, indice_abundancia) %>% # Selecionar as colunas relevantes
  pivot_wider(names_from = ano, values_from = indice_abundancia) # Transformar para o formato largo

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))
#write.csv(df_tribo_ano_largo, "tabela_índice_tribo_ano_AM_sudoeste.csv", row.names = FALSE)
```



```{r grafico IA-regiao-climatica-sudoeste-amazonica-floresta}
#| label: fig-IA-regiao-climatica-sudoeste-amazonica-floresta
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) na região climática norte da Amazônia, no período de 2014 a 2022."

#Gráficos
library(ggplot2)

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Brassolini" = "#003C30", "Morphini" = "#23867E", "Haeterini" = "#97D6CD")
tipos_linhas <- c("Brassolini" = "solid", "Morphini" = "dashed", "Haeterini" = "twodash")

# Filtrar tribos florestais
tribos_selecionadas <- df_tribo_ano_largo %>%
  filter(tribo %in% c("Brassolini", "Morphini", "Haeterini")) %>%
  mutate(tribo = factor(tribo, levels = c("Brassolini", "Morphini", "Haeterini")))

# Transformar 'ano' para o formato longo e garantir que é numérico
dados_longos <- tribos_selecionadas %>%
  pivot_longer(cols = -tribo, names_to = "ano", values_to = "indice_abundancia")

# Certifique-se de que cada 'tribo' tem um 'tipo_linha' correspondente
dados_longos$tipo_linha <- ifelse(dados_longos$tribo == "Brassolini", "solid",
                                  ifelse(dados_longos$tribo == "Morphini","dashed","twodash"))

# Crie o gráfico
gg_florestal <- ggplot(dados_longos, aes(x = ano, y = indice_abundancia, group = tribo, color = tribo, linetype = tribo)) +
  geom_line(size = 0.7) +
  scale_y_continuous(limits = c(0, 1.5)) +
  scale_color_manual(values = cores_linhas) +
  scale_linetype_manual(values = tipos_linhas) +
  geom_hline(yintercept = 1.0, linetype = "dashed", color = "darkgray", size = 0.7) +
  theme_minimal() +
  labs(title = "Região Climática Sudoeste Amazônica",
       subtitle = "Borboletas de áreas fechadas",
       x = "Ano",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = "Tribo",
       linetype = "Tribo") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        axis.title = element_text(size = 10),
        axis.text = element_text(size = 8),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        axis.line = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.minor = element_blank(),
        axis.line.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(linetype = tipos_linhas)))

# Exibir o gráfico
print(gg_florestal)

# Salvar a imagem usando ggsave()
# ggsave(filename = "indice de abundancia AM_Sudoeste_florestal_linhas_.png",  # Escolha um nome adequado para o arquivo
#        plot = gg_florestal,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",  # Especifique o diretório onde você deseja salvar o gráfico
#        dpi = 300,  # Define a resolução (DPI)
#        width = 12, height = 8, units = "in")  # Define o tamanho da imagem

```


```{r grafico IA-regiao-climatica-sudoeste-amazonica-area-aberta}
#| label: fig-IA-regiao-climatica-sudoeste-amazonica-area-aberta
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) na região climática norte da Amazônia, no período de 2014 a 2022."

#Gráficos Borboletas de areas abertas

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Callicorini" = "#CFA154", "Biblidini" = "#824B09", "Ageroniini" = "#543005")
tipos_linhas <- c("Callicorini" = "twodash", "Biblidini" = "dashed", "Ageroniini" = "solid")

# Filtrar tribos florestais
tribos_selecionadas <- df_tribo_ano_largo %>%
  filter(tribo %in% c("Callicorini", "Biblidini", "Ageroniini")) %>%
  mutate(tribo = factor(tribo, levels = c("Callicorini", "Biblidini", "Ageroniini")))

# Transformar 'ano' para o formato longo e garantir que é numérico
dados_longos <- tribos_selecionadas %>%
  pivot_longer(cols = -tribo, names_to = "ano", values_to = "indice_abundancia")

# Certifique-se de que cada 'tribo' tem um 'tipo_linha' correspondente
dados_longos$tipo_linha <- ifelse(dados_longos$tribo == "Ageroniini", "solid",
                                  ifelse(dados_longos$tribo == "Biblidini","dashed","twodash"))

# Crie o gráfico
gg_aberto <- ggplot(dados_longos, aes(x = ano, y = indice_abundancia, group = tribo, color = tribo, linetype = tribo))+
  scale_y_continuous(limits = c(0, 1.5))+
  geom_line(size = 0.7) +
  scale_color_manual(values = cores_linhas) +
  scale_linetype_manual(values = tipos_linhas) +
  geom_hline(yintercept = 1.0, linetype = "dashed", color = "darkgray", size = 0.7) +
  theme_minimal() +
  labs(title = "",
       subtitle = "Borboletas de áreas abertas",
       x = "",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = "Tribo",
       linetype = "Tribo") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        axis.title = element_text(size = 10),
        axis.text = element_text(size = 8),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        axis.line = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.minor = element_blank(),
        axis.line.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(linetype = tipos_linhas)))

# Exibir o gráfico
print(gg_aberto)

# Salvar a imagem usando ggsave()
# ggsave(filename = "indice de abundancia_AM_Sudoeste_aberto_linhas_.png",  # Escolha um nome adequado para o arquivo
#        plot = gg_aberto,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",  # Especifique o diretório onde você deseja salvar o gráfico
#        dpi = 300,  # Define a resolução (DPI)
#        width = 12, height = 8, units = "in")  # Define o tamanho da imagem


```



```{r grafico IA-regiao-climatica-sudoeste-amazonica-graficos-juntos}
#| label: fig-IA-regiao-climatica-sudoeste-amazonica-graficos-juntos
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) na região climática norte da Amazônia, no período de 2014 a 2022."

######
#Gráficos juntos
library(gridExtra)

grid.arrange(gg_florestal, gg_aberto, ncol = 1,  heights = c(3,3))
# ggsave("graficos_combinados_indice_AM_Sudoeste_linhas.png", 
#        grid.arrange(gg_florestal, gg_aberto, ncol = 1, heights = c(3,3)), 
#        device = "png", 
#        width = 12, height = 10, units = "in", 
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")


#knitr::include_graphics("imagens/cap04/bo_IA_areas_abertas_regiao_climatica_norte_amazonica.JPG")

```

</br>


```{r grafico IA-regiao-climatica-sudeste-amazonica-calculo}
#| label: fig-IA-regiao-climatica-sudeste-amazonica-calculo
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) na região climática sudeste da Amazônia, no período de 2014 a 2022."

##### Índices de abundância de tribos ao longo dos anos - Mata Atlântica
## Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)


# Definir o diretório de trabalho
#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
df_indice<-read.csv("data/resultado_final_com_esforco.csv", header=T, sep = ';') # dataframe para fazer os gráficos
df_indice <- df_indice[!is.na(df_indice$tribo), ]

dados_regiao_especifica <- df_indice %>%
  filter(bioma == "Amazonia", regiao == "sudeste")

# Agregar soma_individuos por tribo e ano
soma_individuos_por_tribo_ano <- dados_regiao_especifica %>%
  filter(soma_individuos > 0 ) %>%
  group_by(tribo, ano) %>%
  summarize(soma_individuos = sum(soma_individuos, na.rm = TRUE)) %>%
  ungroup()

# Verificar o esforço individual por uc_ea e expedicao
esforco_individual <- dados_regiao_especifica %>%
  group_by(uc, uc_ea, ano, expedicao) %>%
  summarize(esforco_individual = unique(esforco_amostral), na.rm = TRUE) %>%
  ungroup()

# Somar os esforços por expedicao
esforco_por_expedicao <- esforco_individual %>%
  group_by(uc, ano, expedicao) %>%
  summarize(esforco_total_expedicao = sum(esforco_individual, na.rm = TRUE)) %>%
  ungroup()

# Calcular o esforço total anual para cada ano
esforco_total_anual <- esforco_por_expedicao %>%
  group_by(ano) %>%
  summarize(esforco_total_anual = sum(esforco_total_expedicao, na.rm = TRUE)) %>%
  ungroup()

# Juntar com soma_individuos_por_tribo_ano
df_agregado <- soma_individuos_por_tribo_ano %>%
  left_join(esforco_total_anual, by = "ano") %>%
  ungroup()

# Calcular o índice de abundância
df_agregado <- df_agregado %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         log_frequencia_corrigida = log10(frequencia_corrigida)) %>%
  group_by(tribo) %>%
  arrange(ano) %>%
  mutate(indice_abundancia = if_else(row_number() == 1, 1, 
                                     log_frequencia_corrigida / lag(log_frequencia_corrigida))) %>%
  ungroup()

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo # tabela geral dos índices
df_tribo_ano_largo <- df_agregado %>%
  select(tribo, ano, indice_abundancia) %>% # Selecionar as colunas relevantes
  pivot_wider(names_from = ano, values_from = indice_abundancia) # Transformar para o formato largo

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))
#write.csv(df_tribo_ano_largo, "tabela_índice_tribo_ano_AM_sudeste.csv", row.names = FALSE)


```




```{r grafico IA-regiao-climatica-sudeste-amazonica-floresta}
#| label: fig-IA-regiao-climatica-sudeste-amazonica-floresta
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) na região climática sudeste da Amazônia, no período de 2014 a 2022."

############
#Gráficos
library(ggplot2)

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Brassolini" = "#003C30", "Morphini" = "#23867E", "Haeterini" = "#97D6CD")
tipos_linhas <- c("Brassolini" = "solid", "Morphini" = "dashed", "Haeterini" = "twodash")

# Filtrar tribos florestais
tribos_selecionadas <- df_tribo_ano_largo %>%
  filter(tribo %in% c("Brassolini", "Morphini", "Haeterini")) %>%
  mutate(tribo = factor(tribo, levels = c("Brassolini", "Morphini", "Haeterini")))

# Transformar 'ano' para o formato longo e garantir que é numérico
dados_longos <- tribos_selecionadas %>%
  pivot_longer(cols = -tribo, names_to = "ano", values_to = "indice_abundancia")

# Certifique-se de que cada 'tribo' tem um 'tipo_linha' correspondente
dados_longos$tipo_linha <- ifelse(dados_longos$tribo == "Brassolini", "solid",
                                  ifelse(dados_longos$tribo == "Morphini","dashed","twodash"))

# Crie o gráfico
gg_florestal <- ggplot(dados_longos, aes(x = ano, y = indice_abundancia, group = tribo, color = tribo, linetype = tribo)) +
  geom_line(size = 0.7) +
  scale_y_continuous(limits = c(0.5, 2.0))+
  scale_color_manual(values = cores_linhas) +
  scale_linetype_manual(values = tipos_linhas) +
  geom_hline(yintercept = 1.0, linetype = "dashed", color = "darkgray", size = 0.7) +
  theme_minimal() +
  labs(title = "Região Climática Sudeste Amazônica",
       subtitle = "Borboletas de áreas fechadas",
       x = "Ano",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = "Tribo",
       linetype = "Tribo") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        axis.title = element_text(size = 10),
        axis.text = element_text(size = 8),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        axis.line = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.minor = element_blank(),
        axis.line.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(linetype = tipos_linhas)))

# Exibir o gráfico
print(gg_florestal)

# Salvar a imagem usando ggsave()
# ggsave(filename = "indice de abundancia AM_Sudeste_florestal_linhas_.png",  # Escolha um nome adequado para o arquivo
#        plot = gg_florestal,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",  # Especifique o diretório onde você deseja salvar o gráfico
#        dpi = 300,  # Define a resolução (DPI)
#        width = 12, height = 8, units = "in")  # Define o tamanho da imagem

```


```{r grafico IA-regiao-climatica-sudeste-amazonica-area-aberta}
#| label: fig-IA-regiao-climatica-sudeste-amazonica-area-aberta
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) na região climática sudeste da Amazônia, no período de 2014 a 2022."

#Gráficos Borboletas de areas abertas

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Callicorini" = "#CFA154", "Biblidini" = "#824B09", "Ageroniini" = "#543005")
tipos_linhas <- c("Callicorini" = "twodash", "Biblidini" = "dashed", "Ageroniini" = "solid")

# Filtrar tribos florestais
tribos_selecionadas <- df_tribo_ano_largo %>%
  filter(tribo %in% c("Callicorini", "Biblidini", "Ageroniini")) %>%
  mutate(tribo = factor(tribo, levels = c("Callicorini", "Biblidini", "Ageroniini")))

# Transformar 'ano' para o formato longo e garantir que é numérico
dados_longos <- tribos_selecionadas %>%
  pivot_longer(cols = -tribo, names_to = "ano", values_to = "indice_abundancia")

# Certifique-se de que cada 'tribo' tem um 'tipo_linha' correspondente
dados_longos$tipo_linha <- ifelse(dados_longos$tribo == "Ageroniini", "solid",
                                  ifelse(dados_longos$tribo == "Biblidini","dashed","twodash"))

# Crie o gráfico
gg_aberto <- ggplot(dados_longos, aes(x = ano, y = indice_abundancia, group = tribo, color = tribo, linetype = tribo)) +
  geom_line(size = 0.7) +
  scale_y_continuous(limits = c(0.5, 2.0))+
  scale_color_manual(values = cores_linhas) +
  scale_linetype_manual(values = tipos_linhas) +
  geom_hline(yintercept = 1.0, linetype = "dashed", color = "darkgray", size = 0.7) +
  theme_minimal() +
  labs(title = "",
       subtitle = "Borboletas de áreas abertas",
       x = "",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = "Tribo",
       linetype = "Tribo") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        axis.title = element_text(size = 10),
        axis.text = element_text(size = 8),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        axis.line = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.minor = element_blank(),
        axis.line.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(linetype = tipos_linhas)))

# Exibir o gráfico
print(gg_aberto)

# Salvar a imagem usando ggsave()
# ggsave(filename = "indice de abundancia_AM_Sudeste_aberto_linhas_.png",  # Escolha um nome adequado para o arquivo
#        plot = gg_aberto,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",  # Especifique o diretório onde você deseja salvar o gráfico
#        dpi = 300,  # Define a resolução (DPI)
#        width = 12, height = 8, units = "in")  # Define o tamanho da imagem

```


```{r grafico IA-regiao-climatica-sudeste-amazonica-graficos-juntos}
#| label: fig-IA-regiao-climatica-sudeste-amazonica-graficos-juntos
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) na região climática sudeste da Amazônia, no período de 2014 a 2022."


######
#Gráficos juntos
library(gridExtra)

grid.arrange(gg_florestal, gg_aberto, ncol = 1,  heights = c(3,3))
# ggsave("graficos_combinados_indice_AM_Sudeste_linhas.png", 
#        grid.arrange(gg_florestal, gg_aberto,  ncol = 1,  heights = c(3,3)), 
#        device = "png", 
#        width = 12, height = 10, units = "in", 
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")


# knitr::include_graphics("imagens/cap04/bo_IA_areas_abertas_regiao_climatica_sudeste_amazonica.JPG")

```

</br>

```{r grafico IA-cerrado-calculo}
#| label: fig-IA-cerrado-calculo
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) no bioma Cerrado, no período de 2014 a 2022."

##### Índices de abundância de tribos ao longo dos anos - Cerrado
## Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)


# Definir o diretório de trabalho
#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
df_indice<-read.csv("data/resultado_final_com_esforco.csv", header=T, sep = ';') # dataframe para fazer os gráficos
df_indice <- df_indice[!is.na(df_indice$tribo), ]

dados_regiao_especifica <- df_indice %>%
  filter(bioma == "Cerrado")

# Agregar soma_individuos por tribo e ano
soma_individuos_por_tribo_ano <- dados_regiao_especifica %>%
  filter(soma_individuos > 0 ) %>%
  group_by(tribo, ano) %>%
  summarize(soma_individuos = sum(soma_individuos, na.rm = TRUE)) %>%
  ungroup()

# Verificar o esforço individual por uc_ea e expedicao
esforco_individual <- dados_regiao_especifica %>%
  group_by(uc, uc_ea, ano, expedicao) %>%
  summarize(esforco_individual = unique(esforco_amostral), na.rm = TRUE) %>%
  ungroup()

# Somar os esforços por expedicao
esforco_por_expedicao <- esforco_individual %>%
  group_by(uc, ano, expedicao) %>%
  summarize(esforco_total_expedicao = sum(esforco_individual, na.rm = TRUE)) %>%
  ungroup()

# Calcular o esforço total anual para cada ano
esforco_total_anual <- esforco_por_expedicao %>%
  group_by(ano) %>%
  summarize(esforco_total_anual = sum(esforco_total_expedicao, na.rm = TRUE)) %>%
  ungroup()

# Juntar com soma_individuos_por_tribo_ano
df_agregado <- soma_individuos_por_tribo_ano %>%
  left_join(esforco_total_anual, by = "ano") %>%
  ungroup()

# Calcular o índice de abundância
df_agregado <- df_agregado %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         log_frequencia_corrigida = log10(frequencia_corrigida)) %>%
  group_by(tribo) %>%
  arrange(ano) %>%
  mutate(indice_abundancia = if_else(row_number() == 1, 1, 
                                     log_frequencia_corrigida / lag(log_frequencia_corrigida))) %>%
  ungroup()

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo # tabela geral dos índices
df_tribo_ano_largo <- df_agregado %>%
  select(tribo, ano, indice_abundancia) %>% # Selecionar as colunas relevantes
  pivot_wider(names_from = ano, values_from = indice_abundancia) # Transformar para o formato largo

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))
#write.csv(df_tribo_ano_largo, "tabela_índice_tribo_ano_MataAtlantica.csv", row.names = FALSE)

#knitr::include_graphics("imagens/cap04/bo_IA_cerrado.JPG")

```


```{r grafico IA-cerrado-floresta}
#| label: fig-IA-cerrado-floresta
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) no bioma Mata Atlântica, no período de 2014 a 2022."


#Gráficos
library(ggplot2)

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Brassolini" = "#003C30", "Morphini" = "#23867E")
tipos_linhas <- c("Brassolini" = "solid", "Morphini" = "dashed")

# Filtrar tribos florestais
tribos_selecionadas <- df_tribo_ano_largo %>% #Nao teve captura de Haeterini
  filter(tribo %in% c("Brassolini", "Morphini")) %>%
  mutate(tribo = factor(tribo, levels = c("Brassolini", "Morphini")))

# Transformar 'ano' para o formato longo e garantir que é numérico
dados_longos <- tribos_selecionadas %>%
  pivot_longer(cols = -tribo, names_to = "ano", values_to = "indice_abundancia")

# Certifique-se de que cada 'tribo' tem um 'tipo_linha' correspondente
dados_longos$tipo_linha <- ifelse(dados_longos$tribo == "Brassolini", "solid",
                                  ifelse(dados_longos$tribo == "Morphini","dashed","twodash"))

# Crie o gráfico
gg_florestal <- ggplot(dados_longos, aes(x = ano, y = indice_abundancia, group = tribo, color = tribo, linetype = tribo)) +
  geom_line(size = 0.7) +
  scale_y_continuous(limits = c(0, 2.5))+
  scale_color_manual(values = cores_linhas) +
  scale_linetype_manual(values = tipos_linhas) +
  geom_hline(yintercept = 1.0, linetype = "dashed", color = "darkgray", size = 0.7) +
  theme_minimal() +
  labs(title = "Cerrado",
       subtitle = "Borbletas de áreas fechadas",
       x = "",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = "Tribo",
       linetype = "Tribo") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        axis.title = element_text(size = 10),
        axis.text = element_text(size = 8),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        axis.line = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.minor = element_blank(),
        axis.line.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(linetype = tipos_linhas)))

# Exibir o gráfico
print(gg_florestal)

# Salvar a imagem usando ggsave()
# ggsave(filename = "indice de abundancia Cerrado_florestal_linhas_.png",  # Escolha um nome adequado para o arquivo
#        plot = gg_florestal,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",  # Especifique o diretório onde você deseja salvar o gráfico
#        dpi = 300,  # Define a resolução (DPI)
#        width = 12, height = 8, units = "in")  # Define o tamanho da imagem
```


```{r grafico IA-cerrado-area-aberta}
#| label: fig-IA-cerrado-area-aberta
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) no bioma Mata Atlântica, no período de 2014 a 2022."


#Gráficos Borboletas de areas abertas

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Callicorini" = "#CFA154", "Biblidini" = "#824B09", "Ageroniini" = "#543005")
tipos_linhas <- c("Callicorini" = "twodash", "Biblidini" = "dashed", "Ageroniini" = "solid")

# Filtrar tribos florestais
tribos_selecionadas <- df_tribo_ano_largo %>%
  filter(tribo %in% c("Callicorini", "Biblidini", "Ageroniini")) %>%
  mutate(tribo = factor(tribo, levels = c("Callicorini", "Biblidini", "Ageroniini")))

# Transformar 'ano' para o formato longo e garantir que é numérico
dados_longos <- tribos_selecionadas %>%
  pivot_longer(cols = -tribo, names_to = "ano", values_to = "indice_abundancia")

# Certifique-se de que cada 'tribo' tem um 'tipo_linha' correspondente
dados_longos$tipo_linha <- ifelse(dados_longos$tribo == "Ageroniini", "solid",
                                  ifelse(dados_longos$tribo == "Biblidini","dashed","twodash"))

# Crie o gráfico
gg_aberto <- ggplot(dados_longos, aes(x = ano, y = indice_abundancia, group = tribo, color = tribo, linetype = tribo)) +
  geom_line(size = 0.7) +
  scale_y_continuous(limits = c(0, 2.5))+
  scale_color_manual(values = cores_linhas) +
  scale_linetype_manual(values = tipos_linhas) +
  geom_hline(yintercept = 1.0, linetype = "dashed", color = "darkgray", size = 0.7) +
  theme_minimal() +
  labs(title = "",
       subtitle = "Borboletas de áreas abertas",
       x = "",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = "Tribo",
       linetype = "Tribo") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        axis.title = element_text(size = 10),
        axis.text = element_text(size = 8),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        axis.line = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.minor = element_blank(),
        axis.line.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(linetype = tipos_linhas)))

# Exibir o gráfico #só tem 1 registro de callicorini, em 2018.
print(gg_aberto)

# Salvar a imagem usando ggsave()
# ggsave(filename = "indice de abundancia Cerrado_aberto_linhas_.png",  # Escolha um nome adequado para o arquivo
#        plot = gg_aberto,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",  # Especifique o diretório onde você deseja salvar o gráfico
#        dpi = 300,  # Define a resolução (DPI)
#        width = 12, height = 8, units = "in")  # Define o tamanho da imagem


```

</br>

```{r grafico IA-cerrado-juntos}
#| label: fig-IA-cerrado-juntos
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) no bioma Cerrado, no período de 2014 a 2022."

#Gráficos juntos
library(gridExtra)

grid.arrange(gg_florestal, gg_aberto, ncol = 1, heights = c(3, 3))
# ggsave("graficos_combinados_indice_Cerrado_linhas.png", 
#        grid.arrange(gg_florestal, gg_aberto, ncol = 1, heights = c(3, 3)), 
#        device = "png", 
#        width = 12, height = 10, units = "in", 
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")

```



</br>


```{r grafico IA-mata-atlantica-calculo}
#| label: fig-IA-mata-atlantica-calculo
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) no bioma Mata Atlântica, no período de 2014 a 2022."


##### Índices de abundância de tribos ao longo dos anos - Mata Atlântica
## Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)


# Definir o diretório de trabalho
#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
df_indice<-read.csv("data/resultado_final_com_esforco.csv", header=T, sep = ';') # dataframe para fazer os gráficos
df_indice <- df_indice[!is.na(df_indice$tribo), ]

dados_regiao_especifica <- df_indice %>%
  filter(bioma == "Mata_Atlantica")

# Agregar soma_individuos por tribo e ano
soma_individuos_por_tribo_ano <- dados_regiao_especifica %>%
  filter(soma_individuos > 0 ) %>%
  group_by(tribo, ano) %>%
  summarize(soma_individuos = sum(soma_individuos, na.rm = TRUE)) %>%
  ungroup()

# Verificar o esforço individual por uc_ea e expedicao
esforco_individual <- dados_regiao_especifica %>%
  group_by(uc, uc_ea, ano, expedicao) %>%
  summarize(esforco_individual = unique(esforco_amostral), na.rm = TRUE) %>%
  ungroup()

# Somar os esforços por expedicao
esforco_por_expedicao <- esforco_individual %>%
  group_by(uc, ano, expedicao) %>%
  summarize(esforco_total_expedicao = sum(esforco_individual, na.rm = TRUE)) %>%
  ungroup()

# Calcular o esforço total anual para cada ano
esforco_total_anual <- esforco_por_expedicao %>%
  group_by(ano) %>%
  summarize(esforco_total_anual = sum(esforco_total_expedicao, na.rm = TRUE)) %>%
  ungroup()

# Juntar com soma_individuos_por_tribo_ano
df_agregado <- soma_individuos_por_tribo_ano %>%
  left_join(esforco_total_anual, by = "ano") %>%
  ungroup()

# Calcular o índice de abundância
df_agregado <- df_agregado %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         log_frequencia_corrigida = log10(frequencia_corrigida)) %>%
  group_by(tribo) %>%
  arrange(ano) %>%
  mutate(indice_abundancia = if_else(row_number() == 1, 1, 
                                     log_frequencia_corrigida / lag(log_frequencia_corrigida))) %>%
  ungroup()

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo # tabela geral dos índices
df_tribo_ano_largo <- df_agregado %>%
  select(tribo, ano, indice_abundancia) %>% # Selecionar as colunas relevantes
  pivot_wider(names_from = ano, values_from = indice_abundancia) # Transformar para o formato largo

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))
#write.csv(df_tribo_ano_largo, "tabela_índice_tribo_ano_MataAtlantica.csv", row.names = FALSE)

#knitr::include_graphics("imagens/cap04/bo_IA_mata_atlantica.JPG")

```


```{r grafico IA-mata-atlantica-floresta}
#| label: fig-IA-mata-atlantica-floresta
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) no bioma Mata Atlântica, no período de 2014 a 2022."


#Gráficos
library(ggplot2)

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Brassolini" = "#003C30", "Morphini" = "#23867E")
tipos_linhas <- c("Brassolini" = "solid", "Morphini" = "dashed")

# Filtrar tribos florestais
tribos_selecionadas <- df_tribo_ano_largo %>% #Nao teve captura de Haeterini
  filter(tribo %in% c("Brassolini", "Morphini")) %>%
  mutate(tribo = factor(tribo, levels = c("Brassolini", "Morphini")))

# Transformar 'ano' para o formato longo e garantir que é numérico
dados_longos <- tribos_selecionadas %>%
  pivot_longer(cols = -tribo, names_to = "ano", values_to = "indice_abundancia")

# Certifique-se de que cada 'tribo' tem um 'tipo_linha' correspondente
dados_longos$tipo_linha <- ifelse(dados_longos$tribo == "Brassolini", "solid",
                                  ifelse(dados_longos$tribo == "Morphini","dashed","twodash"))

# Crie o gráfico
gg_florestal <- ggplot(dados_longos, aes(x = ano, y = indice_abundancia, group = tribo, color = tribo, linetype = tribo)) +
  geom_line(size = 0.7) +
  scale_y_continuous(limits = c(0.5, 3.0))+
  scale_color_manual(values = cores_linhas) +
  scale_linetype_manual(values = tipos_linhas) +
  geom_hline(yintercept = 1.0, linetype = "dashed", color = "darkgray", size = 0.7) +
  theme_minimal() +
  labs(title = "Mata Atlântica",
       subtitle = "Borboletas de áreas fechadas",
       x = "",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = "Tribo",
       linetype = "Tribo") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        axis.title = element_text(size = 10),
        axis.text = element_text(size = 8),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        axis.line = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.minor = element_blank(),
        axis.line.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(linetype = tipos_linhas)))

# Exibir o gráfico
print(gg_florestal)

# Salvar a imagem usando ggsave()
# ggsave(filename = "indice de abundancia MataAtlantica_florestal_linhas_.png",  # Escolha um nome adequado para o arquivo
#        plot = gg_florestal,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",  # Especifique o diretório onde você deseja salvar o gráfico
#        dpi = 300,  # Define a resolução (DPI)
#        width = 12, height = 8, units = "in")  # Define o tamanho da imagem

```


```{r grafico IA-mata-atlantica-area-aberta}
#| label: fig-IA-mata-atlantica-area-aberta
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) no bioma Mata Atlântica, no período de 2014 a 2022."


#Gráficos Borboletas de areas abertas

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Callicorini" = "#CFA154", "Biblidini" = "#824B09", "Ageroniini" = "#543005")
tipos_linhas <- c("Callicorini" = "twodash", "Biblidini" = "dashed", "Ageroniini" = "solid")

# Filtrar tribos florestais
tribos_selecionadas <- df_tribo_ano_largo %>%
  filter(tribo %in% c("Callicorini", "Biblidini", "Ageroniini")) %>%
  mutate(tribo = factor(tribo, levels = c("Callicorini", "Biblidini", "Ageroniini")))

# Transformar 'ano' para o formato longo e garantir que é numérico
dados_longos <- tribos_selecionadas %>%
  pivot_longer(cols = -tribo, names_to = "ano", values_to = "indice_abundancia")

# Certifique-se de que cada 'tribo' tem um 'tipo_linha' correspondente
dados_longos$tipo_linha <- ifelse(dados_longos$tribo == "Ageroniini", "solid",
                                  ifelse(dados_longos$tribo == "Biblidini","dashed","twodash"))

# Crie o gráfico
gg_aberto <- ggplot(dados_longos, aes(x = ano, y = indice_abundancia, group = tribo, color = tribo, linetype = tribo)) +
  geom_line(size = 0.7) +
  scale_y_continuous(limits = c(0.5, 3.0))+
  scale_color_manual(values = cores_linhas) +
  scale_linetype_manual(values = tipos_linhas) +
  geom_hline(yintercept = 1.0, linetype = "dashed", color = "darkgray", size = 0.7) +
  theme_minimal() +
  labs(title = "",
       subtitle = "Borboletas de áreas abertas",
       x = "",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = "Tribo",
       linetype = "Tribo") +
  theme(plot.title = element_text(hjust = 0.5, size = 14),
        plot.subtitle = element_text(hjust = 0.5, size = 12),
        axis.title = element_text(size = 10),
        axis.text = element_text(size = 8),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 10),
        axis.line = element_line(color = "black"),
        axis.ticks.y = element_line(color = "black"),
        panel.grid.minor = element_blank(),
        axis.line.x = element_blank()) +
  guides(color = guide_legend(override.aes = list(linetype = tipos_linhas)))

# Exibir o gráfico #só tem 1 registro de callicorini, em 2018.
print(gg_aberto)

# Salvar a imagem usando ggsave()
# ggsave(filename = "indice de abundancia MataAtlantica_aberto_linhas_.png",  # Escolha um nome adequado para o arquivo
#        plot = gg_aberto,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",  # Especifique o diretório onde você deseja salvar o gráfico
#        dpi = 300,  # Define a resolução (DPI)
#        width = 12, height = 8, units = "in")  # Define o tamanho da imagem


```


```{r grafico IA-mata-atlantica-juntos}
#| label: fig-IA-mata-atlantica-juntos
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras indicadoras de florestas íntegras (tons de verde) e de florestas perturbadas (tons de laranja) no bioma Cerrado, no período de 2014 a 2022."

#Gráficos juntos
library(gridExtra)

grid.arrange(gg_florestal, gg_aberto, ncol = 1,  heights = c(3,3))
# ggsave("graficos_combinados_indice_MataAtlantica_linhas.png", 
#        grid.arrange(gg_florestal, gg_aberto, ncol = 1,  heights = c(3,3)), 
#        device = "png", 
#        width = 12, height = 10, units = "in", 
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")


#knitr::include_graphics("imagens/cap04/bo_IA_cerrado.JPG")

```

### Destaques

</br>


#### Efeito da queda dos tabocais nas RESEXs do Cazumbá-Iracema, do Alto Tarauacá, Riozinho da Liberdade e Chico Mendes e no PARNA da Serra do Divisor



</br>


```{r grafico abundancia-resex-cazumba-iracema}
#| label: fig-abundancia-resex-cazumba-iracema
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'


# Análise  de efeito da queda do tabocal nas tribos de borboletas frugívoras - AUTOMATIZADO
# RESEX do Cazumbá-Iracema
# Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)
library(ggplot2)
library(car)

#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")

dados_borboletas <- read.table("data/dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
dados_borboletas$ano <- as.factor(dados_borboletas$ano)
dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]
dados_borboletas <- dados_borboletas[!is.na(dados_borboletas$tribo), ]


dados_regiao_especifica <- dados_borboletas %>%
  filter(uc == 'Resex_do_Cazumba-Iracema')

# Calcular o esforço amostral para cada combinação de uc_ea, expedicao e ano
esforco_por_expedicao <- dados_regiao_especifica %>%
  group_by(uc_ea, uc, expedicao, ano) %>%
  summarize(
    max_dia_amostragem = max(dia_amostragem) - 1,
    .groups = 'drop'
  ) %>%
  mutate(
    esforco_amostral = 16 * max_dia_amostragem
  )

# Agregar o esforço de amostragem para cada uc_ea e ano
esforco_total_por_ea_ano <- esforco_por_expedicao %>%
  group_by(uc_ea, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregar o esforço de amostragem para cada uc e ano
esforco_total_por_uc_ano <- esforco_por_expedicao %>%
  group_by(uc, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregação para obter o esforço total por ano
esforco_por_ano <- esforco_total_por_uc_ano %>%
  group_by(ano,uc) %>%
  summarize(
    esforco = sum(esforco_total_ano),
    .groups = 'drop'
  )

# Agregação para obter o número total de indivíduos por ano
num_ind_por_ano <- dados_regiao_especifica %>%
  group_by(ano) %>%
  summarize(
    num_ind = sum(individuos, na.rm = TRUE),
    .groups = 'drop'
  )

#criando uma coluna de UA e selecionando somente as colunas interessadas pra analise
dados_regiao_especifica <- dados_regiao_especifica %>%
  mutate(ua = paste(uc_ea, transeccao, sep = "_"))

#combinando os dados por UA por ano = 12 (3 ea x 4 parcelas)
df_abu_ano <- dados_regiao_especifica %>%
  group_by(tribo, ua, uc_ea,uc, ano) %>%
  summarise(abundancia = sum(individuos, na.rm = TRUE)) %>%
  ungroup()

# Transforma o df para colocar os zeros
df_tabocal <- df_abu_ano %>%
  spread(key = tribo, value = abundancia, fill = 0)

# Retorna ao formato longo para as análises
df_long <- df_tabocal %>%
  pivot_longer(cols = Ageroniini:Satyrini, names_to = "tribo", values_to = "individuos")

# Agregação para obter a abundância total de cada tribo por ano
abundancia_por_ano <- df_long %>%
  group_by(tribo, ano) %>%
  summarize(
    abundancia_total = sum(individuos)
  )

# Juntar as tabelas pela coluna 'ano' e 'uc'
df_long_com_esforco <- left_join(df_long, esforco_por_ano, by = c("ano", "uc"))


# Calcular a abundância padronizada pelo esforço amostral
df_long <- df_long_com_esforco %>%
  mutate(abundancia_padronizada = (individuos / esforco) * 100)
#

library(tidyverse)

# Realizar análise e gerar gráficos para cada tribo

tribos <- unique(df_long$tribo)

for (tribo_atual in tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
}
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Adicione o ano de 2020, mesmo que não haja dados
  medianas_anuais <- c(medianas_anuais, NA)
  names(medianas_anuais)[length(medianas_anuais)] <- "2020"
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = as.character(unique(c(names(medianas_anuais), "2020"))), MedianaAnual = c(medianas_anuais, NA))
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- c(erros_padrao, NA)
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup)*1.1
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = .7) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "Ano",
         y = "Mediana da Abundância / Esforço Amostral") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5.5),
          axis.text = element_text(size = 6),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Exiba o gráfico ajustado
  print(p_tribo)
  
  # Salvar a imagem usando ggsave()
#   ggsave(filename = paste("mediana_", gsub(" ", "_", tolower(tribo_atual)), "_ajustado_pontos_linha_2020.png", sep = ""),  # Escolha um nome adequado para o arquivo
#          plot = p_tribo,  # O objeto ggplot
#          device = "png",  # Pode ser "jpeg", "tiff", etc.
#          path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Cazumba-Iracema",  # Especifique o diretório onde você deseja salvar o gráfico
#          dpi = 300,  # Define a resolução (DPI)
#          width = 6, height = 5, units = "in")  # Define o tamanho da imagem
# }


library(gridExtra)

# Definir uma lista para armazenar os gráficos
lista_graficos <- list()

# Defina a ordem das tribos
ordem_tribos <- c("Brassolini", "Morphini", "Haeterini", "Preponini", "Melanitini", "Anaeini", 
                  "Epicaliini", "Epiphilini", "Coeini", "Satyrini", "Callicorini", "Biblidini", "Ageroniini")

for (tribo_atual in ordem_tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Adicione o ano de 2020, mesmo que não haja dados
  medianas_anuais <- c(medianas_anuais, NA)
  names(medianas_anuais)[length(medianas_anuais)] <- "2020"
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = as.character(unique(c(names(medianas_anuais), "2020"))), MedianaAnual = c(medianas_anuais, NA))
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- c(erros_padrao, NA)
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup) * 1.1
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "",
         y = "Mediana da Abundância 
 / Esforço Amostral") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5.5),
          axis.text = element_text(size = 6),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Adicionar o gráfico atual à lista
  lista_graficos[[tribo_atual]] <- p_tribo
}



```


```{r grafico abundancia-resex-cazumba-iracema-combinada}
#| label: fig-abundancia-resex-cazumba-iracema-combinada
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '90%'
#| fig-cap: "Variação na abundância das tribos de borboletas frugívoras na RESEX do Cazumbá-Iracema no período de 2020 a 2022."

# Combine todos os gráficos em uma única imagem
imagem_combinada <- grid.arrange(grobs = lista_graficos, ncol = 3)

# Salvar a imagem combinada usando ggsave()
# ggsave(filename = "todos_graficos_cazumba_iracema.png",  # Escolha um nome adequado para o arquivo
#        plot = imagem_combinada,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Cazumba-Iracema",  # Especifique o diretório onde você deseja salvar a imagem
#        dpi = 300,  # Define a resolução (DPI)
#        width = 14, height = 12, units = "in")  # Define o tamanho da imagem



```


</br>



```{r grafico abundancia-resex-alto-tarauaca}
#| label: fig-abundancia-resex-alto-tarauaca
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'



# Análise  de efeito da queda do tabocal nas tribos de borboletas frugívoras - AUTOMATIZADO
# RESEX do Alto Taraucá
# Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)
library(ggplot2)
library(car)

#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")

# dados_borboletas <- read.table("dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
# dados_borboletas$ano <- as.factor(dados_borboletas$ano)
# dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]
# dados_borboletas <- dados_borboletas[!is.na(dados_borboletas$tribo), ]


dados_regiao_especifica <- dados_borboletas %>%
  filter(uc == 'Resex_do_Alto_Tarauaca')

# Calcular o esforço amostral para cada combinação de uc_ea, expedicao e ano
esforco_por_expedicao <- dados_regiao_especifica %>%
  group_by(uc_ea, uc, expedicao, ano) %>%
  summarize(
    max_dia_amostragem = max(dia_amostragem) - 1,
    .groups = 'drop'
  ) %>%
  mutate(
    esforco_amostral = 16 * max_dia_amostragem
  )

# Agregar o esforço de amostragem para cada uc_ea e ano
esforco_total_por_ea_ano <- esforco_por_expedicao %>%
  group_by(uc_ea, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregar o esforço de amostragem para cada uc e ano
esforco_total_por_uc_ano <- esforco_por_expedicao %>%
  group_by(uc, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregação para obter o esforço total por ano
esforco_por_ano <- esforco_total_por_uc_ano %>%
  group_by(ano,uc) %>%
  summarize(
    esforco = sum(esforco_total_ano),
    .groups = 'drop'
  )

# Agregação para obter o número total de indivíduos por ano
num_ind_por_ano <- dados_regiao_especifica %>%
  group_by(ano) %>%
  summarize(
    num_ind = sum(individuos, na.rm = TRUE),
    .groups = 'drop'
  )

#criando uma coluna de UA e selecionando somente as colunas interessadas pra analise
dados_regiao_especifica <- dados_regiao_especifica %>%
  mutate(ua = paste(uc_ea, transeccao, sep = "_"))

#combinando os dados por UA por ano = 12 (3 ea x 4 parcelas)
df_abu_ano <- dados_regiao_especifica %>%
  group_by(tribo, ua, uc_ea,uc, ano) %>%
  summarise(abundancia = sum(individuos, na.rm = TRUE)) %>%
  ungroup()

# Transforma o df para colocar os zeros
df_tabocal <- df_abu_ano %>%
  spread(key = tribo, value = abundancia, fill = 0)

# Retorna ao formato longo para as análises
df_long <- df_tabocal %>%
  pivot_longer(cols = Ageroniini:Satyrini, names_to = "tribo", values_to = "individuos")

# Agregação para obter a abundância total de cada tribo por ano
abundancia_por_ano <- df_long %>%
  group_by(tribo, ano) %>%
  summarize(
    abundancia_total = sum(individuos)
  )

# Juntar as tabelas pela coluna 'ano' e 'uc'
df_long_com_esforco <- left_join(df_long, esforco_por_ano, by = c("ano", "uc"))


# Calcular a abundância padronizada pelo esforço amostral
df_long <- df_long_com_esforco %>%
  mutate(abundancia_padronizada = (individuos / esforco) * 100)
#

library(tidyverse)

# Realizar análise e gerar gráficos para cada tribo

tribos <- unique(df_long$tribo)

for (tribo_atual in tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Adicione o ano de 2020, mesmo que não haja dados
  medianas_anuais <- c(medianas_anuais, NA)
  names(medianas_anuais)[length(medianas_anuais)] <- "2020"
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = as.character(unique(c(names(medianas_anuais), "2020"))), MedianaAnual = c(medianas_anuais, NA))
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- c(erros_padrao, NA)
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup)*1.2
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "Ano",
         y = "Mediana da Abundância / Esforço Amostral") +
    theme_minimal() +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Exiba o gráfico ajustado
  print(p_tribo)
  
  # Salvar a imagem usando ggsave()
  ggsave(filename = paste("mediana_", gsub(" ", "_", tolower(tribo_atual)), "_ajustado_pontos_linha_2020.png", sep = ""),  # Escolha um nome adequado para o arquivo
         plot = p_tribo,  # O objeto ggplot
         device = "png",  # Pode ser "jpeg", "tiff", etc.
         path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Alto Tarauaca",  # Especifique o diretório onde você deseja salvar o gráfico
         dpi = 300,  # Define a resolução (DPI)
         width = 6, height = 5, units = "in")  # Define o tamanho da imagem
}


library(gridExtra)

# Definir uma lista para armazenar os gráficos
lista_graficos <- list()

# Defina a ordem das tribos
ordem_tribos <- c("Brassolini", "Morphini", "Haeterini", "Preponini", "Melanitini", "Anaeini", 
                  "Epicaliini", "Epiphilini", "Coeini", "Satyrini", "Callicorini", "Biblidini", "Ageroniini")

for (tribo_atual in ordem_tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Adicione o ano de 2020, mesmo que não haja dados
  medianas_anuais <- c(medianas_anuais, NA)
  names(medianas_anuais)[length(medianas_anuais)] <- "2020"
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = as.character(unique(c(names(medianas_anuais), "2020"))), MedianaAnual = c(medianas_anuais, NA))
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- c(erros_padrao, NA)
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup) * 1.2
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "",
         y = "Mediana da Abundância 
 / Esforço Amostral") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Adicionar o gráfico atual à lista
  lista_graficos[[tribo_atual]] <- p_tribo
}


```

</br>


```{r grafico abundancia-resex-alto-tarauca-combinada}
#| label: fig-abundancia-resex-alto-tarauaca-combinada
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'
#| fig-cap: "Variação na abundância das tribos de borboletas frugívoras na RESEX do Alto Tarauacá no período de 2020 a 2022."

# Combine todos os gráficos em uma única imagem
imagem_combinada <- grid.arrange(grobs = lista_graficos, ncol = 3)

# Salvar a imagem combinada usando ggsave()
# ggsave(filename = "todos_graficos_alto_tarauaca.png",  # Escolha um nome adequado para o arquivo
#        plot = imagem_combinada,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Alto Tarauaca",  # Especifique o diretório onde você deseja salvar a imagem
#        dpi = 300,  # Define a resolução (DPI)
#        width = 14, height = 12, units = "in")  # Define o tamanho da imagem


```

</br>


```{r grafico abundancia-resex-riozinho-da-liberdade}
#| label: fig-abundancia-resex-riozinho-da-liberdade
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'



# Análise  de efeito da queda do tabocal nas tribos de borboletas frugívoras - AUTOMATIZADO
# RESEX Riozinho da Liberdade
# Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)
library(ggplot2)
library(car)

# setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
# 
# dados_borboletas <- read.table("dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
# dados_borboletas$ano <- as.factor(dados_borboletas$ano)
# dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]
# dados_borboletas <- dados_borboletas[!is.na(dados_borboletas$tribo), ]


dados_regiao_especifica <- dados_borboletas %>%
  filter(uc == 'Resex_Riozinho_da_Liberdade')

# Calcular o esforço amostral para cada combinação de uc_ea, expedicao e ano
esforco_por_expedicao <- dados_regiao_especifica %>%
  group_by(uc_ea, uc, expedicao, ano) %>%
  summarize(
    max_dia_amostragem = max(dia_amostragem) - 1,
    .groups = 'drop'
  ) %>%
  mutate(
    esforco_amostral = 16 * max_dia_amostragem
  )

# Agregar o esforço de amostragem para cada uc_ea e ano
esforco_total_por_ea_ano <- esforco_por_expedicao %>%
  group_by(uc_ea, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregar o esforço de amostragem para cada uc e ano
esforco_total_por_uc_ano <- esforco_por_expedicao %>%
  group_by(uc, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregação para obter o esforço total por ano
esforco_por_ano <- esforco_total_por_uc_ano %>%
  group_by(ano,uc) %>%
  summarize(
    esforco = sum(esforco_total_ano),
    .groups = 'drop'
  )

# Agregação para obter o número total de indivíduos por ano
num_ind_por_ano <- dados_regiao_especifica %>%
  group_by(ano) %>%
  summarize(
    num_ind = sum(individuos, na.rm = TRUE),
    .groups = 'drop'
  )

#criando uma coluna de UA e selecionando somente as colunas interessadas pra analise
dados_regiao_especifica <- dados_regiao_especifica %>%
  mutate(ua = paste(uc_ea, transeccao, sep = "_"))

#combinando os dados por UA por ano = 12 (3 ea x 4 parcelas)
df_abu_ano <- dados_regiao_especifica %>%
  group_by(tribo, ua, uc_ea,uc, ano) %>%
  summarise(abundancia = sum(individuos, na.rm = TRUE)) %>%
  ungroup()

# Transforma o df para colocar os zeros
df_tabocal <- df_abu_ano %>%
  spread(key = tribo, value = abundancia, fill = 0)

# Retorna ao formato longo para as análises
df_long <- df_tabocal %>%
  pivot_longer(cols = Ageroniini:Satyrini, names_to = "tribo", values_to = "individuos")

# Agregação para obter a abundância total de cada tribo por ano
abundancia_por_ano <- df_long %>%
  group_by(tribo, ano) %>%
  summarize(
    abundancia_total = sum(individuos)
  )

# Juntar as tabelas pela coluna 'ano' e 'uc'
df_long_com_esforco <- left_join(df_long, esforco_por_ano, by = c("ano", "uc"))


# Calcular a abundância padronizada pelo esforço amostral
df_long <- df_long_com_esforco %>%
  mutate(abundancia_padronizada = (individuos / esforco) * 100)
#

library(tidyverse)

# Realizar análise e gerar gráficos para cada tribo

tribos <- unique(df_long$tribo)

for (tribo_atual in tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = names(medianas_anuais), MedianaAnual = medianas_anuais)
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- erros_padrao
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup)*1.1
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "Ano",
         y = "Mediana da Abundância / Esforço Amostral") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Exiba o gráfico ajustado
  print(p_tribo)
  
  # Salvar a imagem usando ggsave()
  ggsave(filename = paste("mediana_", gsub(" ", "_", tolower(tribo_atual)), "_ajustado_pontos_linha_2020.png", sep = ""),  # Escolha um nome adequado para o arquivo
         plot = p_tribo,  # O objeto ggplot
         device = "png",  # Pode ser "jpeg", "tiff", etc.
         path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Riozinho da Liberdade",  # Especifique o diretório onde você deseja salvar o gráfico
         dpi = 300,  # Define a resolução (DPI)
         width = 6, height = 5, units = "in")  # Define o tamanho da imagem
}


library(gridExtra)

# Definir uma lista para armazenar os gráficos
lista_graficos <- list()

# Defina a ordem das tribos
ordem_tribos <- c("Brassolini", "Morphini", "Haeterini", "Preponini", "Melanitini", "Anaeini", 
                  "Epicaliini", "Epiphilini", "Coeini", "Satyrini", "Callicorini", "Biblidini", "Ageroniini")

for (tribo_atual in ordem_tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = names(medianas_anuais), MedianaAnual = medianas_anuais)
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- erros_padrao
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup) * 1.1
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "",
         y = "Mediana da Abundância 
 / Esforço Amostral") +
    theme_minimal() +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Adicionar o gráfico atual à lista
  lista_graficos[[tribo_atual]] <- p_tribo
}


```

</br>


```{r grafico abundancia-resex-riozinho-da-liberdade-combinada}
#| label: fig-abundancia-resex-riozinho-da-liberdade-combinada
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'
#| fig-cap: "Variação na abundância das tribos de borboletas frugívoras na RESEX do Riozinho da Liberdade no período de 2020 a 2022."

# Combine todos os gráficos em uma única imagem
imagem_combinada <- grid.arrange(grobs = lista_graficos, ncol = 3)

# Salvar a imagem combinada usando ggsave()
# ggsave(filename = "todos_graficos_riozinho_da_liberdade.png",  # Escolha um nome adequado para o arquivo
#        plot = imagem_combinada,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Riozinho da Liberdade",  # Especifique o diretório onde você deseja salvar a imagem
#        dpi = 300,  # Define a resolução (DPI)
#        width = 14, height = 12, units = "in")  # Define o tamanho da imagem

```

</br>


```{r grafico abundancia-resex-chico-mendes}
#| label: fig-abundancia-resex-chico-mendes
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'



# Análise  de efeito da queda do tabocal nas tribos de borboletas frugívoras - AUTOMATIZADO
# RESEX Chico Mendes
# Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)
library(ggplot2)
library(car)

# setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
# 
# dados_borboletas <- read.table("dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
# dados_borboletas$ano <- as.factor(dados_borboletas$ano)
# dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]
# dados_borboletas <- dados_borboletas[!is.na(dados_borboletas$tribo), ]


dados_regiao_especifica <- dados_borboletas %>%
  filter(uc == 'Resex_Chico_Mendes')

# Calcular o esforço amostral para cada combinação de uc_ea, expedicao e ano
esforco_por_expedicao <- dados_regiao_especifica %>%
  group_by(uc_ea, uc, expedicao, ano) %>%
  summarize(
    max_dia_amostragem = max(dia_amostragem) - 1,
    .groups = 'drop'
  ) %>%
  mutate(
    esforco_amostral = 16 * max_dia_amostragem
  )

# Agregar o esforço de amostragem para cada uc_ea e ano
esforco_total_por_ea_ano <- esforco_por_expedicao %>%
  group_by(uc_ea, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregar o esforço de amostragem para cada uc e ano
esforco_total_por_uc_ano <- esforco_por_expedicao %>%
  group_by(uc, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregação para obter o esforço total por ano
esforco_por_ano <- esforco_total_por_uc_ano %>%
  group_by(ano,uc) %>%
  summarize(
    esforco = sum(esforco_total_ano),
    .groups = 'drop'
  )

# Agregação para obter o número total de indivíduos por ano
num_ind_por_ano <- dados_regiao_especifica %>%
  group_by(ano) %>%
  summarize(
    num_ind = sum(individuos, na.rm = TRUE),
    .groups = 'drop'
  )

#criando uma coluna de UA e selecionando somente as colunas interessadas pra analise
dados_regiao_especifica <- dados_regiao_especifica %>%
  mutate(ua = paste(uc_ea, transeccao, sep = "_"))

#combinando os dados por UA por ano = 12 (3 ea x 4 parcelas)
df_abu_ano <- dados_regiao_especifica %>%
  group_by(tribo, ua, uc_ea,uc, ano) %>%
  summarise(abundancia = sum(individuos, na.rm = TRUE)) %>%
  ungroup()

# Transforma o df para colocar os zeros
df_tabocal <- df_abu_ano %>%
  spread(key = tribo, value = abundancia, fill = 0)

# Retorna ao formato longo para as análises
df_long <- df_tabocal %>%
  pivot_longer(cols = Ageroniini:Satyrini, names_to = "tribo", values_to = "individuos")

# Agregação para obter a abundância total de cada tribo por ano
abundancia_por_ano <- df_long %>%
  group_by(tribo, ano) %>%
  summarize(
    abundancia_total = sum(individuos)
  )

# Juntar as tabelas pela coluna 'ano' e 'uc'
df_long_com_esforco <- left_join(df_long, esforco_por_ano, by = c("ano", "uc"))


# Calcular a abundância padronizada pelo esforço amostral
df_long <- df_long_com_esforco %>%
  mutate(abundancia_padronizada = (individuos / esforco) * 100)
#

library(tidyverse)

# Realizar análise e gerar gráficos para cada tribo

tribos <- unique(df_long$tribo)

for (tribo_atual in tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = names(medianas_anuais), MedianaAnual = medianas_anuais)
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- erros_padrao
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup)*1.1
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "Ano",
         y = "Mediana da Abundância / Esforço Amostral") +
    theme_minimal() +
     theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Exiba o gráfico ajustado
  print(p_tribo)
  
  # Salvar a imagem usando ggsave()
  ggsave(filename = paste("mediana_", gsub(" ", "_", tolower(tribo_atual)), "_ajustado_pontos_linha_2020.png", sep = ""),  # Escolha um nome adequado para o arquivo
         plot = p_tribo,  # O objeto ggplot
         device = "png",  # Pode ser "jpeg", "tiff", etc.
         path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Chico Mendes",  # Especifique o diretório onde você deseja salvar o gráfico
         dpi = 300,  # Define a resolução (DPI)
         width = 6, height = 5, units = "in")  # Define o tamanho da imagem
}


library(gridExtra)

# Definir uma lista para armazenar os gráficos
lista_graficos <- list()

# Defina a ordem das tribos
ordem_tribos <- c("Brassolini", "Morphini", "Haeterini", "Preponini", "Melanitini", "Anaeini", 
                  "Epicaliini", "Epiphilini", "Coeini", "Satyrini", "Callicorini", "Biblidini", "Ageroniini")

for (tribo_atual in ordem_tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = names(medianas_anuais), MedianaAnual = medianas_anuais)
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- erros_padrao
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup) * 1.1
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "",
         y = "Mediana da Abundância 
 / Esforço Amostral") +
    theme_minimal() +
     theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Adicionar o gráfico atual à lista
  lista_graficos[[tribo_atual]] <- p_tribo
}


```

</br>


```{r grafico abundancia-resex-chico-mendes-combinada}
#| label: fig-abundancia-resex-chico-mendes-combinada
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'
#| fig-cap: "Variação na abundância das tribos de borboletas frugívoras na RESEX Chico Mendes no período de 2020 a 2022."

# Combine todos os gráficos em uma única imagem
imagem_combinada <- grid.arrange(grobs = lista_graficos, ncol = 3)

# Salvar a imagem combinada usando ggsave()
# ggsave(filename = "todos_graficos_chico_mendes.png",  # Escolha um nome adequado para o arquivo
#        plot = imagem_combinada,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Chico Mendes",  # Especifique o diretório onde você deseja salvar a imagem
#        dpi = 300,  # Define a resolução (DPI)
#        width = 14, height = 12, units = "in")  # Define o tamanho da imagem

```

</br>

```{r grafico abundancia-parna-serra-divisor}
#| label: fig-abundancia-parna-serra-divisor
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'



# Análise  de efeito da queda do tabocal nas tribos de borboletas frugívoras - AUTOMATIZADO
# PARANA Serra do Divisor
# Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)
library(ggplot2)
library(car)

# setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
# 
# dados_borboletas <- read.table("dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
# dados_borboletas$ano <- as.factor(dados_borboletas$ano)
# dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]
# dados_borboletas <- dados_borboletas[!is.na(dados_borboletas$tribo), ]


dados_regiao_especifica <- dados_borboletas %>%
  filter(uc == 'Parna_da_Serra_do_Divisor')

# Calcular o esforço amostral para cada combinação de uc_ea, expedicao e ano
esforco_por_expedicao <- dados_regiao_especifica %>%
  group_by(uc_ea, uc, expedicao, ano) %>%
  summarize(
    max_dia_amostragem = max(dia_amostragem) - 1,
    .groups = 'drop'
  ) %>%
  mutate(
    esforco_amostral = 16 * max_dia_amostragem
  )

# Agregar o esforço de amostragem para cada uc_ea e ano
esforco_total_por_ea_ano <- esforco_por_expedicao %>%
  group_by(uc_ea, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregar o esforço de amostragem para cada uc e ano
esforco_total_por_uc_ano <- esforco_por_expedicao %>%
  group_by(uc, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregação para obter o esforço total por ano
esforco_por_ano <- esforco_total_por_uc_ano %>%
  group_by(ano,uc) %>%
  summarize(
    esforco = sum(esforco_total_ano),
    .groups = 'drop'
  )

# Agregação para obter o número total de indivíduos por ano
num_ind_por_ano <- dados_regiao_especifica %>%
  group_by(ano) %>%
  summarize(
    num_ind = sum(individuos, na.rm = TRUE),
    .groups = 'drop'
  )

#criando uma coluna de UA e selecionando somente as colunas interessadas pra analise
dados_regiao_especifica <- dados_regiao_especifica %>%
  mutate(ua = paste(uc_ea, transeccao, sep = "_"))

#combinando os dados por UA por ano = 12 (3 ea x 4 parcelas)
df_abu_ano <- dados_regiao_especifica %>%
  group_by(tribo, ua, uc_ea,uc, ano) %>%
  summarise(abundancia = sum(individuos, na.rm = TRUE)) %>%
  ungroup()

# Transforma o df para colocar os zeros
df_tabocal <- df_abu_ano %>%
  spread(key = tribo, value = abundancia, fill = 0)

# Retorna ao formato longo para as análises
df_long <- df_tabocal %>%
  pivot_longer(cols = Ageroniini:Satyrini, names_to = "tribo", values_to = "individuos")

# Agregação para obter a abundância total de cada tribo por ano
abundancia_por_ano <- df_long %>%
  group_by(tribo, ano) %>%
  summarize(
    abundancia_total = sum(individuos)
  )

# Juntar as tabelas pela coluna 'ano' e 'uc'
df_long_com_esforco <- left_join(df_long, esforco_por_ano, by = c("ano", "uc"))


# Calcular a abundância padronizada pelo esforço amostral
df_long <- df_long_com_esforco %>%
  mutate(abundancia_padronizada = (individuos / esforco) * 100)
#

library(tidyverse)

# Realizar análise e gerar gráficos para cada tribo

tribos <- unique(df_long$tribo)

for (tribo_atual in tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Adicione o ano de 2020, mesmo que não haja dados
  medianas_anuais <- c(medianas_anuais, NA)
  names(medianas_anuais)[length(medianas_anuais)] <- "2020"
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = as.character(unique(c(names(medianas_anuais), "2020"))), MedianaAnual = c(medianas_anuais, NA))
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- c(erros_padrao, NA)
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup)*1.2
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "Ano",
         y = "Mediana da Abundância / Esforço Amostral") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Exiba o gráfico ajustado
  print(p_tribo)
  
  # Salvar a imagem usando ggsave()
  ggsave(filename = paste("mediana_", gsub(" ", "_", tolower(tribo_atual)), "_ajustado_pontos_linha_2020.png", sep = ""),  # Escolha um nome adequado para o arquivo
         plot = p_tribo,  # O objeto ggplot
         device = "png",  # Pode ser "jpeg", "tiff", etc.
         path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Serra do Divisor",  # Especifique o diretório onde você deseja salvar o gráfico
         dpi = 300,  # Define a resolução (DPI)
         width = 6, height = 5, units = "in")  # Define o tamanho da imagem
}


library(gridExtra)

# Definir uma lista para armazenar os gráficos
lista_graficos <- list()

# Defina a ordem das tribos
ordem_tribos <- c("Brassolini", "Morphini", "Haeterini", "Preponini", "Melanitini", "Anaeini", 
                  "Epicaliini", "Epiphilini", "Coeini", "Satyrini", "Callicorini", "Biblidini", "Ageroniini")

for (tribo_atual in ordem_tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Adicione o ano de 2020, mesmo que não haja dados
  medianas_anuais <- c(medianas_anuais, NA)
  names(medianas_anuais)[length(medianas_anuais)] <- "2020"
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = as.character(unique(c(names(medianas_anuais), "2020"))), MedianaAnual = c(medianas_anuais, NA))
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- c(erros_padrao, NA)
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup) * 1.2
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "",
         y = "Mediana da Abundância 
 / Esforço Amostral") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Adicionar o gráfico atual à lista
  lista_graficos[[tribo_atual]] <- p_tribo
}


```

</br>


```{r grafico abundancia-parna-serra-divisor-combinada}
#| label: fig-abundancia-parana-serra-divisor-combinada
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'
#| fig-cap: "Variação na abundância das tribos de borboletas frugívoras no PARNA Serra do Divisor no período de 2020 a 2022."

# Combine todos os gráficos em uma única imagem
imagem_combinada <- grid.arrange(grobs = lista_graficos, ncol = 3)

# Salvar a imagem combinada usando ggsave()
# ggsave(filename = "todos_graficos_serra_do_divisor.png",  # Escolha um nome adequado para o arquivo
#        plot = imagem_combinada,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Serra do Divisor",  # Especifique o diretório onde você deseja salvar a imagem
#        dpi = 300,  # Define a resolução (DPI)
#        width = 14, height = 12, units = "in")  # Define o tamanho da imagem

```



## Discussão


</br>




## Recomendações

</br>

::: callout-tip

## Boas práticas para aprimorar o Programa

</br>

- Ampliar o número de unidades de conservação com aplicação do protocolo de borboletas frugívoras (Básico e Avançado) nos biomas Mata Atlântica e Cerrado; 

- Consolidar a implantação do protocolo de borboletas frugívoras naquelas unidades de conservação ainda não consolidadas, de forma que as UCs contem com pelo menos três estações amostrais implantadas e em operação; 

- Assegurar que durante as campanhas de campo as amostragens sejam realizadas de acordo com as diretrizes estabelecidas no protocolo amostral, em especial quanto ao respeito aos períodos de coleta definidos para cada região e em relação ao esforço amostral (número de dias de amostragens em cada EA); 

- Assegurar que os dados coletados sejam repassados à COMOB de acordo com as orientações definidas pela Coordenação e num prazo razoável após a realização da campanha de campo. 

::: 