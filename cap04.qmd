```{r library, echo=FALSE, message=FALSE, warning=FALSE}

library(tidyverse)
library(data.table)
library(descr)
library(RColorBrewer)
library(kableExtra)
library(knitr)
library(DT)
library(plotly)
library(ggthemes)
library(forcats)
library(leaflet)
library(sf)
library(rgdal)
library(treemapify)
library(reshape2)
library(randomcoloR)
library(gridExtra)
```


# Borboletas frugívoras 

</br>

**Isabela Freitas Oliveira**^1-2^ & **Onildo João Marini Filho**^1^


1. Centro Nacional de Pesquisa e Conservação da Biodiversidade do Cerrado e Restauração Ecológica - CBC  
*Instituto Chico Mendes de Conservação da Biodiversidade – ICMBio*  
*Parque Nacional de Brasília*  
*Via Epia, BR-450, Km 8,5*  
*70635-800 Brasília, DF*  

2. Coordenação de Monitoramento da Biodiversidade - COMOB  
*Instituto Chico Mendes de Conservação da Biodiversidade – ICMBio*  
*Complexo Administrativo EQSW 103/104 s/n*  
*70670-350 Brasília, DF*  

</br>


Em alguns grupos de insetos, a variação na riqueza, abundância e composição de espécies das comunidades ao longo do tempo vem sendo utilizada como indicador de alteração ambiental (@Gerlach_2013, @Arenhardt_2021, @Rodrigues_2019). No caso de borboletas, além desses parâmetros, a frequência relativa de ocorrência em nível de tribo também tem sido usada em estudos pontuais e programas de monitoramento (@Monitora_2018a). Esse indicador está relacionado tanto a alterações na vegetação (@Uehara_Prado_2006, @Ribeiro_2010) e eventos extremos climáticos, quanto a mudanças menos perceptíveis, como a redução na qualidade do ar (especialmente devido à presença de agrotóxicos) (@Smilanich_2012, @Ndakidemi_2016) e variações graduais do clima (temperatura e umidade) (@Devictor_2012). 

</br>

## Implementação e validação protocolar

</br>


De 2014 a 2022 o protocolo amostral de borboletas frugívoras foi aplicado de forma integral ou parcial em 50 UCs federais, totalizando 134 estações amostrais (EAs) e 536 unidades amostrais (UAs - transecções com quatro armadilhas atrativas do tipo *Van Someren-Rydon*). A maior parte das amostragens (39 UCs, 78%) foi realizada no bioma Amazônico, seis UCs (12%) foram amostradas na Mata Atlântica e cinco UCs (10%) no Cerrado. Até 2022, das 50 UCs federais com coleta de dados de borboletas frugívoras, 31 (62%) já estão consolidadas com as três EAs e 12 UAs implantadas (Tabela X). Estas UCs são: ESEC da Terra do Meio, ESEC de Maracá, ESEC do Jari, FLONA de Tapajós, FLONA do Jamari, PARNA da Amazônia, PARNA da Serra da Cutia, PARNA da Serra do Divisor, PARNA de Pacaás Novos, PARNA do Cabo Orange, PARNA do Jaú, PARNA do Juruena, PARNA do Superagui, PARNA dos Campos Amazônicos, PARNA Mapinguari, PARNA Montanhas do Tumucumaque, PARNA Nascentes do Lago Jari, REBIO do Gurupi, REBIO do Jaru, REBIO do Tapirapé, REBIO do Uatumã, RESEX Arapixi, RESEX Barreiro das Antas, RESEX Chico Mendes, RESEX do Alto Tarauacá, RESEX do Cazumbá-Iracema, RESEX do Rio do Cautário, RESEX Renascer, RESEX Rio Ouro Preto, RESEX Riozinho da Liberdade e RESEX Tapajós-Arapiuns (Cap. 2, Tabela xx).  


A partir de xxxx, xx UCs (XX%) adotaram o *Open Data Kit* (ODK), um aplicativo Android de código aberto que possibilita a coleta de dados em campo de forma mais eficiente e confiável, substituindo os formulários em papel. Ele armazena diversos tipos de informação como textos, dados numéricos, coordenadas geográficas, áudio, imagens, vídeo e códigos de barras, sendo projetado para funcionar mesmo sem conectividade à *internet*. O ODK favorece o registro de armadilhas com zero capturas, informação muitas vezes desconsiderada quando a amostragem é feita com formulários tradicionais. Além disso, só é possível adicionar as fotos das borboletas no sistema quando as coordenadas da unidade amostral de cada EA são registradas, certificando que a coleta foi, de fato, feita no local correto. Com as fotos das borboletas no sistema, especialistas podem identificar os indivíduos em nível de espécie ou morfoespécie, possibilitando a análise dos dados de acordo com o protocolo avançado.  

Conforme mencionado no capítulo 2, as amostragens de borboleta frugívoras foram paralisadas ou reduzidas no período mais intenso da pandemia de COVID (2020-21). Em 2020, 13 UCs fizeram coletas, porém, somente o PARNA da Amazônia, PARNA Serra da Cutia, PARNA de Pacaás Novos, PARNA Mapinguari, REBIO do Uatumã e RESEX Barreiro das Antas coletaram nas três EAs. Em 2021, as atividades foram retomadas em 31 UCs (@fig-evolucao-implementacao e @fig-esforco-amostral).  

Ao longo dos anos, houve uma progressão no número de UCs e EAs amostradas (exceto em 2020). Em 2022, a amostragem de borboletas frugívoras foi realizada em 39 das 50 UCs do Programa Monitora – Protocolo de Borboletas frugívoras, nos três biomas florestais (Tabela x). O ano de 2022 teve oito UCs a mais do que 2021, com um aumento de 35.4% no número de EAs implementadas (@fig-evolucao-implementacao). 


</br>

 
```{r grafico ucs_ativas_taxa_acumulado}
#| label: fig-evolucao-implementacao
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Evolução do número de unidades de conservação (UCs) e de estações amostrais (EAs) com amostragem de borboletas frugívoras no Programa Monitora de 2014 a 2022."

# Gráficos de dados Borboletas- Protocolo básico
# Numero de UC's e EA's implementadas 2014-2022
# Script: Isabela Freitas Oliveira

library(tidyverse)
library(ggplot2)
library(stringr)

dados_borboletas <- read.table("dados/borboletas/dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
dados_borboletas$ano <- factor(dados_borboletas$ano)
dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]

# Preparar os dados para o gráfico
contagem_uc_ea <- dados_borboletas %>%
  group_by(ano) %>%
  summarise(
    num_uc = n_distinct(uc),
    num_ea = n_distinct(uc_ea)
  )

dados_long <- contagem_uc_ea %>%
  pivot_longer(
    cols = -ano,
    names_to = "categoria",
    values_to = "contagem"
  )

dados_long$categoria <- factor(dados_long$categoria, levels = c("num_uc","num_ea"))
grafico_amostragens <- ggplot(dados_long, aes(x = ano, y = contagem, fill = categoria)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(
    aes(label = contagem), 
    position = position_dodge(width = 0.9), # ajustar 'width' para alinhar com as barras
    vjust = -0.50, # ajustar 'vjust' para mover o texto um pouco acima das barras
    size = 3
  ) +
  scale_fill_manual(
    values = c("num_uc" = "#35978f", "num_ea" = "#dfc27d"),
    labels = c("UCs", "EAs")) +
  labs(
    x = "",
    y = "",
    fill = "",
    title = str_wrap("", width = 35) # Quebra o título em duas linhas
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, hjust = 0, lineheight = 1.3),
    legend.position = c(0.03, 1), # Define a posição da legenda no canto superior esquerdo
    legend.justification = c(0, 1), # Define a justificação da legenda para o canto superior esquerdo
    legend.box.just = "left", # Alinha a legenda à esquerda
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 10),
    axis.title.x = element_text(size = 14), 
    axis.text.x = element_text(size = 10),  
    #axis.line = element_line(colour = "gray40"),
    axis.line.x = element_blank(),
    axis.text.y = element_blank(),
    panel.grid.major = element_blank(),  # remove as linhas principais da grade
    panel.grid.minor = element_blank() 
  ) 
  #scale_y_continuous(limits = c(0, 115))

grafico_amostragens

# Salvar a imagem usando ggsave()
# ggsave(
#  filename = "grafico_numeros_de_uc_ea_f1.png",
#   plot = grafico_amostragens,
#  device = "png",
#   path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",
#  dpi = 300,
#   width = 12,
#  height = 8,
# units = "in"
# )

```
</br>

Para verificar se as amostragens de borboletas frugívoras nas UCs da Amazônia seguiram o protocolo de coleta adequadamente, os dados foram submetidos a um *script* em R para validação automatizada das campanhas realizadas. Três regras de validação do protocolo foram aplicadas às EAs em cada campanha: (1) A amostragem ter sido realizada no período do ano correto para a região, (2) terem sido realizados seis dias de amostragem e (3) ter sido respeitado o intervalo mínimo de 15 dias entre campanhas. Todos os 846 registros (estação amostral de uma UC por campanha por ano) foram avaliados. Dessas, 230 (27%) violaram alguma regra do protocolo. Seis registros violaram duas regras, sendo estas expedições para locais de difícil acesso (i.e., PARNA do Monte Roraima). Em apenas um registro (EA-4 do PARNA Mapinguari na segunda campanha de 2022) as três regras foram violadas.  A coleta fora do período indicado para a região correspondeu a 85% das violações. O número correto de dias de amostragem por campanha não foi cumprido em 13% das EAs,  havendo tanto EAs com mais quanto com menos dias de coleta. O intervalo mínimo de 15 dias entre campanhas não foi respeitado em 7% das EAs.  

O esforço amostral de borboletas frugívoras vem aumentando desde o início da implementação do Programa Monitora (exceto em 2020). Em relação a 2014, o ano de 2015 apresentou um aumento de 121% no esforço amostral. Em 2016, houve um aumento de 134%, em 2017 o esforço aumentou 67%, em 2018 houve um crescimento de 43% e em 2019 o aumento foi de 23%. Em 2020, ano com maior impacto da pandemia, houve uma queda de 74% em relação ao ano anterior. No entanto, em 2021 o esforço amostral cresceu 234%, e em 2022 o aumento foi de 36% (@fig-esforco-amostral).  

De maneira geral, observou-se que o número de indivíduos amostrados acompanhou o esforço amostral, havendo um aumento na abundância de borboletas com o aumento do esforço amostral (@fig-esforco-amostral). Ao todo, foram capturados 85.386 indivíduos de borboletas, com um esforço amostral de 90.320 armadilhas/dia (@fig-esforco-amostral). 


</br>


```{r grafico ucs_ativas_taxa_acumulado}
#| label: fig-esforco-amostral
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no número de registros de borboletas frugívoras e esforço amostral (dias*armadilhas) somada para todas as UCs participantes do Programa Monitora."


#Script: Isabela Freitas Oliveira

library(dplyr)

# Ler e limpar dados_borboletas
dados_borboletas <- read.table("dados/borboletas/dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
dados_borboletas <- dados_borboletas %>%
  filter(ano != "2023", !is.na(tribo))


# Calcular o esforço amostral para cada combinação de uc_ea, expedicao e ano
esforco_por_expedicao <- dados_borboletas %>%
  group_by(uc_ea, uc, expedicao, ano) %>%
  summarize(
    max_dia_amostragem = max(dia_amostragem) - 1,
    .groups = 'drop'
  ) %>%
  mutate(
    esforco_amostral = 16 * max_dia_amostragem
  )

# Agregar o esforço de amostragem para cada uc_ea e ano
esforco_total_por_ea_ano <- esforco_por_expedicao %>%
  group_by(uc_ea, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregar o esforço de amostragem para cada uc e ano
esforco_total_por_uc_ano <- esforco_por_expedicao %>%
  group_by(uc, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )


# Agregação para obter o esforço total por ano por uc
esforco_por_ano_uc <- esforco_total_por_uc_ano %>%
  group_by(ano,uc) %>%
  summarize(
    esforco = sum(esforco_total_ano),
    .groups = 'drop'
  )

# Agregação para obter o esforço total por ano
esforco_por_ano <- esforco_total_por_uc_ano %>%
  group_by(ano) %>%
  summarize(
    esforco = sum(esforco_total_ano),
    .groups = 'drop'
  )

# Agregação para obter o número total de indivíduos por ano
num_ind_por_ano <- dados_borboletas %>%
  group_by(ano) %>%
  summarize(
    num_ind = sum(individuos, na.rm = TRUE),
    .groups = 'drop'
  )


# Juntar as duas tabelas agregadas
tabela_final_esfoco <- left_join(esforco_por_ano, num_ind_por_ano, by = "ano")
#write.csv(tabela_final_esfoco, "tabela_final_esfoco.csv", row.names = FALSE)


#####Fazer o gráfico de Abundancia e esforço
# Definindo os dados para cada série separadamente
dados_esforco <- tabela_final_esfoco[, c("ano", "esforco")]
names(dados_esforco)[2] <- "valor"
dados_esforco$tipo <- "Esforço"

dados_abundancia <- tabela_final_esfoco[, c("ano", "num_ind")]
names(dados_abundancia)[2] <- "valor"
dados_abundancia$tipo <- "Abundância"

# Juntando os dados
dados_plot <- rbind(dados_esforco, dados_abundancia)

# Criando o gráfico
grafico <- ggplot(data = dados_plot, aes(x = ano, y = valor, colour = tipo, linetype = tipo, shape = tipo)) +
  geom_line(size = 1.0) +
  geom_point(size = 3) +
  scale_colour_manual(values = c("Esforço" = "#35978f", "Abundância" = "#dfc27d")) +
  scale_linetype_manual(values = c("Esforço" = "solid", "Abundância" = "solid")) +
  scale_shape_manual(values = c("Esforço" = 16, "Abundância" = 17)) +
  scale_y_continuous(
    "Esforço Amostral e Abundância",
    labels = scales::label_number(big.mark = ".", decimal.mark = ","),
    limits = c(0, 25000)
  ) +
  scale_x_continuous(breaks = tabela_final_esfoco$ano) +
  labs(
    title = "",
    x = " ",
    y = "Esforço Amostral e Abundância",
    colour = "",
    shape = "", # Isso ajuda a garantir que as formas correspondam na legenda
    linetype = "" # Isso ajuda a garantir que os tipos de linha correspondam na legenda
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = -0.5, size = 18, lineheight = 1.5), # Ajuste o lineheight conforme necessário
    legend.position = c(0.10, 0.93), # Define a posição da legenda no canto superior esquerdo
    legend.justification = c(0, 1), # Define a justificação da legenda para o canto superior esquerdo
    legend.box.just = "left", # Alinha a legenda à esquerda
    legend.box.background = element_rect(fill = "white", color = "white"),
    axis.ticks.y = element_line(color = "black"),
    axis.text.y = element_text(margin = margin(r = 5)),
    axis.text.x = element_text(margin = margin(r = 12)),
    axis.title.y = element_text(size = 10, margin = margin(r = 10)),
    axis.title.x = element_text(size = 10, margin = margin(t = 10)),
    axis.text = element_text(size = 10),
    axis.line = element_line(colour = "gray40"),
    legend.text = element_text(size = 10),
    axis.line.x = element_blank(),
    panel.grid.minor = element_blank()
  )

grafico


#knitr::include_graphics("imagens/cap04/bo_esforco.JPG")

```

</br>

## Resultados

</br>

Após a correção, limpeza e validação dos dados foram contabilizadas 85.386 borboletas frugívoras capturadas de 2014 a 2022. Desse total, 915 indivíduos (1%) foram registrados como ‘NA’ em sua tribo, sem a chance de verificação por falta de fotografias. Outras 604 borboletas (0.8%), registradas como recapturas, foram desconsideradas na contagem. Na Amazônia, foram capturados 76.309 indivíduos, no Cerrado 6.378 e na Mata Atlântica 2.700 indivíduos.  


### Regiões climáticas

</br>


Os períodos de amostragem propostos no protocolo do Programa Monitora para borboletas frugívoras na Amazônia seguem a mesma lógica aplicada para as regiões Central e Sudeste do Brasil, onde há alta abundância populacional e maior diversidade de espécies de borboletas frugívoras no final do período de chuvas intensas (@Checa_2009). Os períodos de amostragem para as regiões amazônicas apresentados a seguir baseiam-se na caracterização climática associada ao padrão de chuvas em toda a Amazônia (conforme @Marengo_2001). Com base na identificação dos padrões de chuva em cada região, foram definidas seis regiões climáticas que englobam as Unidades de Conservação participantes do Programa Monitora (@fig-regioes-climaticas). As regiões climáticas são: Central, Sudoeste, Leste, Sudeste, Norte e Noroeste. Isso permite determinar o período mais adequado para a amostragem (Tabela x), considerando que o regime de chuvas é uma característica regional relevante para as borboletas frugívoras (**referência**). 


O número de UCs e EAs amostradas varia bastante entre as regiões (@fig-regioes-climaticas). Atualmente, nenhuma UC da região Noroeste da Amazônia participa do Programa Monitora aplicando o protocolo de borboletas frugívoras. No entanto, seria de extrema importância implementar esse protocolo em pelo menos três UCs nessa região: ESEC Juami-Japurá, PARNA do Pico da Neblina e RESEX Auatí-Paraná.  

O número de UCs e EAs amostradas varia bastante entre as regiões (@fig-regioes-climaticas). Atualmente, nenhuma UC da região Noroeste da Amazônia participa do Programa Monitora aplicando o protocolo de borboletas frugívoras. No entanto, seria de extrema importância implementar esse protocolo em pelo menos três UCs nessa região: ESEC Juami-Japurá, PARNA do Pico da Neblina e RESEX Auatí-Paraná. Outra região climática em que se faz necessária a inclusão de mais UCs para o protocolo de borboletas frugívoras é a sudeste amazônica. Esta região é de extrema importância por abrigar uma rica diversidade de espécies e estar constantemente ameaçada pelo agronegócio e mineração. Sugere-se a inclusão da ESEC Iquê, REBIO Nascentes da Serra do Cachimbo, FLONA Jamanxim, PARNA Rio Novo e FLONA de Carajás. Além dessas regiões, é importante também a inclusão de UCs mais ao norte da região climática sudoeste. Assim, sugere-se a inclusão de UCs no médio e baixo rio Juruá, como as RESEX Médio Juruá, Baixo Juruá e FLONA de Tefé. 


</br>


```{r grafico ucs_ativas_taxa_acumulado}
#| label: fig-regioes-climaticas
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '60%'
#| fig-cap: "Mapa mostrando a proposta de distribuição das UCs participantes do Programa Monitora nos polígonos das regiões climáticas da Amazônia definidos em função do regime de chuvas."

knitr::include_graphics("imagens/cap04/bo_mapa_ucs.jpeg")

```


</br>

Tabela x. Localização das UCs em relação às regiões climáticas da Amazônia, incluindo o período sugerido de amostragens de borboletas indicado como o final das chuvas. As UCs com \* situam-se entre duas ou mais regiões climáticas (q. = quinzena). As UCs marcadas com \# ainda não iniciaram a amostragem de borboletas.  

</br>


De 2014 a 2022 as amostragens de borboletas frugívoras na região climática central amazônica foram realizadas em 41 EAs em 12 UCs (@fig-ucs-eas-combinado): ESEC da Terra do Meio, FLONA de Tapajós, PARNA da Amazônia, PARNA dos Campos Amazônicos, PARNA do Jaú, PARNA Nascentes do Lago Jari, REBIO do Jaru, REBIO do Uatumã, RESEX do Lago do Capanã Grande, RESEX Riozinho do Anfrísio, RESEX Tapajós-Arapiuns e RESEX Verde para Sempre.  

O sudoeste amazônico foi a região com o maior número de UCs aplicando o protocolo de borboletas no período de 2014 a 2022, com 14 UCs amostradas: ESEC Rio Acre, FLONA do Jamari, PARNA da Serra da Cutia, PARNA da Serra do Divisor, PARNA de Pacaás Novos, PARNA Mapinguari, RESEX Arapixi, RESEX Barreiro das Antas, RESEX Chico Mendes, RESEX do Alto Tarauacá, RESEX do Cazumbá-Iracema, RESEX do Rio do Cautário, RESEX Rio Ouro Preto e RESEX Riozinho da Liberdade. Nesta região, as coletas foram realizadas em 44 EAs (@fig-ucs-eas-combinado). 

Na região leste amazônica, as amostragens se iniciaram em 2016. Até 2022, seis UCs e 17 EAs foram amostradas (@fig-ucs-eas-combinado): ESEC do Jari, PARNA do Cabo Orange, PARNA Montanhas do Tumucumaque, REBIO do Gurupi, RESEX Ipaú-Anilzinho e RESEX Renascer.  

Na região sudeste amazônica, as amostragens de borboletas frugívoras também se iniciaram em 2016 e ocorreram em seis EAs, contemplando apenas duas UCs: PARNA do Juruena e REBIO do Tapirapé.  

Finalmente, na região norte da Amazônia, a aplicação do protocolo de borboletas frugívoras se iniciou em 2017, com cinco UCs e nove EAs amostradas até 2022 (@fig-ucs-eas-combinado): ESEC de Maracá, ESEC de Niquiá, PARNA da Serra da Mocidade, PARNA do Monte Roraima e PARNA do Viruá. 


</br>


```{r numero-ucs-amostradas}
#| label: fig-numero-ucs-amostradas
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '60%'



library(tidyverse)
library(ggplot2)
library(stringr)

# Carregar os dados
dados_borboletas <- read.table("dados/borboletas/dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]

# Converter o ano para fator
dados_borboletas$ano <- factor(dados_borboletas$ano)

# Filtrar os dados para incluir apenas regiões da Amazônia
dados_amazonia <- dados_borboletas %>%
  filter(regiao %in% c("central", "sudoeste", "leste", "sudeste", "norte"))

# Preparar os dados para o gráfico
contagem_uc_amazonia <- dados_amazonia %>%
  group_by(ano, regiao) %>%
  summarise(num_uc = n_distinct(uc))

# Definir a ordem dos níveis da variável regiao
contagem_uc_amazonia$regiao <- factor(contagem_uc_amazonia$regiao, levels = c("central", "sudoeste", "leste", "sudeste", "norte"))


# Cores para cada região da Amazônia
cores_amazonia <- c(
  "#003c30",
  "#01665e",
  "#35978f",
  "#80cdc1",
  "#c7eae5"
)

# Gráfico
grafico_uc_amazonia <- ggplot(contagem_uc_amazonia, aes(x = ano, y = num_uc, fill = regiao)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_fill_manual(values = cores_amazonia) + # Definindo as cores manualmente
  labs(
    x = "",
    y = "",
    fill = "",
    title = ""
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 26, hjust = 0, lineheight = 1.3),
    legend.position = c(0, 1.15), # Define a posição da legenda no canto superior esquerdo
    legend.justification = c(0, 1), # Define a justificação da legenda para o canto superior esquerdo
    legend.box.just = "left", # Alinha a legenda à esquerda
    legend.title = element_text(size = 20),
    legend.text = element_text(size = 20),
    axis.title.x = element_text(size = 20), 
    axis.text.x = element_text(size = 18),  
    #axis.line = element_line(colour = "gray40"),
    axis.line.x = element_blank(),
    axis.text.y = element_blank(),
    panel.grid.minor = element_blank() 
  ) 

# Exibir o gráfico
print(grafico_uc_amazonia)

##f1
grafico_uc_amazonia <- ggplot(contagem_uc_amazonia, aes(x = ano, y = num_uc, fill = regiao)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = num_uc), position = position_dodge(width = 0.9), vjust = -0.3, size = 3) + # Adicionando os valores
  scale_fill_manual(values = cores_amazonia) + # Definindo as cores manualmente
  labs(
    x = "",
    y = "",
    fill = "",
    title = "Número de UCs"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, hjust = 0.3, lineheight = 1.3),
    legend.position = c(0, 1.15), # Define a posição da legenda no canto superior esquerdo
    legend.justification = c(0, 1), # Define a justificação da legenda para o canto superior esquerdo
    legend.box.just = "left", # Alinha a legenda à esquerda
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 8),
    axis.title.x = element_text(size = 12), 
    axis.text.x = element_text(size = 10),  
    #axis.line = element_line(colour = "gray40"),
    axis.line.x = element_blank(),
    axis.text.y = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank() 
  ) 

# Exibir o gráfico
print(grafico_uc_amazonia)


# Salvar a imagem usando ggsave()

# ggsave(
#   filename = "grafico_numeros_de_uc_amazonia_f1.png",
#   plot = grafico_uc_amazonia,
#   device = "png",
#   path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",
#   dpi = 300,
#   width = 12,
#   height = 8,
#   units = "in"
# )


```


</br>

```{r numero-eas-amostradas}
#| label: fig-numero-eas-amostradas
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '60%'


library(tidyverse)
library(ggplot2)
library(stringr)

# Carregar os dados
dados_borboletas <- read.table("dados/borboletas/dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]

# Converter o ano para fator
dados_borboletas$ano <- factor(dados_borboletas$ano)

# Filtrar os dados para incluir apenas regiões da Amazônia
dados_amazonia <- dados_borboletas %>%
  filter(regiao %in% c("central", "sudoeste", "leste", "sudeste", "norte"))

# Preparar os dados para o gráfico
contagem_ea_amazonia <- dados_amazonia %>%
  group_by(ano, regiao) %>%
  summarise(num_ea = n_distinct(uc_ea))

# Definir a ordem dos níveis da variável regiao
contagem_ea_amazonia$regiao <- factor(contagem_ea_amazonia$regiao, levels = c("central", "sudoeste", "leste", "sudeste", "norte"))


# Cores para cada região da Amazônia
cores_amazonia <- c(
  "#543005",
  "#8c510a",
  "#bf812d",
  "#dfc27d",
  "#f6e8c3"
)


# Gráfico
grafico_ea_amazonia<-ggplot(contagem_ea_amazonia, aes(x = ano, y = num_ea, fill = regiao)) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = num_ea), position = position_dodge(width = 0.9), vjust = -0.3, size = 3) + # Adicionando os valores
  scale_fill_manual(values = cores_amazonia) + # Definindo as cores manualmente
  labs(
    x = "",
    y = "",
    fill = "",
    title = "Número de EAs"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, hjust = 0.3, lineheight = 1.3),
    legend.position = c(0, 1.15), # Define a posição da legenda no canto superior esquerdo
    legend.justification = c(0, 1), # Define a justificação da legenda para o canto superior esquerdo
    legend.box.just = "left", # Alinha a legenda à esquerda
    legend.title = element_text(size = 10),
    legend.text = element_text(size = 8),
    axis.title.x = element_text(size = 12), 
    axis.text.x = element_text(size = 10),  
    #axis.line = element_line(colour = "gray40"),
    axis.line.x = element_blank(),
    axis.text.y = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank() 
  ) 

# Exibir o gráfico
print(grafico_ea_amazonia)


# Salvar a imagem usando ggsave()

# ggsave(
#   filename = "grafico_numeros_de_ea_amazonia_f1.png",
#   plot = grafico_ea_amazonia,
#   device = "png",
#   path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela",
#   dpi = 300,
#   width = 12,
#   height = 8,
#   units = "in"
# )

```
</br>

```{r ucs-eas-amostradas}
#| label: fig-ucs-eas-amostradas
#| echo: false
#| message: false
#| warning: false
#| include: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'
#| fig-cap: "Número de unidades de conservação (UCs) e estações amostrais (EAs) do Programa Monitora na região amazônica por região climática com amostragem de borboletas frugívoras implementadas de 2014 a 2022."



library(gridExtra)
combinado <- grid.arrange(grafico_uc_amazonia, grafico_ea_amazonia, ncol=1)

# ggsave(
#   filename = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/ucs_eas_combinados.png",
#   plot = combinado,
#   device = "png",
#   dpi = 300,
#   width = 14,
#   height = 12,
#   units = "in"
# )

``` 

```{r grafico ucs-eas-combinado}
#| label: fig-ucs-eas-combinado
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'
#| fig-cap: "Número de unidades de conservação (UCs) e estações amostrais (EAs) do Programa Monitora na região amazônica por região climática com amostragem de borboletas frugívoras implementadas de 2014 a 2022."

knitr::include_graphics("imagens/cap04/bo-ucs-eas-combinados.png")

```



</br>


Para que os dados e informações neste relatório possam ser interpretados de forma adequada e com maior confiabilidade, foi estabelecido um esforço amostral mínimo para os biomas. Para cada região Amazônica, foi considerado o esforço amostral de 1.728 armadilhas/dia. Isso significa pelo menos três UCs consolidadas (i.e., 9 EAs) em que tenham sido executadas as duas campanhas (6 dias cada) no ano.  




## Assinatura das tribos de borboletas ao longo dos anos  

</br>

A assinatura de tribos de borboletas é uma forma gráfica de representar as proporções das tribos de borboletas de uma determinada comunidade presente naquele ano ou local. Ela se torna efetiva quando comparada em longo prazo ou entre locais. Com a assinatura de borboletas, detectam-se tribos mais representativas naquela comunidade amostrada, sendo possível assim, realizar diagnósticos ambientais mais informativos para aquela região ou ano.  

A abordagem que vem sendo utilizada no Programa Monitora considera a existência de um gradiente na associação entre as tribos de borboletas frugívoras e a estrutura das formações florestais, variando das florestas mais alteradas e/ou abertas até florestas mais adensadas e fechadas. O protocolo adotado pelo grupo de especialistas em borboletas considera que as tribos registradas estão relacionadas aos seguintes tipos de ambientes: 

- florestas fechadas/conservadas: Brassolini, Haeterini e Morphini. Em situações de perturbação da floresta a abundância relativa dessas tribos diminui consistentemente; 

- florestas abertas/alteradas (com abertura significativa no dossel): Ageroniini, Callicorini e Biblidini. As espécies dessas tribos são favorecidas por alterações na estrutura da floresta e suas abundâncias aumentam consistentemente com perturbações locais. 

As tribos Preponini, Melanitini, Anaeini, Epicaliini, Epiphilini, Coeini e Satyrini não apresentam associação clara com ambientes florestais ou não demonstram tendência definida. A abundância dessas tribos pode aumentar ou diminuir em resposta a perturbações da floresta, como abertura de clareiras ou eventuais alterações no dossel. 

Embora ainda pouco disseminada em trabalhos acadêmicos, a assinatura de tribos de borboletas tem um papel importante em relatórios técnicos de iniciativas de monitoramento de fauna. É uma maneira viável de analisar e apresentar dados de um grupo com grande riqueza de espécies de uma região megadiversa, amostrado em uma escala tão ampla como o Brasil. 


### Amazônia 

</br>

Na região climática central amazônica 25.481 borboletas frugívoras foram amostradas de 2014 a 2022. Visto que 174 indivíduos não foram identificados em nível de tribo e foram descartados, 25.307 indivíduos foram considerados nas análises. Desses, 43% pertencem à tribo Satyrini, a mais abundante da região, seguidos por 16% de Brassolini e 9% de Coeini. Os anos 2014 e 2020 tiveram um esforço amostral inferior àquele definido como mínimo aceitável para a região. Assim, a interpretação dos resultados nesses anos deve ser feita com cautela.  

As tribos Satyrini e Brassolini foram predominantes em praticamente todos os anos amostrados na região climática central amazônica. No entanto, em 2017 houve um aumento no número de Coeini, que foi a segunda tribo mais abundante (Figura 4.5.1). As tribos indicadoras de áreas abertas/perturbadas tiveram baixíssima representação. Porém, essas tribos tiveram um aumento no número de indivíduos em 2021 (Figura 4.5.1). 



</br>

```{r preparação gráficos assinaturas}
#| label: prep-graficos-assinaturas
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true

# Gráficos de dados Borboletas - Protocolo básico - Amazônia regional - individual
### Tribos com asterisco estão ausentes nos dados
## Script: Isabela Freitas Oliveira

library(ggplot2)
library(dplyr)
library(scales)
library(tools)

# Função auxiliar para ajustar o título
ajustar_titulo <- function(titulo) {
  palavras <- strsplit(titulo, " ")[[1]]
  
  # Palavras que necessitam de correção de acentuação
  correcoes <- list(
    "leste" = "Região climática Leste Amazônica", "sudoeste" = "Região climática Sudoeste Amazônica", "central" = "Região climática Central Amazônica",
    "norte" = "Região climática Norte Amazônica", "sudeste" = "Região climática Sudeste Amazônica"
  )
  
  palavras <- sapply(palavras, function(palavra) {
    # Aplicar regras específicas para certas palavras
    if (tolower(palavra) %in% c("esec", "flona", "rebio", "resex", "parna")) {
      return(toupper(palavra))
    } else if (tolower(palavra) %in% c("de", "da", "do", "dos", "das")) {
      return(tolower(palavra))
    } else {
      # Corrigir acentuação, se necessário
      palavra_corrigida <- tolower(palavra)
      if (palavra_corrigida %in% names(correcoes)) {
        return(correcoes[[palavra_corrigida]])
      } else {
        return(tools::toTitleCase(palavra))
      }
    }
  })
  
  return(paste(palavras, collapse = " "))
}


# Função para gerar o gráfico para cada região
gerar_grafico_por_regiao <- function(dados, nome_regiao) {
  # Preparar o título
  titulo <- ajustar_titulo(nome_regiao)  # Utilizando a função de ajuste de título aqui
  
  # Filtrar os dados para a região atual
  dados_regiao <- subset(dados, regiao == nome_regiao & bioma == "Amazonia")
  dados_regiao <- dados_regiao[!is.na(dados_regiao$tribo), ] #tirar os dados 'NA' que estão na tribo
  
  # Calcular o total de indivíduos por ano para a região atual
  total_individuos_por_ano <- dados_regiao %>%
    group_by(ano) %>%
    summarise(total = sum(soma_individuos), .groups = 'drop')
  
  # Agregar dados por ano e tribo
  dados_agregados <- dados_regiao %>%
    group_by(ano, tribo) %>%
    summarize(frequencia = sum(soma_individuos), .groups = 'drop')
  
  # Calcular totais e proporções
  total_por_ano <- dados_agregados %>%
    group_by(ano) %>%
    summarize(total = sum(frequencia), .groups = 'drop')
  
  dados_agregados <- left_join(dados_agregados, total_por_ano, by = "ano") %>%
    mutate(proporcao = frequencia / total * 100)
  
  # Ajustar proporções
  dados_agregados <- dados_agregados %>%
    group_by(ano) %>%
    mutate(diferenca = 100 - sum(proporcao),
           proporcao_ajustada = ifelse(proporcao == max(proporcao), proporcao + diferenca, proporcao)) %>%
    ungroup() %>%
    dplyr::select(-diferenca, -proporcao) %>%
    rename(proporcao = proporcao_ajustada)
  
  # Ordem específica das tribos
  ordem_tribos <- c(
    "Brassolini", "Morphini", "Haeterini", 
    "Preponini", "Melanitini", "Anaeini", 
    "Epicaliini","Epiphilini", "Coeini",
    "Satyrini",
    "Callicorini", "Biblidini","Ageroniini"
  )
  
  # Cores correspondentes às tribos - BLINDSAFE colors (3 categorias de verde, 7 categorias de cinza e 3 categorias de marrom)
  cores_tribos <- c(
    "Brassolini" = "#35978f", "Morphini" = "#80cdc1", "Haeterini" = "#c7eae5", 
    "Preponini" = "gray65", "Melanitini" = "gray70", "Anaeini" = "gray75", 
    "Epicaliini" = "gray80", "Epiphilini" = "gray85", "Coeini" = "gray90",
    "Satyrini" = "gray95",
    "Callicorini" = "#f6e8c3", "Biblidini" = "#dfc27d","Ageroniini" = "#bf812d"
  )
  
  # Ajustar a ordem e as cores das tribos com base nas tribos presentes
  cores_tribos <- cores_tribos[ordem_tribos]
  
  # Assegurar que a coluna 'tribo_clean' respeite a ordem definida
  dados_agregados$tribo <- factor(dados_agregados$tribo, levels = ordem_tribos)
  
  # Criar um data frame com a frequência agregada por tribo
  frequencias_por_tribo_ano <- aggregate(frequencia ~ tribo, dados_agregados, sum)
  
  # Criar uma função para determinar se um asterisco deve ser adicionado ao nome da tribo
  adicionar_asterisco <- function(nome_tribo) {
    # Verificar se existe alguma frequência igual a zero para essa tribo em qualquer ano
    if (any(frequencias_por_tribo_ano$tribo == nome_tribo & frequencias_por_tribo_ano$frequencia == 0)) {
      return(paste0(nome_tribo, "*"))
    } else {
      return(nome_tribo)
    }
  }
  
  # Aplicar a função a cada tribo para criar o vetor de rótulos
  labels_tribos <- sapply(ordem_tribos, adicionar_asterisco)
  
  # Criar um data frame com o número único de 'uc_ea' por ano
  numero_ea_por_ano <- dados_regiao %>%
    distinct(ano, uc_ea) %>%
    group_by(ano) %>%
    summarize(num_ea = n_distinct(uc_ea))
  
  # Construir o gráfico
  gg <- ggplot() +
    geom_bar(data = dados_agregados, aes(x = ano, y = proporcao, fill = tribo), stat = "identity", position = position_stack(reverse = FALSE)) +
    geom_text(data = total_individuos_por_ano, aes(x = ano, y = 100, label = total), vjust = -0.5, size = 3, hjust = 0.5)+
    geom_text(data = numero_ea_por_ano, aes(x = ano, y = 0, label = paste0("(", num_ea, ")")), vjust = 1.5, size = 3, hjust = 0.5, color = "gray40") +
    scale_y_continuous(labels = scales::number_format(scale = 1, accuracy = 1), limits = c(0, 100))+
    scale_x_discrete(expand = c(0, 0)) +
    scale_fill_manual(values = cores_tribos, 
                      labels = labels_tribos,
                      breaks = ordem_tribos) +
    labs(title = titulo,
         x = " ",
         y = "Frequência relativa de ocorrência (%)",
         fill = "Tribo") +
    theme_minimal() +
    theme(legend.position = "right", 
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 10), 
          plot.title = element_text(hjust = 0.5, size = 16), 
          plot.subtitle = element_text(hjust = 0.5, size = 14),
          axis.ticks.y = element_line(color = "black"),
          axis.text = element_text(size = 10), 
          axis.title = element_text(size = 10),
          axis.line = element_line(colour = "gray40"),
          axis.line.x = element_blank()) +
    guides(fill = guide_legend(title = "Tribos", reverse = FALSE))
  
  # Exibir o gráfico
  print(gg)
}

# Carregar e preparar os dados
resultado_final <- read.csv("dados/borboletas/resultado_final.csv", header = TRUE)
resultado_final$ano <- factor(resultado_final$ano)
resultado_final$tribo <- gsub("\\*", "", resultado_final$tribo)


```



```{r grafico regiao-climatica-central-amazonica}
#| label: fig-regiao-climatica-central-amazonica
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Abundância relativa de tribos de borboletas frugívoras de 2014 a 2022 na região climática central amazônica. Os números acima das barras indicam indivíduos registrados e os números entre parêntesis abaixo das barras se referem ao número de estações amostrais inspecionadas naquele ano."

# Definir a região de interesse - colocar as regiões 'norte', 'sudoeste', 'sudeste', 'leste', 'central'
regiao_interesse <- "central"

# Gerar o gráfico para a região de interesse
gerar_grafico_por_regiao(resultado_final, regiao_interesse)


# Salvar a imagem usando ggsave()
# ggsave(filename = "bo_regiao_climatica_central_amazonica.png",  # Escolha um nome adequado para o arquivo
#        plot = gg,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/imagens/cap04/",  # Especifique o diretório onde você deseja salvar o gráfico
#        dpi = 300,  # Define a resolução (DPI)
#        width = 10, height =8, units = "in")  # Define o tamanho da imagem

```

</br>


Na região climática sudoeste amazônica, foram amostradaos 34.525 indivíduos de borboletas frugívoras, 354 delas não identificadas e desconsideradas nas análises. Assim, 34.171 indivíduos foram identificados em nível de tribo: 48% Satyrini, 11% Brassolini e 9% Ageroniiini. Apesar de não serem maioria, a região sudoeste apresentou a maior proporção de tribos indicadoras de florestas abertas/perturbadas dentre as regiões da Amazônia. No caso, a tribo Ageroniini foi responsável por esse padrão, especialmente em 2019. É importante salientar que, apesar de Ageroniini ser classificada como uma tribo indicadora de florestas abertas/perturbadas, diversas espécies do gênero *Hamadryas* (e.g., *Hamadryas alicia*, *Hamadryas belladonna*, *Hamadryas velutina*) e dos gêneros *Batesia* e *Panacea* estão geralmente presentes em florestas maduras e bem conservadas. Dessa forma, torna-se ainda mais necessária a aplicação do protocolo avançado nas UCs para que, com as fotografias dos indivíduos, seja possível separar espécies na tribo que utilizam regularmente florestas abertas/perturbadas, como por exemplo *Hamadryas februa*, *Hamadryas feronia*, *Hamadryas amphinome* e *Ectima iona*, das espécies anteriormente citadas, habitantes de florestas fechadas/preservadas (Jenkins, 1983).  

Seguindo os padrões de diversidade da fauna e flora amazônicas, a região sudoeste apresentou os maiores valores de números de indivíduos por esforço amostral. Apesar de tratar-se de contagem de indivíduos, é de se esperar que a riqueza e diversidade de espécies acompanhem este padrão. Somente a partir de 2017 o esforço amostral foi adequado para representar a região. 

</br>

```{r grafico regiao-climatica-sudoeste-amazonica}
#| label: fig-regiao-climatica-sudoeste-amazonica
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Abundância relativa de tribos de borboletas frugívoras de 2014 a 2022 na região climática sudoeste. Os números acima das barras indicam indivíduos registrados e os números entre parêntesis abaixo das barras se referem ao número de estações amostrais inspecionadas naquele ano."

# Definir a região de interesse - colocar as regiões 'norte', 'sudoeste', 'sudeste', 'leste', 'central'
regiao_interesse <- "sudoeste"

# Gerar o gráfico para a região de interesse
gerar_grafico_por_regiao(resultado_final, regiao_interesse)

```


</br>

Na região climática leste amazônica foram amostradas 7.969 borboletas frugívoras, com 67 indivíduos não identificados em nível de tribo. Assim, dos 7.902 indivíduos de borboletas frugívoras identificados na região leste da Amazônia, 46% corresponderam à tribo Satyrini, a mais representativa, seguida por Brassolini (15%) e Morphini (11%). Os anos 2016, 2017 e 2020 tiveram amostragens abaixo do esforço adequado para representar a região.  

O padrão da proporção da abundância das tribos foi bastante estável, com pouca variação entre anos. 



```{r grafico regiao-climatica-leste-amazonica}
#| label: fig-regiao-climatica-leste-amazonica
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Abundância relativa de tribos de borboletas frugívoras de 2016 a 2022 na região climática leste amazônica. Os números acima das barras indicam indivíduos registrados e os números entre parêntesis abaixo das barras se referem ao número de estações amostrais inspecionadas naquele ano. "

# Definir a região de interesse - colocar as regiões 'norte', 'sudoeste', 'sudeste', 'leste', 'central'
regiao_interesse <- "leste"

# Gerar o gráfico para a região de interesse
gerar_grafico_por_regiao(resultado_final, regiao_interesse)

```

</br>


Ao todo, foram amostrados 5.042 indivíduos de borboletas frugívoras na região sudeste amazônica. Desses, 48 indivíduos foram descartados na análise por não terem sido identificados. Assim, 4.994 borboletas frugívoras foram identificadas em nível de tribo. Dentre as mais abundantes destacaram-se Satyrini (58%), Epicaliini (11%) e Morphini (11%).  

Apesar do baixo número de UCs nesta região, o padrão da proporção das tribos ao longo dos anos variou pouco. 


</br>

```{r grafico regiao-climatica-sudeste-amazonica}
#| label: fig-regiao-climatica-sudeste-amazonica
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Abundância relativa de tribos de borboletas frugívoras de 2016 a 2022 na região climática sudeste amazônica. Não houve amostragem em 2020. Os números acima das barras indicam indivíduos registrados e os números entre parêntesis abaixo das barras se referem ao número de estações amostrais inspecionadas naquele ano."

# Definir a região de interesse - colocar as regiões 'norte', 'sudoeste', 'sudeste', 'leste', 'central'
regiao_interesse <- "sudeste"

# Gerar o gráfico para a região de interesse
gerar_grafico_por_regiao(resultado_final, regiao_interesse)

```

</br>


Na região climática norte amazônica o esforço mínimo para a representação da comunidade de borboletas frugívoras não foi atingido em nenhum ano. Uma das razões é a complexidade logística para a amostragem em algumas UCs do norte da Amazônia. Por exemplo, as amostragens no PARNA do Monte Roraima precisam ser feitas na forma de expedições, devido às dificuldades de acesso através da Terra indígena Raposa Serra do Sol, levando dias por terra ou com um alto custo utilizando aviões monomotores. Outro fator que influenciou a diminuição do número de EAs amostradas foi a invasão da ESEC Maracá por garimpeiros em 2019, com ameaças e roubo de equipamentos da UC. A ESEC Maracá era a única UC consolidada nao região Norte. Assim, é necessário se reestabelecer a amostragem na ESEC Maracá e aumentar o número de EAs implementadas no PARNA da Serra da Mocidade, na ESEC de Niquiá e no PARNA do Viruá. 

Ao todo, foram amostradas 3.303 borboletas frugívoras nessa região. Dessas, 190 não foram identificadas em nível de tribo, tendo sido descartadas, de forma que 3.113 indivíduos identificados foram considerados na análise. Dentre as tribos mais abundantes destacam-se Satyrini, Brassolini e Preponini, com 55%, 15% e 6%, respectivamente. 

O padrão da assinatura das tribos nos anos não variou drasticamente. Porém, o número de indivíduos foi bastante influenciado pelo número de estações amostrais (@fig-regiao-climatica-sudeste-amazonica). 

</br>

```{r grafico regiao-climatica-norte-amazonica}
#| label: fig-regiao-climatica-norte-amazonica
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Abundância relativa de tribos de borboletas frugívoras de 2017 a 2022 na região climática norte amazônica. Os números acima das barras indicam indivíduos registrados e os números entre parêntesis abaixo das barras se referem ao número de estações amostrais inspecionadas naquele ano. O asterisco indica tribo ausente na amostragem. "

# Definir a região de interesse - colocar as regiões 'norte', 'sudoeste', 'sudeste', 'leste', 'central'
regiao_interesse <- "norte"

# Gerar o gráfico para a região de interesse
gerar_grafico_por_regiao(resultado_final, regiao_interesse)

```

</br>


### Cerrado e Mata Atlântica  

</br>

Até o momento, poucas UCs dos biomas Cerrado e Mata Atlântica aplicaram o protocolo de amostragem de borboletas frugívoras. Dessa forma, os resultados apresentados aqui requerem cautela na interpretação. 

No Cerrado foram amostrados 6.378 indivíduos (67 deles não identificados em nível de tribo), sendo 6.311 considerados nas análises. As tribos mais representativas no Cerrado foram Satyrini, Ageroniini e Biblidini com 40%, 14% e 8%, respectivamente. 

Os padrões anuais apresentaram grandes variações na proporção das tribos indicadoras, especialmente de Brassolini, Morphini, Biblidini e Ageroniini (@fig-regiao-cerrado). 

 

</br>

```{r assinatura cerrado}
#| label: fig-regiao-cerrado
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Abundância relativa de tribos de borboletas frugívoras de 2014 a 2022 no Cerrado. Não houve amostragem em 2020. Os números acima das barras indicam indivíduos registrados e os números entre parêntesis abaixo das barras se referem ao número de estações amostrais inspecionadas naquele ano. O asterisco indica tribo ausente na amostragem."

# Gráficos de dados Borboletas - Protocolo básico - Cerrado -
### Tribos com asterisco estão ausentes nos dados
## Script: Isabela Freitas Oliveira

library(ggplot2)
library(dplyr)
library(scales)
library(tools)


# Função auxiliar para ajustar o título
ajustar_titulo <- function(titulo) {
  palavras <- strsplit(titulo, " ")[[1]]
  
  # Palavras que necessitam de correção de acentuação
  #correcoes <- list(
   # "Cerrado" = "Cerrado")
  
}

# Função para gerar o gráfico para cada unidade de conservação
gerar_grafico_por_bioma <- function(dados, nome_bioma) {
  # Preparar o título com as novas regras
  titulo <- gsub("_", " ", nome_bioma)
  titulo <- ajustar_titulo(titulo)  # Utilizando a função de ajuste de título aqui
  
  # Filtrar os dados para a unidade de conservação atual
  dados_bioma <- subset(dados, bioma == nome_bioma & bioma == "Cerrado")
  dados_bioma <- dados_bioma[!is.na(dados_bioma$tribo), ] #tirar os dados 'NA' que estão na tribo
  
  # Calcular o total de indivíduos por ano para a região atual
  total_individuos_por_ano <- dados_bioma %>%
    group_by(ano) %>%
    summarise(total = sum(soma_individuos), .groups = 'drop')
  
  # Agregar dados por ano e tribo
  dados_agregados <- dados_bioma %>%
    group_by(ano, tribo) %>%
    summarize(frequencia = sum(soma_individuos), .groups = 'drop')
  
  # Calcular totais e proporções
  total_por_ano <- dados_agregados %>%
    group_by(ano) %>%
    summarize(total = sum(frequencia), .groups = 'drop')
  
  dados_agregados <- left_join(dados_agregados, total_por_ano, by = "ano") %>%
    mutate(proporcao = frequencia / total * 100)
  
  # Ajustar proporções
  dados_agregados <- dados_agregados %>%
    group_by(ano) %>%
    mutate(diferenca = 100 - sum(proporcao),
           proporcao_ajustada = ifelse(proporcao == max(proporcao), proporcao + diferenca, proporcao)) %>%
    ungroup() %>%
    dplyr::select(-diferenca, -proporcao) %>%
    rename(proporcao = proporcao_ajustada)
  
  # Ordem específica das tribos
  ordem_tribos <- c(
    "Brassolini", "Morphini", "Haeterini", 
    "Preponini", "Melanitini", "Anaeini", 
    "Epicaliini","Epiphilini", "Coeini",
    "Satyrini",
    "Callicorini", "Biblidini","Ageroniini"
  )
  
  # Cores correspondentes às tribos - BLINDSAFE colors (3 categorias de verde, 7 categorias de cinza e 3 categorias de marrom)
  cores_tribos <- c(
    "Brassolini" = "#35978f", "Morphini" = "#80cdc1", "Haeterini" = "#c7eae5", 
    "Preponini" = "gray65", "Melanitini" = "gray70", "Anaeini" = "gray75", 
    "Epicaliini" = "gray80", "Epiphilini" = "gray85", "Coeini" = "gray90",
    "Satyrini" = "gray95",
    "Callicorini" = "#f6e8c3", "Biblidini" = "#dfc27d","Ageroniini" = "#bf812d"
  )
  
  # Ajustar a ordem e as cores das tribos com base nas tribos presentes
  cores_tribos <- cores_tribos[ordem_tribos]
  
  # Assegurar que a coluna 'tribo_clean' respeite a ordem definida
  dados_agregados$tribo <- factor(dados_agregados$tribo, levels = ordem_tribos)
  
  # Criar um data frame com a frequência agregada por tribo
  frequencias_por_tribo_ano <- aggregate(frequencia ~ tribo, dados_agregados, sum)
  
  # Criar uma função para determinar se um asterisco deve ser adicionado ao nome da tribo
  adicionar_asterisco <- function(nome_tribo) {
    # Verificar se existe alguma frequência igual a zero para essa tribo em qualquer ano
    if (any(frequencias_por_tribo_ano$tribo == nome_tribo & frequencias_por_tribo_ano$frequencia == 0)) {
      return(paste0(nome_tribo, "*"))
    } else {
      return(nome_tribo)
    }
  }
  
  # Aplicar a função a cada tribo para criar o vetor de rótulos
  labels_tribos <- sapply(ordem_tribos, adicionar_asterisco)
  
  # Criar um data frame com o número único de 'uc_ea' por ano
  numero_ea_por_ano <- dados_bioma %>%
    distinct(ano, uc_ea) %>%
    group_by(ano) %>%
    summarize(num_ea = n_distinct(uc_ea))
  
  # Construir o gráfico
  gg <- ggplot() +
    geom_bar(data = dados_agregados, aes(x = ano, y = proporcao, fill = tribo), stat = "identity", position = position_stack(reverse = FALSE)) +
    geom_text(data = total_individuos_por_ano, aes(x = ano, y = 100, label = total), vjust = -0.5, size = 3, hjust = 0.5)+
    geom_text(data = numero_ea_por_ano, aes(x = ano, y = 0, label = paste0("(", num_ea, ")")), vjust = 1.5, size = 3, hjust = 0.5, color = "gray40") +
    scale_y_continuous(labels = scales::number_format(scale = 1, accuracy = 1), limits = c(0, 100))+
    scale_x_discrete(expand = c(0, 0)) +
    scale_fill_manual(values = cores_tribos, 
                      labels = labels_tribos,
                      breaks = ordem_tribos) +
    labs(title = titulo,
         x = " ",
         y = "Frequência relativa de ocorrência (%)",
         fill = "Tribo") +
    theme_minimal() +
    theme(legend.position = "right", 
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 10), 
          plot.title = element_text(hjust = 0.5, size = 16), 
          plot.subtitle = element_text(hjust = 0.5, size = 14),
          axis.ticks.y = element_line(color = "black"),
          axis.text = element_text(size = 10), 
          axis.title = element_text(size = 10),
          axis.line = element_line(colour = "gray40"),
          axis.line.x = element_blank()) +
    guides(fill = guide_legend(title = "Tribos", reverse = FALSE))
  
  
  # Exibir o gráfico
  print(gg)
  
  # Retorna o gráfico para que possa ser salvo externamente
  return(gg)
  
}

# Carregar e preparar os dados
resultado_final <- read.csv("dados/borboletas/resultado_final.csv", header = TRUE)
resultado_final$ano <- factor(resultado_final$ano)
resultado_final$tribo <- gsub("\\*", "", resultado_final$tribo)

# Obter todas as UC's do bioma Cerrado
biomas <- unique(resultado_final$bioma[resultado_final$bioma == "Cerrado"])

# Aplicar a função
graficos <- lapply(biomas, function(bioma) gerar_grafico_por_bioma(resultado_final, bioma))

# Salvar a imagem usando ggsave()
# ggsave(filename = "bo_cerrado.png",  # Escolha um nome adequado para o arquivo
#        plot = graficos[[1]],  # Especifique qual gráfico da lista deseja salvar
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/imagens/cap04",  # Especifique o diretório onde você deseja salvar o gráfico
#        dpi = 300,  # Define a resolução (DPI)
#        width = 10, height = 8, units = "in")  # Define o tamanho da imagem


```



Na Mata Atlântica 2.700 borboletas frugívoras foram amostradas. Dessas, 16 não foram identificadaos no nível de tribo, de modo que 2.684 indivíduos amostrados foram considerados na análise. A tribo Satyrini foi a mais representativa, com 27% dos indivíduos, seguida por Anaeini, com 24% e Epicaliini, com 14%. 

Houve uma grande variação das tribos entre anos, especialmente de Brassolini, Anaeini, Coeini e Satyrini (@fig-regiao-mata-atlantica). Verificou-se também grande variação no número de indivíduos, mesmo quando com um mesmo esforço amostral, indicando haver de fato diferenças na abundância entre regiões. Assim, é de extrema importância que as amostragens sejam feitas continuamente nas mesmas UCs e que, com a adesão de novas unidades de conservação da região ao programa de monitoramento, as amostragens nas UCs com protocolo de borboletas frugívoras já implementado sejam mantidas. 



</br>


```{r assinatura mata atlântica}
#| label: fig-regiao-mata-atlantica
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Abundância relativa de tribos de borboletas frugívoras de 2015 a 2022 na Mata Atlântica. Não houve amostragem em 2020. Os números acima das barras indicam indivíduos registrados e os números entre parêntesis abaixo das barras se referem ao número de estações amostrais inspecionadas naquele ano. O asterisco indica tribo ausente na amostragem."


##### Gráficos de dados Borboletas - Protocolo básico - Mata Atlantica
### Tribos com asterisco estão ausentes no gráfico
## Script: Isabela Freitas Oliveira

# Carregar bibliotecas
library(ggplot2)
library(dplyr)
library(scales)
library(tools)



# Função auxiliar para ajustar o título
ajustar_titulo <- function(titulo) {
  palavras <- strsplit(titulo, " ")[[1]]
  
  # Palavras que necessitam de correção de acentuação
  correcoes <- list(
    "Mata_Atlantica" = "Mata Atlântica")
  
}

# Função para gerar o gráfico para cada unidade de conservação
gerar_grafico_por_bioma <- function(dados, nome_bioma) {
  # Preparar o título com as novas regras
  titulo <- gsub("_", " ", nome_bioma)
  titulo <- ajustar_titulo(titulo)  # Utilizando a função de ajuste de título aqui
  
  # Filtrar os dados para a unidade de conservação atual
  dados_bioma <- subset(dados, bioma == nome_bioma & bioma == "Mata_Atlantica")
  dados_bioma <- dados_bioma[!is.na(dados_bioma$tribo), ] #tirar os dados 'NA' que estão na tribo
  
  # Calcular o total de indivíduos por ano para a região atual
  total_individuos_por_ano <- dados_bioma %>%
    group_by(ano) %>%
    summarise(total = sum(soma_individuos), .groups = 'drop')
  
  # Agregar dados por ano e tribo
  dados_agregados <- dados_bioma %>%
    group_by(ano, tribo) %>%
    summarize(frequencia = sum(soma_individuos), .groups = 'drop')
  
  # Calcular totais e proporções
  total_por_ano <- dados_agregados %>%
    group_by(ano) %>%
    summarize(total = sum(frequencia), .groups = 'drop')
  
  dados_agregados <- left_join(dados_agregados, total_por_ano, by = "ano") %>%
    mutate(proporcao = frequencia / total * 100)
  
  # Ajustar proporções
  dados_agregados <- dados_agregados %>%
    group_by(ano) %>%
    mutate(diferenca = 100 - sum(proporcao),
           proporcao_ajustada = ifelse(proporcao == max(proporcao), proporcao + diferenca, proporcao)) %>%
    ungroup() %>%
    dplyr::select(-diferenca, -proporcao) %>%
    rename(proporcao = proporcao_ajustada)
  
  # Ordem específica das tribos
  ordem_tribos <- c(
    "Brassolini", "Morphini", "Haeterini", 
    "Preponini", "Melanitini", "Anaeini", 
    "Epicaliini","Epiphilini", "Coeini",
    "Satyrini",
    "Callicorini", "Biblidini","Ageroniini"
  )
  
  # Cores correspondentes às tribos - BLINDSAFE colors (3 categorias de verde, 7 categorias de cinza e 3 categorias de marrom)
  cores_tribos <- c(
    "Brassolini" = "#35978f", "Morphini" = "#80cdc1", "Haeterini" = "#c7eae5", 
    "Preponini" = "gray65", "Melanitini" = "gray70", "Anaeini" = "gray75", 
    "Epicaliini" = "gray80", "Epiphilini" = "gray85", "Coeini" = "gray90",
    "Satyrini" = "gray95",
    "Callicorini" = "#f6e8c3", "Biblidini" = "#dfc27d","Ageroniini" = "#bf812d"
  )
  
  # Ajustar a ordem e as cores das tribos com base nas tribos presentes
  cores_tribos <- cores_tribos[ordem_tribos]
  
  # Assegurar que a coluna 'tribo_clean' respeite a ordem definida
  dados_agregados$tribo <- factor(dados_agregados$tribo, levels = ordem_tribos)
  
  # Criar um data frame com a frequência agregada por tribo
  frequencias_por_tribo_ano <- aggregate(frequencia ~ tribo, dados_agregados, sum)
  
  # Criar uma função para determinar se um asterisco deve ser adicionado ao nome da tribo
  adicionar_asterisco <- function(nome_tribo) {
    # Verificar se existe alguma frequência igual a zero para essa tribo em qualquer ano
    if (any(frequencias_por_tribo_ano$tribo == nome_tribo & frequencias_por_tribo_ano$frequencia == 0)) {
      return(paste0(nome_tribo, "*"))
    } else {
      return(nome_tribo)
    }
  }
  
  # Aplicar a função a cada tribo para criar o vetor de rótulos
  labels_tribos <- sapply(ordem_tribos, adicionar_asterisco)
  
  # Criar um data frame com o número único de 'uc_ea' por ano
  numero_ea_por_ano <- dados_bioma %>%
    distinct(ano, uc_ea) %>%
    group_by(ano) %>%
    summarize(num_ea = n_distinct(uc_ea))
  
  # Construir o gráfico
  gg <- ggplot() +
    geom_bar(data = dados_agregados, aes(x = ano, y = proporcao, fill = tribo), stat = "identity", position = position_stack(reverse = FALSE)) +
    geom_text(data = total_individuos_por_ano, aes(x = ano, y = 100, label = total), vjust = -0.5, size = 3, hjust = 0.5)+
    geom_text(data = numero_ea_por_ano, aes(x = ano, y = 0, label = paste0("(", num_ea, ")")), vjust = 1.5, size = 3, hjust = 0.5, color = "gray40") +
    scale_y_continuous(labels = scales::number_format(scale = 1, accuracy = 1), limits = c(0, 100))+
    scale_x_discrete(expand = c(0, 0)) +
    scale_fill_manual(values = cores_tribos, 
                      labels = labels_tribos,
                      breaks = ordem_tribos) +
    labs(title = titulo,
         x = " ",
         y = "Frequência relativa de ocorrência (%)",
         fill = "Tribo") +
    theme_minimal() +
    theme(legend.position = "right", 
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 10), 
          plot.title = element_text(hjust = 0.5, size = 16), 
          plot.subtitle = element_text(hjust = 0.5, size = 14),
          axis.ticks.y = element_line(color = "black"),
          axis.text = element_text(size = 10), 
          axis.title = element_text(size = 10),
          axis.line = element_line(colour = "gray40"),
          axis.line.x = element_blank()) +
    guides(fill = guide_legend(title = "Tribos", reverse = FALSE))
  
  # Exibir o gráfico
  print(gg)
}

# Carregar e preparar os dados
resultado_final <- read.csv("dados/borboletas/resultado_final.csv", header = TRUE)
resultado_final$ano <- factor(resultado_final$ano)
resultado_final$tribo <- gsub("\\*", "", resultado_final$tribo)

# Obter todas as UC's do bioma Mata Atlântica
biomas <- unique(resultado_final$bioma[resultado_final$bioma == "Mata_Atlantica"])

# Aplicar a função
graficos <- lapply(biomas, function(bioma) gerar_grafico_por_bioma(resultado_final, bioma))

# Salvar a imagem usando ggsave()
# ggsave(filename = "mata_atlantica.png",  # Escolha um nome adequado para o arquivo
#        plot = graficos[[1]],  # Especifique qual gráfico da lista deseja salvar
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/imagens/cap04",  # Especifique o diretório onde você deseja salvar o gráfico
#        dpi = 300,  # Define a resolução (DPI)
#        width = 10, height = 8, units = "in")  # Define o tamanho da imagem


```


</br>



### Índices de abundância de tribos  

</br>

Para avaliar as flutuações dos índices de abundância ao longo dos anos, foram utilizadas somente as tribos indicadoras de ambientes preservados e perturbados. Dessa forma, foram somados os números de indivíduos das tribos Brassolini, Morphini e Haeterini para cada ano, representando as borboletas indicadoras de ambientes fechados/preservados e o número de indivíduos das tribos Callicorini, Biblidini e Ageroniini, tribos de borboletas de florestas abertas/perturbadas. Os valores de índice de abundância de cada tribo por ano são apresentados no **Apêndice xx**.  


</br>

#### Cálculo do índice 

</br>

O índice de abundância tem como base o número acumulado de indivíduos de cada tribo em cada ano numa dada área. Partindo do número de indivíduos por ano (*n*), é feita uma correção, somando um número muito pequeno de forma a evitar a presença de zeros na matriz. Desta forma, é obtida a frequência absoluta corrigida (*f* = n + 0.00001). Em seguida, é calculada a frequência absoluta corrigida pelo esforço amostral (*fe*) para padronização: *fe* = *f* / (número de armadilhas * dias de amostragem). O índice de abundância (*i*) é calculado através da divisão da fe do ano específico sobre o valor da fe do primeiro ano em que aquela “população” foi registrada. Foi considerada primeira ocorrência quando a abundância da “população” no ano foi ≥ 20 indivíduos. O índice de abundância da primeira ocorrência (*i*0) é padronizado com o valor 1,0. Considerando que a frequência corrigida apresenta grandes variações de abundância e esforço amostral entre anos, foi feita uma transformação logarítmica (log10 + 1) do índice de abundância. Assim, valores acima de 1,0 indicam um aumento "populacional" referente ao primeiro ano e valores abaixo de 1,0 indicam uma redução "populacional".  


Neste relatório, foram feitas duas abordagens do índice de abundância. O primeiro se refere à flutuação do índice de abundância em relação ao ano anterior. Exemplo do cálculo do índice de abundância no terceiro ano de amostragem: 

*f*~3~ = *n* + 000001 

*fe*~3~ = *f*~3~ / esforço anual 

*i*~3~ = log~10~ (*fe*~3~ / *fe*~2~) + 1 

</b>  


Esta abordagem revela, por exemplo, o quanto a "população" está se 'recuperando' de um declínio no ano anterior. Estes valores podem ser encontrados nas tabelas x,x,x,x,x.  


A segunda abordagem segue o princípio do *Live Planet Index* (LPI), no qual os índices de abundância dos anos amostrados fazem referência ao primeiro ano em que a "população" foi registrada. Esta flutuação "populacional" pode ser vista nas figuras abaixo. Exemplo do cálculo do índice de abundância no terceiro ano de amostragem: 


*f*~3~= *n* + 000001 

*fe*~3~ = f~3~ / esforço anual 

*i*~3~ = log~10~ (*fe*~3~ / *fe*~0~) + 1 


</br>


#### Regional Amazônica 

</br>

Na primeira abordagem utilizada para o índice de abundância, comparamos os valores de cada ano referente ao ano anterior. Na região climática central Amazônica, as tribos indicadoras de florestas abertas/perturbadas tiveram um aumento 'populacional' em 2017 referente a 2016, porém, houve uma redução nos anos de 2018 e 2019 (Tabela xx). Em 2020 e 2021, os valores aumentaram consecutivamente, mas em 2022 houve uma grande redução 'populacional' (Tabela xx). No caso das borboletas de florestas fechadas/preservadas, notou-se uma oscilação de crescimento e redução 'populacional' ao longo dos anos, com crescimento nos anos de 2020 e 2021 (Tabela xx). 


</br>


Na região climática central amazônica.... 

</br>

```{r tab_ind_abund_regiao_central}
#| label: tbl-ind-abund-regiao-central
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| fig.align: "center"
#| out.width: '70%'
#| tbl-cap: "Índice de abundância das tribos indicadoras de cada ano da Região Climática Central Amazônica."


# tab_ind_abund_regiao_central <- read_csv2("dados/tabelas/borboletas/tab_ind_abund_regiao_central.csv")
# 
# tabela_indice_abund_regiao_central <- kbl(tab_ind_abund_regiao_central,
#              booktabs = TRUE,
#              longtable = TRUE, 
#              caption = "Índice de abundância das tribos indicadoras de cada ano da Região Climática Central Amazônica. Os valores dos índices estão em referência ao ano anterior. Nos anos em negrito, o esforço amostral foi menor que 1.728 armadilhas/dia e os dados devem ser interpretados com cautela. 'NA' indica que a primeira ocorrência apresentou uma abundância < 20 indivíduos no ano e assim não foi considerada na análise.",
#              col.names = c(" ", "[2014]", "2015", "2016", "2017", "2018", "2019", "[2020]", "2021", "2022"), align = c("l", "l", "l", "l", "l", "l", "l", "l", "l", "l")) %>%
#   #row_spec(0, bold = F) |> 
#     # column_spec(3, italic = TRUE) %>%
# kable_styling(full_width = F, bootstrap_options = c("striped", "hover", "condensed", "responsive"), latex_options = c("repeat_header"), repeat_header_text = "\\textit{(continuação)}") 
# 
# 
# tabela_indice_abund_regiao_central


knitr::include_graphics("imagens/cap04/tbl-IA-regiao-climatica-central-amazonica.png")


```
</br>
</br>
</br>

Na região climática sudoeste amazônica.... 

</br>

```{r tab_ind_abund_regiao_sudoeste}
#| label: tbl-ind_abund_regiao_sudoeste
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| fig.align: "center"
#| out.width: '70%'
#| tbl-cap: "Índice de abundância das tribos indicadoras de cada ano da Região Climática Sudoeste Amazônica."


# tab_ind_abund_regiao_sudoeste <- read_csv2("dados/tabelas/borboletas/tab_ind_abund_regiao_sudoeste.csv")
# 
# tabela_indice_abund_regiao_sudoeste <- kbl(tab_ind_abund_regiao_sudoeste,
#              booktabs = TRUE,
#              longtable = TRUE, 
#              caption = "Índice de abundância das tribos indicadoras de cada ano da Região Climática Sudoeste Amazônica. Os valores dos índices estão em referência ao ano anterior. Nos anos em negrito, o esforço amostral foi menor que 1.728 armadilhas/dia e os dados devem ser interpretados com cautela. 'NA' indica que a primeira ocorrência teve uma abundância < 20 indivíduos no ano e não foi considerada na análise.",
#              col.names = c(" ", "[2014]", "[2015]", "[2016]", "2017", "2018", "2019", "2020", "2021", "2022"), align = c("l", "l", "l", "l", "l", "l", "l", "l", "l", "l")) %>%
#   #row_spec(0, bold = F) |> 
#     # column_spec(3, italic = TRUE) %>%
# kable_styling(full_width = F, bootstrap_options = c("striped", "hover", "condensed", "responsive"), latex_options = c("repeat_header"), repeat_header_text = "\\textit{(continuação)}") 
# 
# 
# tabela_indice_abund_regiao_sudoeste


knitr::include_graphics("imagens/cap04/tbl-IA-regiao-climatica-sudoeste-amazonica.png")

```


</br>
</br>
</br>

Na região climática leste amazônica.... 

</br>

```{r tab_ind_abund_regiao_leste}
#| label: tbl-ind_abund_regiao_leste
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| fig.align: "center"
#| out.width: '70%'
#| tbl-cap: "Índice de abundância das tribos indicadoras de cada ano da Região Climática Leste Amazônica."


# tab_ind_abund_regiao_leste <- read_csv2("dados/tabelas/borboletas/tab_ind_abund_regiao_leste.csv")
# 
# tabela_indice_abund_regiao_leste <- kbl(tab_ind_abund_regiao_leste,
#              booktabs = TRUE,
#              longtable = TRUE, 
#              caption = "Índice de abundância das tribos indicadoras de cada ano da Região Climática Leste Amazônica. Os valores dos índices estão em referência ao ano anterior. Nos anos em negrito, o esforço amostral foi menor que 1.728 armadilhas/dia e os dados devem ser interpretados com cautela. Nos anos sublinhados, nenhuma UC da região foi amostrada. 'NA' indica que a primeira ocorrência teve uma abundância < 20 indivíduos no ano e não foi considerada na análise.",
#              col.names = c(" ", "(2014)", "(2015)", "[2016]", "[2017]", "2018", "2019", "2020", "2021", "2022"), align = c("l", "l", "l", "l", "l", "l", "l", "l", "l", "l")) %>%
#   #row_spec(0, bold = F) |> 
#     # column_spec(3, italic = TRUE) %>%
# kable_styling(full_width = F, bootstrap_options = c("striped", "hover", "condensed", "responsive"), latex_options = c("repeat_header"), repeat_header_text = "\\textit{(continuação)}") 
# 
# 
# tabela_indice_abund_regiao_leste

knitr::include_graphics("imagens/cap04/tbl-IA-regiao-climatica-leste-amazonica.png")


```


</br>
</br>
</br>

Na região climática sudeste amazônica.... 

</br>

```{r tab_ind_abund_regiao_sudeste}
#| label: tbl-ind_abund_regiao_sudeste
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| fig.align: "center"
#| out.width: '70%'
#| tbl-cap: "Índice de abundância das tribos indicadoras de cada ano da Região Climática Sudeste Amazônica."


# tab_ind_abund_regiao_sudeste <- read_csv2("dados/tabelas/borboletas/tab_ind_abund_regiao_sudeste.csv")
# 
# tabela_indice_abund_regiao_sudeste <- kbl(tab_ind_abund_regiao_sudeste,
#              booktabs = TRUE,
#              longtable = TRUE, 
#              caption = "Índice de abundância das tribos indicadoras de cada ano da Região Climática Sudeste Amazônica. Os valores dos índices estão em referência ao ano anterior. Nos anos em negrito, o esforço amostral foi menor que 1.728 armadilhas/dia e os dados devem ser interpretados com cautela. Nos anos sublinhados nenhuma UC da região foi amostrada. 'NA' indica que a primeira ocorrência apresentou uma abundância < 20 indivíduos no ano e não foi considerada na análise.",
#              col.names = c(" ", "(2014)", "(2015)", "[2016]", "[2017]", "[2018]", "2019", "(2020)", "[2021]", "[2022]"), align = c("l", "l", "l", "l", "l", "l", "l", "l", "l", "l")) %>%
#   #row_spec(0, bold = F) |> 
#     # column_spec(3, italic = TRUE) %>%
# kable_styling(full_width = F, bootstrap_options = c("striped", "hover", "condensed", "responsive"), latex_options = c("repeat_header"), repeat_header_text = "\\textit{(continuação)}") 
# 
# 
# tabela_indice_abund_regiao_sudeste

knitr::include_graphics("imagens/cap04/tbl-IA-regiao-climatica-sudeste-amazonica.png")


```


</br>
</br>
</br>

Na região climática norte amazônica.... 

</br>

```{r tab_ind_abund_regiao_norte}
#| label: tbl-ind_abund_regiao_norte
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| fig.align: "center"
#| out.width: '70%'
#| tbl-cap: "Índice de abundância das tribos indicadoras de cada ano da Região Climática Norte Amazônica."


# tab_ind_abund_regiao_norte <- read_csv2("dados/tabelas/borboletas/tab_ind_abund_regiao_norte.csv")
# 
# tabela_indice_abund_regiao_norte <- kbl(tab_ind_abund_regiao_norte,
#              booktabs = TRUE,
#              longtable = TRUE, 
#              caption = " Índice de abundância das tribos indicadoras de cada ano da Região Climática Norte Amazônica. Os valores dos índices estão em referência ao ano anterior. Nos anos em negrito, o esforço amostral foi menor que 1.728 armadilhas/dia e os dados devem ser interpretados com cautela. Nos anos sublinhados nenhuma UC da região foi amostrada. 'NA' indica que a primeira ocorrência apresentou uma abundância < 20 indivíduos no ano e não foi considerada na análise.",
#              col.names = c(" ", "(2014)", "(2015)", "(2016)", "[2017]", "[2018]", "[2019]", "[2020]", "[2021]", "[2022]"), align = c("l", "l", "l", "l", "l", "l", "l", "l", "l", "l")) %>%
#   #row_spec(0, bold = F) |> 
#     # column_spec(3, italic = TRUE) %>%
# kable_styling(full_width = F, bootstrap_options = c("striped", "hover", "condensed", "responsive"), latex_options = c("repeat_header"), repeat_header_text = "\\textit{(continuação)}") 
# 
# 
# tabela_indice_abund_regiao_norte


knitr::include_graphics("imagens/cap04/tbl-IA-regiao-climatica-norte-amazonica.png")

```


</br>
</br>
</br>

No cerrado.... 

</br>

```{r tab_ind_abund_cerrado}
#| label: tbl-ind_abund_cerrado
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| fig.align: "center"
#| out.width: '70%'
#| tbl-cap: "Índice de abundância das tribos indicadoras de cada ano no Cerrado."


# tab_ind_abund_cerrado <- read_csv2("dados/tabelas/borboletas/tab_ind_abund_cerrado.csv")
# 
# tabela_indice_abund_cerrado <- kbl(tab_ind_abund_cerrado,
#              booktabs = TRUE,
#              longtable = TRUE, 
#              caption = "Índice de abundância das tribos indicadoras de cada ano do Cerrado. Os valores dos índices estão em referência ao ano anterior. Nos anos em negrito, o esforço amostral foi menor que 1.728 armadilhas/dia e os dados devem ser interpretados com cautela. Nos anos sublinhados, nenhuma UC da região foi amostrada. 'NA' indica que a primeira ocorrência apresentou uma abundância < 20 indivíduos e não foi considerada na análise.",
#              col.names = c(" ", "[2014]", "[2015]", "[2016]", "[2017]", "[2018]", "[2019]", "(2020)", "[2021]", "[2022]"), align = c("l", "l", "l", "l", "l", "l", "l", "l", "l", "l")) %>%
#   #row_spec(0, bold = F) |> 
#     # column_spec(3, italic = TRUE) %>%
# kable_styling(full_width = F, bootstrap_options = c("striped", "hover", "condensed", "responsive"), latex_options = c("repeat_header"), repeat_header_text = "\\textit{(continuação)}") 
# 
# 
# tabela_indice_abund_cerrado

knitr::include_graphics("imagens/cap04/tbl-IA-cerrado.png")


```


</br>
</br>
</br>

Na Mata Atlântica.... 

</br>

```{r tab_ind_abund_mata_atlantica}
#| label: tbl-ind_abund_mata_atlantica
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| fig.align: "center"
#| out.width: '70%'
#| tbl-cap: "Índice de abundância das tribos indicadoras de cada ano na Mata Atlântica."


# tab_ind_abund_mata_atlantica <- read_csv2("dados/tabelas/borboletas/tab_ind_abund_mata_atlantica.csv")
# 
# tabela_indice_abund_mata_atlantica <- kbl(tab_ind_abund_mata_atlantica,
#              booktabs = TRUE,
#              longtable = TRUE, 
#              caption = "Índice de abundância das tribos indicadoras de cada ano da Mata Atlântica. Os valores dos índices estão em referência ao ano anterior. Nos anos em negrito, o esforço amostral foi menor que 1.728 armadilhas/dia e os dados devem ser interpretados com cautela. Nos anos sublinhados nenhuma UC da região foi amostrada. 'NA' indica que a primeira ocorrência apresentou uma abundância < 20 indivíduos e não foi considerada na análise.",
#              col.names = c(" ", "(2014)", "[2015]", "[2016]", "[2017]", "[2018]", "[2019]", "(2020)", "[2021]", "[2022]"), align = c("l", "l", "l", "l", "l", "l", "l", "l", "l", "l")) %>%
#   #row_spec(0, bold = F) |> 
#     # column_spec(3, italic = TRUE) %>%
# kable_styling(full_width = F, bootstrap_options = c("striped", "hover", "condensed", "responsive"), latex_options = c("repeat_header"), repeat_header_text = "\\textit{(continuação)}") 
# 
# 
# tabela_indice_abund_mata_atlantica

knitr::include_graphics("imagens/cap04/tbl-IA-mata-atlantica.png")


```


</br>
</br>
</br>


De forma geral, qualquer variação na quantidade de borboletas capturadas causou grandes variações no índice de abundância. Portanto, concluímos que o uso desse índice para “populações” pequenas não é aconselhável. Cabe avaliar se, com o aumento no esforço amostral e uma suposta ampliação na quantidade de dados acumulados, com reflexos no tamanho das populações analisadas, o método nos permitirá discriminar variações biologicamente significativas, associadas a algum tipo de alteração ambiental, de meras pequenas oscilações naturais casuais e erráticas nessas populações. 

</br>


```{r graficos IA-regiões_climaticas_amazonia_calculos}
#| label: fig-IA-regioes-climaticas-amazonia_calculos
#| echo: false
#| message: false
#| warning: false
#| include: false
#| cache: true


##### Índices de abundância de tribos ao longo dos anos - Cinco regiões Amazônicas 
##Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)
library(ggplot2)

#########################################################
######### Região Central Amazônica
#########################################################

# # Definir o diretório de trabalho
#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
df_indice <-read.csv("dados/borboletas/resultado_final_com_esforco.csv", header=T, sep = ';')
df_indice <- df_indice[!is.na(df_indice$tribo), ]

dados_regiao_especifica <- df_indice %>%
  filter(bioma == "Amazonia", regiao == "central")

# Agregar soma_individuos por tribo e ano
soma_individuos_por_tribo_ano <- dados_regiao_especifica %>%
  group_by(tribo, ano) %>%
  summarize(soma_individuos = sum(soma_individuos, na.rm = TRUE)) %>%
  ungroup()

# Verificar o esforço individual por uc_ea e expedicao
esforco_individual <- dados_regiao_especifica %>%
  group_by(uc, uc_ea, ano, expedicao) %>%
  summarize(esforco_individual = unique(esforco_amostral), na.rm = TRUE) %>%
  ungroup()

# Somar os esforços por expedicao
esforco_por_expedicao <- esforco_individual %>%
  group_by(uc, ano, expedicao) %>%
  summarize(esforco_total_expedicao = sum(esforco_individual, na.rm = TRUE)) %>%
  ungroup()

# Calcular o esforço total anual para cada ano
esforco_total_anual <- esforco_por_expedicao %>%
  group_by(ano) %>%
  summarize(esforco_total_anual = sum(esforco_total_expedicao, na.rm = TRUE)) %>%
  ungroup()

# Juntar com soma_individuos_por_tribo_ano
df_agregado <- soma_individuos_por_tribo_ano %>%
  left_join(esforco_total_anual, by = "ano") %>%
  ungroup()

# Somando os grupos de borboletas_fechadas
borboletas_fechadas <- df_agregado %>%
  filter(tribo %in% c('Brassolini', 'Morphini', 'Haeterini')) %>%
  group_by(ano) %>%
  summarise(soma_individuos = sum(soma_individuos)) %>%
  ungroup() %>%
  mutate(tribo = 'Borboletas_fechadas') %>%
  left_join(df_agregado %>% filter(tribo %in% c('Brassolini', 'Morphini', 'Haeterini')) %>% select(ano, esforco_total_anual) %>% distinct(), by = "ano")

# Somando os grupos de borboletas_abertas
borboletas_abertas <- df_agregado %>%
  filter(tribo %in% c('Ageroniini', 'Callicorini', 'Biblidini')) %>%
  group_by(ano) %>%
  summarise(soma_individuos = sum(soma_individuos)) %>%
  ungroup() %>%
  mutate(tribo = 'Borboletas_abertas') %>%
  left_join(df_agregado %>% filter(tribo %in% c('Ageroniini', 'Callicorini', 'Biblidini')) %>% select(ano, esforco_total_anual) %>% distinct(), by = "ano")

# Adicionando as linhas de Borboletas_fechadas ao dataframe original
df_agregado <- bind_rows(df_agregado, borboletas_fechadas)

# Adicionando as linhas de Borboletas_abertas ao dataframe original
df_agregado <- bind_rows(df_agregado, borboletas_abertas)

#################################
# Calcular o índice de abundância referente ao ano anterior
df_agregado_1 <- df_agregado %>%
  group_by(tribo) %>%
  arrange(tribo, ano) %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         # log_frequencia_corrigida = log10(frequencia_corrigida),
         primeira_ocorrencia = which(soma_individuos >= 20)[1],
         indice_abundancia = if_else(row_number() == primeira_ocorrencia, 1,
                                     if_else(row_number() < primeira_ocorrencia, NA_real_,
                                             log10(frequencia_corrigida /lag(frequencia_corrigida))+1))) %>%
  ungroup() %>%
  select(-primeira_ocorrencia)

#Tabela completa
#write.table(df_agregado_1, "df_completo_central_ano_anterior.txt", sep = "\t", row.names = FALSE)

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado_1 %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo
df_tribo_ano_largo <- df_agregado_1 %>%
  select(tribo, ano, indice_abundancia) %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))

#Tabela de índices de abundancia para o relatório
tab_boneco_central <- df_agregado_1 %>%
  filter(!(row_number() %in% 28:45))

df_tribo_ano_largo_tab <- tab_boneco_central %>%
  select(tribo, ano, indice_abundancia) %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

df_tribo_ano_largo_tab <- df_tribo_ano_largo_tab %>%
  mutate_if(is.numeric, ~ round(., 3))

#Salvar
#write.table(df_tribo_ano_largo_tab, "indice_abundancia_central_ano_anterior.txt", sep = "\t", row.names = FALSE)

# Filtrar as linhas desejadas - borboletas indicadoras
df_tribo_ano_largo_filtrado <- df_tribo_ano_largo %>%
  filter(row_number() %in% c(4, 5))

df_tribo_ano_largo_filtrado <- df_tribo_ano_largo_filtrado %>%
  mutate(tribo = ifelse(row_number() == 1, "Borboletas de florestas abertas/perturbadas",
                        ifelse(row_number() == 2, "Borboletas de florestas fechadas/preservadas", tribo)))

## Tabela para colocar no relatório (índice referente aos valores do ano anterior)
#write.table(df_tribo_ano_largo_filtrado, "indice_abundancia_central_tab_indicadoras_ano_anterior.txt", sep = "\t", row.names = FALSE)

##################################
# Calcular o índice de abundância referente ao ano de primeira ocorrencia
df_agregado_2 <- df_agregado %>%
  group_by(tribo) %>%
  arrange(tribo, ano) %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         #log_frequencia_corrigida = log10(frequencia_corrigida),
         primeira_ocorrencia = which(soma_individuos >= 20)[1],
         indice_abundancia = if_else(row_number() == primeira_ocorrencia, 1,
                                     if_else(row_number() < primeira_ocorrencia, NA_real_,
                                             log10(frequencia_corrigida / frequencia_corrigida[primeira_ocorrencia])+1))) %>%
ungroup() %>%
select(-primeira_ocorrencia)

#Tabela completa
#write.table(df_agregado_2, "df_completo_central_primeiro_ano.txt", sep = "\t", row.names = FALSE)

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado_2 %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo
df_tribo_ano_largo <- df_agregado_2 %>%
  select(tribo, ano, indice_abundancia) %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))

# Salvar
#write.table(df_tribo_ano_largo, "indice_abundancia_central_primeiro_ano.txt", sep = "\t", row.names = FALSE)

########################
####### Gráfico #######

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Borboletas_fechadas" = "#23867E", "Borboletas_abertas" = "#CFA154")
tipos_linhas <- c("Borboletas_fechadas" = "solid","Borboletas_abertas" = "dashed")

dados_longos <- df_agregado_2 %>%
  filter(tribo %in% c('Borboletas_fechadas', 'Borboletas_abertas'))

# Criar uma sequência completa de anos
anos_completos <- factor(seq(min(dados_longos$ano), max(dados_longos$ano)))

# Grafico - referente ao primeiro ano de ocorrencia
gg_grafico_primeira_ocorrencia_central <- ggplot(dados_longos, aes(x = as.factor(ano), y = indice_abundancia, color = tribo, linetype = tribo)) +
  geom_line(aes(group = tribo), size = 1) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "black", size = 0.5) +
  scale_color_manual(values = cores_linhas, labels = c("Borboletas_fechadas" = "Borboletas de áreas florestais fechadas/preservadas",
                                                       "Borboletas_abertas" = "Borboletas de áreas florestais abertas/perturbadas")) +
  scale_linetype_manual(values = tipos_linhas, labels = c("Borboletas_fechadas" = "Borboletas de áreas florestais fechadas/preservadas",
                                                          "Borboletas_abertas" = "Borboletas de áreas florestais abertas/perturbadas")) +
  theme_minimal() +
  labs(title = "Região Climática Central Amazônica",
       x = "",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = NULL,
       linetype = NULL) +
  theme(plot.title = element_text(hjust = 0.5, size = 20),
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 14),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 12),
        axis.line = element_line(color = "black"),
        axis.line.x = element_blank(),
        legend.position = "bottom",
        axis.text.x = element_text(hjust = 0.5)) +
  scale_x_discrete(labels = as.character(anos_completos))+
  coord_cartesian(ylim = c(0, 2))

# Exibir o gráfico
print(gg_grafico_primeira_ocorrencia_central)

# Salvar o gráfico em formato PNG
#ggsave("indice_abundancia_central.png",
 #      gg_grafico_primeira_ocorrencia_central,
  #     width = 12,
   #    height = 10,
    #   units = "in")


#########################################################
######### Região Sudoeste Amazônica
#########################################################

# Definir o diretório de trabalho
# setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
df_indice<-read.csv("dados/borboletas/resultado_final_com_esforco.csv", header=T, sep = ';')
df_indice <- df_indice[!is.na(df_indice$tribo), ]

dados_regiao_especifica <- df_indice %>%
  filter(bioma == "Amazonia", regiao == "sudoeste")

# Agregar soma_individuos por tribo e ano
soma_individuos_por_tribo_ano <- dados_regiao_especifica %>%
  group_by(tribo, ano) %>%
  summarize(soma_individuos = sum(soma_individuos, na.rm = TRUE)) %>%
  ungroup()

# Verificar o esforço individual por uc_ea e expedicao
esforco_individual <- dados_regiao_especifica %>%
  group_by(uc, uc_ea, ano, expedicao) %>%
  summarize(esforco_individual = unique(esforco_amostral), na.rm = TRUE) %>%
  ungroup()

# Somar os esforços por expedicao
esforco_por_expedicao <- esforco_individual %>%
  group_by(uc, ano, expedicao) %>%
  summarize(esforco_total_expedicao = sum(esforco_individual, na.rm = TRUE)) %>%
  ungroup()

# Calcular o esforço total anual para cada ano
esforco_total_anual <- esforco_por_expedicao %>%
  group_by(ano) %>%
  summarize(esforco_total_anual = sum(esforco_total_expedicao, na.rm = TRUE)) %>%
  ungroup()

# Juntar com soma_individuos_por_tribo_ano
df_agregado <- soma_individuos_por_tribo_ano %>%
  left_join(esforco_total_anual, by = "ano") %>%
  ungroup()

# Somando os grupos de borboletas_fechadas
borboletas_fechadas <- df_agregado %>%
  filter(tribo %in% c('Brassolini', 'Morphini', 'Haeterini')) %>%
  group_by(ano) %>%
  summarise(soma_individuos = sum(soma_individuos)) %>%
  ungroup() %>%
  mutate(tribo = 'Borboletas_fechadas') %>%
  left_join(df_agregado %>% filter(tribo %in% c('Brassolini', 'Morphini', 'Haeterini')) %>% select(ano, esforco_total_anual) %>% distinct(), by = "ano")

# Somando os grupos de borboletas_abertas
borboletas_abertas <- df_agregado %>%
  filter(tribo %in% c('Ageroniini', 'Callicorini', 'Biblidini')) %>%
  group_by(ano) %>%
  summarise(soma_individuos = sum(soma_individuos)) %>%
  ungroup() %>%
  mutate(tribo = 'Borboletas_abertas') %>%
  left_join(df_agregado %>% filter(tribo %in% c('Ageroniini', 'Callicorini', 'Biblidini')) %>% select(ano, esforco_total_anual) %>% distinct(), by = "ano")

# Adicionando as linhas de Borboletas_fechadas ao dataframe original
df_agregado <- bind_rows(df_agregado, borboletas_fechadas)

# Adicionando as linhas de Borboletas_abertas ao dataframe original
df_agregado <- bind_rows(df_agregado, borboletas_abertas)

#################################
# Calcular o índice de abundância referente ao ano anterior
df_agregado_3 <- df_agregado %>%
  group_by(tribo) %>%
  arrange(tribo, ano) %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         # log_frequencia_corrigida = log10(frequencia_corrigida),
         primeira_ocorrencia = which(soma_individuos >= 20)[1],
         indice_abundancia = if_else(row_number() == primeira_ocorrencia, 1,
                                     if_else(row_number() < primeira_ocorrencia, NA_real_,
                                             log10(frequencia_corrigida /lag(frequencia_corrigida))+1))) %>%
  ungroup() %>%
  select(-primeira_ocorrencia)

#Tabela completa
#write.table(df_agregado_3, "df_completo_sudoeste_ano_anterior.txt", sep = "\t", row.names = FALSE)

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado_3 %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo # tabela geral dos índices
df_tribo_ano_largo <- df_agregado_3 %>%
  select(tribo, ano, indice_abundancia) %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))

#Tabela de índices de abundancia para o relatório
tab_boneco_sudoeste <- df_agregado_3 %>%
  filter(!(row_number() %in% 28:45))

df_tribo_ano_largo_tab <- tab_boneco_sudoeste %>%
  select(tribo, ano, indice_abundancia) %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

df_tribo_ano_largo_tab <- df_tribo_ano_largo_tab %>%
  mutate_if(is.numeric, ~ round(., 3))

#Salvar
#write.table(df_tribo_ano_largo_tab, "indice_abundancia_sudoeste_ano_anterior.txt", sep = "\t", row.names = FALSE)

# Filtrar as linhas desejadas - borboletas indicadoras
df_tribo_ano_largo_filtrado <- df_tribo_ano_largo %>%
  filter(row_number() %in% c(4, 5))

df_tribo_ano_largo_filtrado <- df_tribo_ano_largo_filtrado %>%
  mutate(tribo = ifelse(row_number() == 1, "Borboletas de florestas abertas/perturbadas",
                        ifelse(row_number() == 2, "Borboletas de florestas fechadas/preservadas", tribo)))

# Tabela para colocar no relatório (índice referente aos valores do ano anterior)
#write.table(df_tribo_ano_largo_filtrado, "indice_abundancia_sudoeste_tab_indicadoras_ano_anterior.txt", sep = "\t", row.names = FALSE)

#################################
# Calcular o índice de abundância referente ao ano de primeira ocorrencia
df_agregado_4 <- df_agregado %>%
  group_by(tribo) %>%
  arrange(tribo, ano) %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         #log_frequencia_corrigida = log10(frequencia_corrigida),
         primeira_ocorrencia = which(soma_individuos >= 20)[1],
         indice_abundancia = if_else(row_number() == primeira_ocorrencia, 1,
                                     if_else(row_number() < primeira_ocorrencia, NA_real_,
                                             log10(frequencia_corrigida / frequencia_corrigida[primeira_ocorrencia])+1))) %>%
  ungroup() %>%
  select(-primeira_ocorrencia)

#Tabela completa
#write.table(df_agregado_4, "df_completo_sudoeste_primeiro_ano.txt", sep = "\t", row.names = FALSE)

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado_4 %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo
df_tribo_ano_largo <- df_agregado_4 %>%
  select(tribo, ano, indice_abundancia) %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))

# Salvar
#write.table(df_tribo_ano_largo, "indice_abundancia_sudoeste_primeiro_ano.txt", sep = "\t", row.names = FALSE)

########################
####### Gráfico #######

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Borboletas_fechadas" = "#23867E", "Borboletas_abertas" = "#CFA154")
tipos_linhas <- c("Borboletas_fechadas" = "solid","Borboletas_abertas" = "dashed")

dados_longos <- df_agregado_4 %>%
  filter(tribo %in% c('Borboletas_fechadas', 'Borboletas_abertas'))

# Criar uma sequência completa de anos
anos_completos <- factor(seq(min(dados_longos$ano), max(dados_longos$ano)))

# Criar o gráfico com duas linhas
gg_grafico_primeira_ocorrencia_sudoeste <- ggplot(dados_longos, aes(x = as.factor(ano), y = indice_abundancia, color = tribo, linetype = tribo)) +
  geom_line(aes(group = tribo), size = 1) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "black", size = 0.5) +
  scale_color_manual(values = cores_linhas, labels = c("Borboletas_fechadas" = "Borboletas de áreas florestais fechadas/preservadas",
                                                       "Borboletas_abertas" = "Borboletas de áreas florestais abertas/perturbadas")) +
  scale_linetype_manual(values = tipos_linhas, labels = c("Borboletas_fechadas" = "Borboletas de áreas florestais fechadas/preservadas",
                                                          "Borboletas_abertas" = "Borboletas de áreas florestais abertas/perturbadas")) +
  theme_minimal() +
  labs(title = "Região Climática Sudoeste Amazônica",
       x = "",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = NULL,
       linetype = NULL) +
  theme(plot.title = element_text(hjust = 0.5, size = 20),
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 14),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 12),
        axis.line = element_line(color = "black"),
        axis.line.x = element_blank(),
        legend.position = "bottom",
        axis.text.x = element_text(hjust = 0.5)) +
  scale_x_discrete(labels = as.character(anos_completos))+
  coord_cartesian(ylim = c(0, 2))

# Exibir o gráfico
print(gg_grafico_primeira_ocorrencia_sudoeste)

# Salvar o gráfico em formato PNG
#ggsave("indice_abundancia_sudoeste.png",
 #      gg_grafico_primeira_ocorrencia_sudoeste,
  #     width = 12,
   #    height = 10,
    #   units = "in")

#########################################################
######### Região Leste Amazônica
#########################################################

# Definir o diretório de trabalho
#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
df_indice<-read.csv("dados/borboletas/resultado_final_com_esforco.csv", header=T, sep = ';')
df_indice <- df_indice[!is.na(df_indice$tribo), ]

dados_regiao_especifica <- df_indice %>%
  filter(bioma == "Amazonia", regiao == "leste")

# Agregar soma_individuos por tribo e ano
soma_individuos_por_tribo_ano <- dados_regiao_especifica %>%
  group_by(tribo, ano) %>%
  summarize(soma_individuos = sum(soma_individuos, na.rm = TRUE)) %>%
  ungroup()

# Verificar o esforço individual por uc_ea e expedicao
esforco_individual <- dados_regiao_especifica %>%
  group_by(uc, uc_ea, ano, expedicao) %>%
  summarize(esforco_individual = unique(esforco_amostral), na.rm = TRUE) %>%
  ungroup()

# Somar os esforços por expedicao
esforco_por_expedicao <- esforco_individual %>%
  group_by(uc, ano, expedicao) %>%
  summarize(esforco_total_expedicao = sum(esforco_individual, na.rm = TRUE)) %>%
  ungroup()

# Calcular o esforço total anual para cada ano
esforco_total_anual <- esforco_por_expedicao %>%
  group_by(ano) %>%
  summarize(esforco_total_anual = sum(esforco_total_expedicao, na.rm = TRUE)) %>%
  ungroup()

# Juntar com soma_individuos_por_tribo_ano
df_agregado <- soma_individuos_por_tribo_ano %>%
  left_join(esforco_total_anual, by = "ano") %>%
  ungroup()

# Somando os grupos de borboletas_fechadas
borboletas_fechadas <- df_agregado %>%
  filter(tribo %in% c('Brassolini', 'Morphini', 'Haeterini')) %>%
  group_by(ano) %>%
  summarise(soma_individuos = sum(soma_individuos)) %>%
  ungroup() %>%
  mutate(tribo = 'Borboletas_fechadas') %>%
  left_join(df_agregado %>% filter(tribo %in% c('Brassolini', 'Morphini', 'Haeterini')) %>% select(ano, esforco_total_anual) %>% distinct(), by = "ano")

# Somando os grupos de borboletas_abertas
borboletas_abertas <- df_agregado %>%
  filter(tribo %in% c('Ageroniini', 'Callicorini', 'Biblidini')) %>%
  group_by(ano) %>%
  summarise(soma_individuos = sum(soma_individuos)) %>%
  ungroup() %>%
  mutate(tribo = 'Borboletas_abertas') %>%
  left_join(df_agregado %>% filter(tribo %in% c('Ageroniini', 'Callicorini', 'Biblidini')) %>% select(ano, esforco_total_anual) %>% distinct(), by = "ano")

# Adicionando as linhas de Borboletas_fechadas ao dataframe original
df_agregado <- bind_rows(df_agregado, borboletas_fechadas)

# Adicionando as linhas de Borboletas_abertas ao dataframe original
df_agregado <- bind_rows(df_agregado, borboletas_abertas)

#################################
# Calcular o índice de abundância referente ao ano anterior
df_agregado_5 <- df_agregado %>%
  group_by(tribo) %>%
  arrange(tribo, ano) %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         # log_frequencia_corrigida = log10(frequencia_corrigida),
         primeira_ocorrencia = which(soma_individuos >= 20)[1],
         indice_abundancia = if_else(row_number() == primeira_ocorrencia, 1,
                                     if_else(row_number() < primeira_ocorrencia, NA_real_,
                                             log10(frequencia_corrigida /lag(frequencia_corrigida))+1))) %>%
  ungroup() %>%
  select(-primeira_ocorrencia)

#Tabela completa
#write.table(df_agregado_5, "df_completo_leste_ano_anterior.txt", sep = "\t", row.names = FALSE)

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado_5 %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo # tabela geral dos índices
df_tribo_ano_largo <- df_agregado_5 %>%
  select(tribo, ano, indice_abundancia) %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))

#Tabela de índices de abundancia para o relatório
tab_boneco_leste <- df_agregado_5 %>%
  filter(!(row_number() %in% 28:45))

df_tribo_ano_largo_tab <- tab_boneco_leste %>%
  select(tribo, ano, indice_abundancia) %>% # Selecionar as colunas relevantes
  pivot_wider(names_from = ano, values_from = indice_abundancia)

df_tribo_ano_largo_tab <- df_tribo_ano_largo_tab %>%
  mutate_if(is.numeric, ~ round(., 3))

#Salvar
#write.table(df_tribo_ano_largo_tab, "indice_abundancia_leste_ano_anterior.txt", sep = "\t", row.names = FALSE)

# Filtrar as linhas desejadas
df_tribo_ano_largo_filtrado <- df_tribo_ano_largo %>%
  filter(row_number() %in% c(4, 5))

df_tribo_ano_largo_filtrado <- df_tribo_ano_largo_filtrado %>%
  mutate(tribo = ifelse(row_number() == 1, "Borboletas de florestas abertas/perturbadas",
                        ifelse(row_number() == 2, "Borboletas de florestas fechadas/preservadas", tribo)))

## Tabela para colocar no relatório (índice referente aos valores do ano anterior)
#write.table(df_tribo_ano_largo_filtrado, "indice_abundancia_leste_tab_indicadoras_ano_anterior.txt", sep = "\t", row.names = FALSE)

#################################
# Calcular o índice de abundância referente ao ano de primeira ocorrencia
df_agregado_6 <- df_agregado %>%
  group_by(tribo) %>%
  arrange(tribo, ano) %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         #log_frequencia_corrigida = log10(frequencia_corrigida),
         primeira_ocorrencia = which(soma_individuos >= 20)[1],
         indice_abundancia = if_else(row_number() == primeira_ocorrencia, 1,
                                     if_else(row_number() < primeira_ocorrencia, NA_real_,
                                             log10(frequencia_corrigida / frequencia_corrigida[primeira_ocorrencia])+1))) %>%
  ungroup() %>%
  select(-primeira_ocorrencia)

#Tabela completa
#write.table(df_agregado_6, "df_completo_leste_primeiro_ano.txt", sep = "\t", row.names = FALSE)

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado_6 %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo
df_tribo_ano_largo <- df_agregado_6 %>%
  select(tribo, ano, indice_abundancia) %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))

# Salvar
#write.table(df_tribo_ano_largo, "indice_abundancia_leste_primeiro_ano.txt", sep = "\t", row.names = FALSE)

########################
####### Gráfico #######

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Borboletas_fechadas" = "#23867E", "Borboletas_abertas" = "#CFA154")
tipos_linhas <- c("Borboletas_fechadas" = "solid","Borboletas_abertas" = "dashed")

dados_longos <- df_agregado_6 %>%
  filter(tribo %in% c('Borboletas_fechadas', 'Borboletas_abertas'))

# Criar uma sequência completa de anos, incluindo os anos sem dados (2014, 2015, 2020)
anos_completos <- factor(c(2014:2022, max(dados_longos$ano)))

dados_longos <- dados_longos %>%
  bind_rows(data.frame(tribo = rep(unique(dados_longos$tribo), 2),
                       ano = rep(c(2014, 2015), each = length(unique(dados_longos$tribo))),
                       indice_abundancia = NA))

# Grafico - referente ao primeiro ano de ocorrencia
gg_grafico_primeira_ocorrencia_leste <- ggplot(dados_longos, aes(x = as.factor(ano), y = indice_abundancia, color = tribo, linetype = tribo)) +
  geom_line(aes(group = tribo), size = 1) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "black", size = 0.5) +
  scale_color_manual(values = cores_linhas, labels = c("Borboletas_fechadas" = "Borboletas de áreas florestais fechadas/preservadas",
                                                       "Borboletas_abertas" = "Borboletas de áreas florestais abertas/perturbadas")) +
  scale_linetype_manual(values = tipos_linhas, labels = c("Borboletas_fechadas" = "Borboletas de áreas florestais fechadas/preservadas",
                                                          "Borboletas_abertas" = "Borboletas de áreas florestais abertas/perturbadas")) +
  theme_minimal() +
  labs(title = "Região Climática Leste Amazônica",
       x = "",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = NULL,
       linetype = NULL) +
  theme(plot.title = element_text(hjust = 0.5, size = 20),
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 14),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 12),
        axis.line = element_line(color = "black"),
        axis.line.x = element_blank(),
        legend.position = "bottom",
        axis.text.x = element_text(hjust = 0.5)) +
  scale_x_discrete(labels = as.character(anos_completos))+
  coord_cartesian(ylim = c(0, 2))

print(gg_grafico_primeira_ocorrencia_leste)

# Salvar o gráfico em formato PNG
#ggsave("indice_abundancia_leste.png",
 #      gg_grafico_primeira_ocorrencia_leste,
  #     width = 12,
   #    height = 10,
    #   units = "in")

#########################################################
######### Região Sudeste Amazônica
#########################################################

#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
df_indice<-read.csv("dados/borboletas/resultado_final_com_esforco.csv", header=T, sep = ';')
df_indice <- df_indice[!is.na(df_indice$tribo), ]

dados_regiao_especifica <- df_indice %>%
  filter(bioma == "Amazonia", regiao == "sudeste")

# Agregar soma_individuos por tribo e ano
soma_individuos_por_tribo_ano <- dados_regiao_especifica %>%
  group_by(tribo, ano) %>%
  summarize(soma_individuos = sum(soma_individuos, na.rm = TRUE)) %>%
  ungroup()

# Verificar o esforço individual por uc_ea e expedicao
esforco_individual <- dados_regiao_especifica %>%
  group_by(uc, uc_ea, ano, expedicao) %>%
  summarize(esforco_individual = unique(esforco_amostral), na.rm = TRUE) %>%
  ungroup()

# Somar os esforços por expedicao
esforco_por_expedicao <- esforco_individual %>%
  group_by(uc, ano, expedicao) %>%
  summarize(esforco_total_expedicao = sum(esforco_individual, na.rm = TRUE)) %>%
  ungroup()

# Calcular o esforço total anual para cada ano
esforco_total_anual <- esforco_por_expedicao %>%
  group_by(ano) %>%
  summarize(esforco_total_anual = sum(esforco_total_expedicao, na.rm = TRUE)) %>%
  ungroup()

# Juntar com soma_individuos_por_tribo_ano
df_agregado <- soma_individuos_por_tribo_ano %>%
  left_join(esforco_total_anual, by = "ano") %>%
  ungroup()

# Somando os grupos de borboletas_fechadas
borboletas_fechadas <- df_agregado %>%
  filter(tribo %in% c('Brassolini', 'Morphini', 'Haeterini')) %>%
  group_by(ano) %>%
  summarise(soma_individuos = sum(soma_individuos)) %>%
  ungroup() %>%
  mutate(tribo = 'Borboletas_fechadas') %>%
  left_join(df_agregado %>% filter(tribo %in% c('Brassolini', 'Morphini', 'Haeterini')) %>% select(ano, esforco_total_anual) %>% distinct(), by = "ano")

# Somando os grupos de borboletas_abertas
borboletas_abertas <- df_agregado %>%
  filter(tribo %in% c('Ageroniini', 'Callicorini', 'Biblidini')) %>%
  group_by(ano) %>%
  summarise(soma_individuos = sum(soma_individuos)) %>%
  ungroup() %>%
  mutate(tribo = 'Borboletas_abertas') %>%
  left_join(df_agregado %>% filter(tribo %in% c('Ageroniini', 'Callicorini', 'Biblidini')) %>% select(ano, esforco_total_anual) %>% distinct(), by = "ano")

# Adicionando as linhas de Borboletas_fechadas ao dataframe original
df_agregado <- bind_rows(df_agregado, borboletas_fechadas)

# Adicionando as linhas de Borboletas_abertas ao dataframe original
df_agregado <- bind_rows(df_agregado, borboletas_abertas)

#####################
# Calcular o índice de abundância referente ao ano anterior
df_agregado_7 <- df_agregado %>%
  group_by(tribo) %>%
  arrange(tribo, ano) %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         # log_frequencia_corrigida = log10(frequencia_corrigida),
         primeira_ocorrencia = which(soma_individuos >= 20)[1],
         indice_abundancia = if_else(row_number() == primeira_ocorrencia, 1,
                                     if_else(row_number() < primeira_ocorrencia, NA_real_,
                                             log10(frequencia_corrigida /lag(frequencia_corrigida))+1))) %>%
  ungroup() %>%
  select(-primeira_ocorrencia)

#Tabela completa
#write.table(df_agregado_7, "df_completo_sudeste_ano_anterior.txt", sep = "\t", row.names = FALSE)

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado_7 %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo
df_tribo_ano_largo <- df_agregado_7 %>%
  select(tribo, ano, indice_abundancia) %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))

#Tabela de índices de abundancia para o relatório
tab_boneco_sudeste <- df_agregado_7 %>%
  filter(!(row_number() %in% 28:45))

df_tribo_ano_largo_tab <- tab_boneco_sudeste %>%
  select(tribo, ano, indice_abundancia) %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

df_tribo_ano_largo_tab <- df_tribo_ano_largo_tab %>%
  mutate_if(is.numeric, ~ round(., 3))

#Salvar
#write.table(df_tribo_ano_largo_tab, "indice_abundancia_sudeste_ano_anterior.txt", sep = "\t", row.names = FALSE)

# Filtrar as linhas desejadas
df_tribo_ano_largo_filtrado <- df_tribo_ano_largo %>%
  filter(row_number() %in% c(4, 5))

df_tribo_ano_largo_filtrado <- df_tribo_ano_largo_filtrado %>%
  mutate(tribo = ifelse(row_number() == 1, "Borboletas de florestas abertas/perturbadas",
                        ifelse(row_number() == 2, "Borboletas de florestas fechadas/preservadas", tribo)))

## Tabela para colocar no relatório (índice referente aos valores do ano anterior)
#write.table(df_tribo_ano_largo_filtrado, "indice_abundancia_sudeste_tab_indicadoras_ano_anterior.txt", sep = "\t", row.names = FALSE)

################################
# Calcular o índice de abundância referente ao ano de primeira ocorrencia
df_agregado_8 <- df_agregado %>%
  group_by(tribo) %>%
  arrange(tribo, ano) %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         #log_frequencia_corrigida = log10(frequencia_corrigida),
         primeira_ocorrencia = which(soma_individuos >= 20)[1],
         indice_abundancia = if_else(row_number() == primeira_ocorrencia, 1,
                                     if_else(row_number() < primeira_ocorrencia, NA_real_,
                                             log10(frequencia_corrigida / frequencia_corrigida[primeira_ocorrencia])+1))) %>%
  ungroup() %>%
  select(-primeira_ocorrencia)

#Tabela completa
#write.table(df_agregado_8, "df_completo_sudeste_primeiro_ano.txt", sep = "\t", row.names = FALSE)

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado_8 %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo
df_tribo_ano_largo <- df_agregado_8 %>%
  select(tribo, ano, indice_abundancia) %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))

# Salvar
#write.table(df_tribo_ano_largo, "indice_abundancia_sudeste_primeiro_ano.txt", sep = "\t", row.names = FALSE)

########################
####### Gráfico #######

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Borboletas_fechadas" = "#23867E", "Borboletas_abertas" = "#CFA154")
tipos_linhas <- c("Borboletas_fechadas" = "solid","Borboletas_abertas" = "dashed")

dados_longos <- df_agregado_8 %>%
  filter(tribo %in% c('Borboletas_fechadas', 'Borboletas_abertas'))

# Criar uma sequência completa de anos, incluindo os anos sem dados (2014, 2015, 2020)
anos_completos <- factor(c(2014:2022, max(dados_longos$ano)))

dados_longos <- dados_longos %>%
  bind_rows(data.frame(tribo = rep(unique(dados_longos$tribo), 3),
                       ano = rep(c(2014, 2015, 2020), each = length(unique(dados_longos$tribo))),
                       indice_abundancia = NA))

# Grafico - referente ao primeiro ano de ocorrencia
gg_grafico_primeira_ocorrencia_sudeste <- ggplot(dados_longos, aes(x = as.factor(ano), y = indice_abundancia, color = tribo, linetype = tribo)) +
  geom_line(aes(group = tribo), size = 1) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "black", size = 0.5) +
  geom_point(data = filter(dados_longos, tribo == "Borboletas_abertas" & ano == 2019), aes(x = as.factor(ano), y = indice_abundancia), color = "#CFA154", size = 3) +
  scale_color_manual(values = cores_linhas, labels = c("Borboletas_fechadas" = "Borboletas de áreas florestais fechadas/preservadas",
                                                       "Borboletas_abertas" = "Borboletas de áreas florestais abertas/perturbadas")) +
  scale_linetype_manual(values = tipos_linhas, labels = c("Borboletas_fechadas" = "Borboletas de áreas florestais fechadas/preservadas",
                                                          "Borboletas_abertas" = "Borboletas de áreas florestais abertas/perturbadas")) +
  theme_minimal() +
  labs(title = "Região Climática Sudeste Amazônica",
       x = "",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = NULL,
       linetype = NULL) +
  theme(plot.title = element_text(hjust = 0.5, size = 20),
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 14),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 12),
        axis.line = element_line(color = "black"),
        axis.line.x = element_blank(),
        legend.position = "bottom",
        axis.text.x = element_text(hjust = 0.5)) +
  scale_x_discrete(labels = as.character(anos_completos))+
  coord_cartesian(ylim = c(0, 2))

# Exibir o gráfico
print(gg_grafico_primeira_ocorrencia_sudeste)

# Salvar o gráfico em formato PNG
#ggsave("indice_abundancia_sudeste.png",
 #      gg_grafico_primeira_ocorrencia_sudeste,
  #     width = 12,
   #    height = 10,
    #   units = "in")

#########################################################
######### Região Norte Amazônica
#########################################################

# Definir o diretório de trabalho
#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
df_indice<-read.csv("dados/borboletas/resultado_final_com_esforco.csv", header=T, sep = ';')
df_indice <- df_indice[!is.na(df_indice$tribo), ]

dados_regiao_especifica <- df_indice %>%
  filter(bioma == "Amazonia", regiao == "norte")

# Agregar soma_individuos por tribo e ano
soma_individuos_por_tribo_ano <- dados_regiao_especifica %>%
  group_by(tribo, ano) %>%
  summarize(soma_individuos = sum(soma_individuos, na.rm = TRUE)) %>%
  ungroup()

# Verificar o esforço individual por uc_ea e expedicao
esforco_individual <- dados_regiao_especifica %>%
  group_by(uc, uc_ea, ano, expedicao) %>%
  summarize(esforco_individual = unique(esforco_amostral), na.rm = TRUE) %>%
  ungroup()

# Somar os esforços por expedicao
esforco_por_expedicao <- esforco_individual %>%
  group_by(uc, ano, expedicao) %>%
  summarize(esforco_total_expedicao = sum(esforco_individual, na.rm = TRUE)) %>%
  ungroup()

# Calcular o esforço total anual para cada ano
esforco_total_anual <- esforco_por_expedicao %>%
  group_by(ano) %>%
  summarize(esforco_total_anual = sum(esforco_total_expedicao, na.rm = TRUE)) %>%
  ungroup()

# Juntar com soma_individuos_por_tribo_ano
df_agregado <- soma_individuos_por_tribo_ano %>%
  left_join(esforco_total_anual, by = "ano") %>%
  ungroup()

# Somando os grupos de borboletas_fechadas
borboletas_fechadas <- df_agregado %>%
  filter(tribo %in% c('Brassolini', 'Morphini', 'Haeterini')) %>%
  group_by(ano) %>%
  summarise(soma_individuos = sum(soma_individuos)) %>%
  ungroup() %>%
  mutate(tribo = 'Borboletas_fechadas') %>%
  left_join(df_agregado %>% filter(tribo %in% c('Brassolini', 'Morphini', 'Haeterini')) %>% select(ano, esforco_total_anual) %>% distinct(), by = "ano")

# Somando os grupos de borboletas_abertas
borboletas_abertas <- df_agregado %>%
  filter(tribo %in% c('Ageroniini', 'Callicorini', 'Biblidini')) %>%
  group_by(ano) %>%
  summarise(soma_individuos = sum(soma_individuos)) %>%
  ungroup() %>%
  mutate(tribo = 'Borboletas_abertas') %>%
  left_join(df_agregado %>% filter(tribo %in% c('Ageroniini', 'Callicorini', 'Biblidini')) %>% select(ano, esforco_total_anual) %>% distinct(), by = "ano")

# Adicionando as linhas de Borboletas_fechadas ao dataframe original
df_agregado <- bind_rows(df_agregado, borboletas_fechadas)

# Adicionando as linhas de Borboletas_abertas ao dataframe original
df_agregado <- bind_rows(df_agregado, borboletas_abertas)

#################################
# Calcular o índice de abundância referente ao ano anterior
df_agregado_9 <- df_agregado %>%
  group_by(tribo) %>%
  arrange(tribo, ano) %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         # log_frequencia_corrigida = log10(frequencia_corrigida),
         primeira_ocorrencia = which(soma_individuos >= 20)[1],
         indice_abundancia = if_else(row_number() == primeira_ocorrencia, 1,
                                     if_else(row_number() < primeira_ocorrencia, NA_real_,
                                             log10(frequencia_corrigida /lag(frequencia_corrigida))+1))) %>%
  ungroup() %>%
  select(-primeira_ocorrencia)

#Tabela completa
#write.table(df_agregado_9, "df_completo_norte_ano_anterior.txt", sep = "\t", row.names = FALSE)

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado_9 %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo # tabela geral dos índices
df_tribo_ano_largo <- df_agregado_9 %>%
  select(tribo, ano, indice_abundancia) %>% # Selecionar as colunas relevantes
  pivot_wider(names_from = ano, values_from = indice_abundancia) # Transformar para o formato largo

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))

#Tabela de índices de abundancia para o relatório
tab_boneco_norte <- df_agregado_9 %>%
  filter(!(row_number() %in% 28:45))

df_tribo_ano_largo_tab <- tab_boneco_norte %>%
  select(tribo, ano, indice_abundancia) %>% # Selecionar as colunas relevantes
  pivot_wider(names_from = ano, values_from = indice_abundancia)

df_tribo_ano_largo_tab <- df_tribo_ano_largo_tab %>%
  mutate_if(is.numeric, ~ round(., 3))

#Salvar
#write.table(df_tribo_ano_largo_tab, "indice_abundancia_norte_ano_anterior.txt", sep = "\t", row.names = FALSE)

# Filtrar as linhas desejadas
df_tribo_ano_largo_filtrado <- df_tribo_ano_largo %>%
  filter(row_number() %in% c(4, 5))

df_tribo_ano_largo_filtrado <- df_tribo_ano_largo_filtrado %>%
  mutate(tribo = ifelse(row_number() == 1, "Borboletas de florestas abertas/perturbadas",
                        ifelse(row_number() == 2, "Borboletas de florestas fechadas/preservadas", tribo)))

## Tabela para colocar no relatório (índice referente aos valores do ano anterior)
#write.table(df_tribo_ano_largo_filtrado, "indice_abundancia_norte_tab_indicadoras_ano_anterior.txt", sep = "\t", row.names = FALSE)

#################################
# Calcular o índice de abundância referente ao ano de primeira ocorrencia
df_agregado_10 <- df_agregado %>%
  group_by(tribo) %>%
  arrange(tribo, ano) %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         #log_frequencia_corrigida = log10(frequencia_corrigida),
         primeira_ocorrencia = which(soma_individuos >= 20)[1],
         indice_abundancia = if_else(row_number() == primeira_ocorrencia, 1,
                                     if_else(row_number() < primeira_ocorrencia, NA_real_,
                                             log10(frequencia_corrigida / frequencia_corrigida[primeira_ocorrencia])+1))) %>%
  ungroup() %>%
  select(-primeira_ocorrencia)

#Tabela completa
#write.table(df_agregado_10, "df_completo_norte_primeiro_ano.txt", sep = "\t", row.names = FALSE)

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado_10 %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo
df_tribo_ano_largo <- df_agregado_10 %>%
  select(tribo, ano, indice_abundancia) %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))

# Salvar o dataframe em um arquivo de texto
#write.table(df_tribo_ano_largo, "indice_abundancia_norte_primeiro_ano.txt", sep = "\t", row.names = FALSE)

########################
####### Gráfico #######

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Borboletas_fechadas" = "#23867E", "Borboletas_abertas" = "#CFA154")
tipos_linhas <- c("Borboletas_fechadas" = "solid","Borboletas_abertas" = "dashed")

dados_longos <- df_agregado_10 %>%
  filter(tribo %in% c('Borboletas_fechadas', 'Borboletas_abertas'))

# Criar uma sequência completa de anos, incluindo os anos sem dados (2014, 2015)
anos_completos <- factor(c(2014:2022))

dados_longos <- dados_longos %>%
  bind_rows(data.frame(tribo = rep(unique(dados_longos$tribo), 2),
                       ano = rep(c(2014, 2015), each = length(unique(dados_longos$tribo))),
                       indice_abundancia = NA))

# Grafico - referente ao primeiro ano de ocorrencia
gg_grafico_primeira_ocorrencia_norte <- ggplot(dados_longos, aes(x = as.factor(ano), y = indice_abundancia, color = tribo, linetype = tribo)) +
  geom_line(data = subset(dados_longos, ano >= 2018), aes(group = tribo), size = 1) +  #tava dando erro, pois os dados tavam comecando em 2017,mas é para começar em 2018
  geom_hline(yintercept = 1, linetype = "dashed", color = "black", size = 0.5) +
  scale_color_manual(values = cores_linhas, labels = c("Borboletas_fechadas" = "Borboletas de áreas florestais fechadas/preservadas",
                                                       "Borboletas_abertas" = "Borboletas de áreas florestais abertas/perturbadas")) +
  scale_linetype_manual(values = tipos_linhas, labels = c("Borboletas_fechadas" = "Borboletas de áreas florestais fechadas/preservadas",
                                                          "Borboletas_abertas" = "Borboletas de áreas florestais abertas/perturbadas")) +
  theme_minimal() +
  labs(title = "Região Climática Norte Amazônica",
       x = "",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = NULL,
       linetype = NULL) +
  theme(plot.title = element_text(hjust = 0.5, size = 20),
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 14),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 12),
        axis.line = element_line(color = "black"),
        axis.line.x = element_blank(),
        legend.position = "bottom",
        axis.text.x = element_text(hjust = 0.5),
        panel.grid.major = element_line(color = "gray80", size = 0.4),
        panel.grid.minor = element_blank()) +
  scale_x_discrete(limits = as.character(2014:2022)) +
  coord_cartesian(ylim = c(0, 2))

# print(gg_grafico_primeira_ocorrencia_norte)

# Salvar o gráfico em formato PNG
#ggsave("indice_abundancia_norte.png",
 #      gg_grafico_primeira_ocorrencia_norte,
  #     width = 12,
   #    height = 10,
    #   units = "in")

##############################################
#### Gráficos combinados
#############################################

library(gridExtra)
indice_abu_amazonia <- grid.arrange(
  gg_grafico_primeira_ocorrencia_central + theme(legend.position = "none",
                                                 axis.text.x = element_blank(),
                                                 axis.title = element_text(size = 14),
                                                 plot.title = element_text(size = 18),
                                                 panel.spacing = unit(0.5, "lines"),
                                                 panel.grid.major = element_line(color = "gray80", size = 0.4),
                                                 axis.ticks.y = element_line(color = "black", size = 0.4)),
  gg_grafico_primeira_ocorrencia_sudoeste + theme(legend.position = "none",
                                                  axis.text.x = element_blank(),
                                                  axis.title = element_text(size = 14),
                                                  plot.title = element_text(size = 18),
                                                  panel.spacing = unit(0.5, "lines"),
                                                  panel.grid.major = element_line(color = "gray80", size = 0.4),
                                                  axis.ticks.y = element_line(color = "black", size = 0.4)),
  gg_grafico_primeira_ocorrencia_leste + theme(legend.position = "none",
                                               axis.text.x = element_blank(),
                                               axis.title = element_text(size = 14),
                                               plot.title = element_text(size = 18),
                                               panel.spacing = unit(0.5, "lines"),
                                               panel.grid.major = element_line(color = "gray80", size = 0.4),
                                               axis.ticks.y = element_line(color = "black", size = 0.4)),
  gg_grafico_primeira_ocorrencia_sudeste + theme(legend.position = "none",
                                                 axis.text.x = element_blank(),
                                                 axis.title = element_text(size = 14),
                                                 plot.title = element_text(size = 18),
                                                 panel.grid.major = element_line(color = "gray80", size = 0.4),
                                                 axis.ticks.y = element_line(color = "black", size = 0.4)),
  gg_grafico_primeira_ocorrencia_norte + theme(legend.position = "bottom",
                                               axis.text.x = element_text(size = 20),
                                               axis.title = element_text(size = 14),
                                               plot.title = element_text(size = 18),
                                               panel.spacing = unit(0.5, "lines"),
                                               panel.grid.major = element_line(color = "gray80", size = 0.4),
                                               axis.ticks.y = element_line(color = "black", size = 0.4),
                                               legend.text = element_text(size = 20)),
  nrow = 5,  heights = c(10, 10, 10, 10, 13)
)

# Remover os painéis menores
indice_abu_amazonia$grobs[[1]]$grobs[[1]]$children[[2]]$children[[2]] <- NULL
indice_abu_amazonia$grobs[[2]]$grobs[[1]]$children[[2]]$children[[2]] <- NULL
indice_abu_amazonia$grobs[[3]]$grobs[[1]]$children[[2]]$children[[2]] <- NULL
indice_abu_amazonia$grobs[[4]]$grobs[[1]]$children[[2]]$children[[2]] <- NULL
indice_abu_amazonia$grobs[[5]]$grobs[[1]]$children[[2]]$children[[2]] <- NULL

# Exibir a imagem
print(indice_abu_amazonia)

# Salvar o gráfico em formato PNG

ggsave("imagens/cap04/indice_abundancia_combinado_amazonia.png",
       indice_abu_amazonia,
       width = 16,
       height = 16,
       units = "in")
```

</br>


```{r grafico IA-regiões_climaticas_amazonia}
#| label: fig-ind-abund-regioes-climaticas-combinado
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras do bioma Amazônico em relação ao primeiro ano de ocorrência. Tribos de borboletas indicadoras de florestas fechadas/preservadas (Brassolini, Morphini e Haeterini) estão somadas e representadas pela linha contínua verde. As tribos de borboletas indicadoras de florestas abertas/perturbadas (Callicorini, Biblidini e Ageroniini) estão somadas e representadas pela linha pontilhada marrom."


knitr::include_graphics("imagens/cap04/indice_abundancia_combinado_amazonia.png")

```
</br>

```{r grafico IA-cerrado-calculos}
#| label: ind-abund-cerrado-calculos
#| echo: false
#| message: false
#| warning: false
#| include: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'


##### Índices de abundância de tribos ao longo dos anos - Cerrado
##Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)

# Definir o diretório de trabalho
# setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
df_indice<-read.csv("dados/borboletas/resultado_final_com_esforco.csv", header=T, sep = ';') 
df_indice <- df_indice[!is.na(df_indice$tribo), ]

dados_regiao_especifica <- df_indice %>%
  filter(bioma == "Cerrado")

# Agregar soma_individuos por tribo e ano
soma_individuos_por_tribo_ano <- dados_regiao_especifica %>%
  group_by(tribo, ano) %>%
  summarize(soma_individuos = sum(soma_individuos, na.rm = TRUE)) %>%
  ungroup()

# Verificar o esforço individual por uc_ea e expedicao
esforco_individual <- dados_regiao_especifica %>%
  group_by(uc, uc_ea, ano, expedicao) %>%
  summarize(esforco_individual = unique(esforco_amostral), na.rm = TRUE) %>%
  ungroup()

# Somar os esforços por expedicao
esforco_por_expedicao <- esforco_individual %>%
  group_by(uc, ano, expedicao) %>%
  summarize(esforco_total_expedicao = sum(esforco_individual, na.rm = TRUE)) %>%
  ungroup()

# Calcular o esforço total anual para cada ano
esforco_total_anual <- esforco_por_expedicao %>%
  group_by(ano) %>%
  summarize(esforco_total_anual = sum(esforco_total_expedicao, na.rm = TRUE)) %>%
  ungroup()

# Juntar com soma_individuos_por_tribo_ano
df_agregado <- soma_individuos_por_tribo_ano %>%
  left_join(esforco_total_anual, by = "ano") %>%
  ungroup()

# Somando os grupos de borboletas_fechadas
borboletas_fechadas <- df_agregado %>%
  filter(tribo %in% c('Brassolini', 'Morphini', 'Haeterini')) %>%
  group_by(ano) %>%
  summarise(soma_individuos = sum(soma_individuos)) %>%
  ungroup() %>%
  mutate(tribo = 'Borboletas_fechadas') %>%
  left_join(df_agregado %>% filter(tribo %in% c('Brassolini', 'Morphini', 'Haeterini')) %>% select(ano, esforco_total_anual) %>% distinct(), by = "ano")

# Somando os grupos de borboletas_abertas
borboletas_abertas <- df_agregado %>%
  filter(tribo %in% c('Ageroniini', 'Callicorini', 'Biblidini')) %>%
  group_by(ano) %>%
  summarise(soma_individuos = sum(soma_individuos)) %>%
  ungroup() %>%
  mutate(tribo = 'Borboletas_abertas') %>%
  left_join(df_agregado %>% filter(tribo %in% c('Ageroniini', 'Callicorini', 'Biblidini')) %>% select(ano, esforco_total_anual) %>% distinct(), by = "ano")

# Adicionando as linhas de Borboletas_fechadas ao dataframe original
df_agregado <- bind_rows(df_agregado, borboletas_fechadas)

# Adicionando as linhas de Borboletas_abertas ao dataframe original
df_agregado <- bind_rows(df_agregado, borboletas_abertas)

#######################
# Calcular o índice de abundância referente ao ano anterior
df_agregado_1 <- df_agregado %>%
  group_by(tribo) %>%
  arrange(tribo, ano) %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         # log_frequencia_corrigida = log10(frequencia_corrigida),
         primeira_ocorrencia = which(soma_individuos >= 20)[1],
         indice_abundancia = if_else(row_number() == primeira_ocorrencia, 1, 
                                     if_else(row_number() < primeira_ocorrencia, NA_real_, 
                                             log10(frequencia_corrigida /lag(frequencia_corrigida))+1))) %>%
  ungroup() %>%
  select(-primeira_ocorrencia)

#Tabela completa
#write.table(df_agregado_1, "df_completo_cerrado_ano_anterior.txt", sep = "\t", row.names = FALSE)

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado_1 %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo
df_tribo_ano_largo <- df_agregado_1 %>%
  select(tribo, ano, indice_abundancia) %>% 
  pivot_wider(names_from = ano, values_from = indice_abundancia) 

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))

#Tabela de índices de abundancia para o relatório
tab_boneco_cerrado <- df_agregado_1 %>%
  filter(!(row_number() %in% 28:45))

df_tribo_ano_largo_tab <- tab_boneco_cerrado %>%
  select(tribo, ano, indice_abundancia) %>% 
  pivot_wider(names_from = ano, values_from = indice_abundancia)

df_tribo_ano_largo_tab <- df_tribo_ano_largo_tab %>%
  mutate_if(is.numeric, ~ round(., 3))

#Salvar
#write.table(df_tribo_ano_largo_tab, "indice_abundancia_cerrado_ano_anterior.txt", sep = "\t", row.names = FALSE)

# Filtrar as linhas desejadas
df_tribo_ano_largo_filtrado <- df_tribo_ano_largo %>%
  filter(row_number() %in% c(4, 5))

df_tribo_ano_largo_filtrado <- df_tribo_ano_largo_filtrado %>%
  mutate(tribo = ifelse(row_number() == 1, "Borboletas de florestas abertas/perturbadas", 
                        ifelse(row_number() == 2, "Borboletas de florestas fechadas/preservadas", tribo)))

## Tabela para colocar no relatório (índice referente aos valores do ano anterior)
#write.table(df_tribo_ano_largo_filtrado, "indice_abundancia_cerrado_tab_indicadoras_ano_anterior.txt", sep = "\t", row.names = FALSE)

######################
# Calcular o índice de abundância referente ao ano de primeira ocorrencia
df_agregado_2 <- df_agregado %>%
  group_by(tribo) %>%
  arrange(tribo, ano) %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         #log_frequencia_corrigida = log10(frequencia_corrigida),
         primeira_ocorrencia = which(soma_individuos >= 20)[1],
         indice_abundancia = if_else(row_number() == primeira_ocorrencia, 1, 
                                     if_else(row_number() < primeira_ocorrencia, NA_real_, 
                                             log10(frequencia_corrigida / frequencia_corrigida[primeira_ocorrencia])+1))) %>%
  ungroup() %>%
  select(-primeira_ocorrencia)

#Tabela completa
#write.table(df_agregado_2, "df_completo_cerrado_primeiro_ano.txt", sep = "\t", row.names = FALSE)

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado_2 %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo
df_tribo_ano_largo <- df_agregado_2 %>%
  select(tribo, ano, indice_abundancia) %>% 
  pivot_wider(names_from = ano, values_from = indice_abundancia) 

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))

# Salvar
#write.table(df_tribo_ano_largo, "indice_abundancia_cerrado_primeiro_ano.txt", sep = "\t", row.names = FALSE)

############
#Gráfico
library(ggplot2)

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Borboletas_fechadas" = "#23867E", "Borboletas_abertas" = "#CFA154")
tipos_linhas <- c("Borboletas_fechadas" = "solid","Borboletas_abertas" = "dashed")

dados_longos <- df_agregado_2 %>%
  filter(tribo %in% c('Borboletas_fechadas', 'Borboletas_abertas'))

# Criar uma sequência completa de anos, incluindo os anos sem dados (2014, 2015, 2020)
anos_completos <- factor(c(2014:2022, max(dados_longos$ano)))

dados_longos <- dados_longos %>%
  bind_rows(data.frame(tribo = rep(unique(dados_longos$tribo), 1),
                       ano = 2020, each = length(unique(dados_longos$tribo)),
                       indice_abundancia = NA))

# Criar uma sequência completa de anos
anos_completos <- factor(seq(min(dados_longos$ano), max(dados_longos$ano)))

# Grafico - referente ao primeiro ano de ocorrencia
gg_grafico_primeira_ocorrencia_cerrado <- ggplot(dados_longos, aes(x = as.factor(ano), y = indice_abundancia, color = tribo, linetype = tribo)) +
  geom_line(aes(group = tribo), size = 1) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "black", size = 0.5) +
  scale_color_manual(values = cores_linhas, labels = c("Borboletas_fechadas" = "Borboletas de áreas florestais fechadas/preservadas",
                                                       "Borboletas_abertas" = "Borboletas de áreas florestais abertas/perturbadas")) +
  scale_linetype_manual(values = tipos_linhas, labels = c("Borboletas_fechadas" = "Borboletas de áreas florestais fechadas/preservadas",
                                                          "Borboletas_abertas" = "Borboletas de áreas florestais abertas/perturbadas")) +
  theme_minimal() +
  labs(title = "Cerrado",
       x = "",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = NULL,
       linetype = NULL) +
  theme(plot.title = element_text(hjust = 0.5, size = 20),
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 16),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 12),
        axis.line = element_line(color = "black"),
        axis.line.x = element_blank(),
        legend.position = "bottom",
        axis.text.x = element_text(hjust = 0.5)) +
  scale_x_discrete(labels = as.character(anos_completos))+
  coord_cartesian(ylim = c(0, 2)) 

# Exibir o gráfico
print(gg_grafico_primeira_ocorrencia_cerrado)

# Salvar o gráfico em formato PNG
ggsave("imagens/cap04/bo-indice-abundancia-cerrado.png",
      gg_grafico_primeira_ocorrencia_cerrado,
     width = 10,
    height = 5, 
   units = "in") 


```

</br>


```{r grafico IA-cerrado}
#| label: fig-ind-abund-cerrado
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras do bioma Cerrado em relação ao primeiro ano de ocorrência. Tribos de borboletas indicadoras de florestas fechadas/preservadas (Brassolini, Morphini e Haeterini) estão somadas e representadas pela linha contínua verde. As tribos de borboletas indicadoras de florestas abertas/perturbadas (Callicorini, Biblidini e Ageroniini) estão somadas e representadas pela linha pontilhada marrom."


knitr::include_graphics("imagens/cap04/bo-indice-abundancia-cerrado.png")

```
</br>

```{r IA-mata-atlantica-calculos}
#| label: ind-abund-mata-atlantica-calculos
#| echo: false
#| message: false
#| warning: false
#| include: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'


##### Índices de abundância de tribos ao longo dos anos - Mata Atlântica
##Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)

# Definir o diretório de trabalho
#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
df_indice<-read.csv("dados/borboletas/resultado_final_com_esforco.csv", header=T, sep = ';') 
df_indice <- df_indice[!is.na(df_indice$tribo), ]

dados_regiao_especifica <- df_indice %>%
  filter(bioma == "Mata_Atlantica")

# Agregar soma_individuos por tribo e ano
soma_individuos_por_tribo_ano <- dados_regiao_especifica %>%
  group_by(tribo, ano) %>%
  summarize(soma_individuos = sum(soma_individuos, na.rm = TRUE)) %>%
  ungroup()

# Verificar o esforço individual por uc_ea e expedicao
esforco_individual <- dados_regiao_especifica %>%
  group_by(uc, uc_ea, ano, expedicao) %>%
  summarize(esforco_individual = unique(esforco_amostral), na.rm = TRUE) %>%
  ungroup()

# Somar os esforços por expedicao
esforco_por_expedicao <- esforco_individual %>%
  group_by(uc, ano, expedicao) %>%
  summarize(esforco_total_expedicao = sum(esforco_individual, na.rm = TRUE)) %>%
  ungroup()

# Calcular o esforço total anual para cada ano
esforco_total_anual <- esforco_por_expedicao %>%
  group_by(ano) %>%
  summarize(esforco_total_anual = sum(esforco_total_expedicao, na.rm = TRUE)) %>%
  ungroup()

# Juntar com soma_individuos_por_tribo_ano
df_agregado <- soma_individuos_por_tribo_ano %>%
  left_join(esforco_total_anual, by = "ano") %>%
  ungroup()

# Somando os grupos de borboletas_fechadas
borboletas_fechadas <- df_agregado %>%
  filter(tribo %in% c('Brassolini', 'Morphini', 'Haeterini')) %>%
  group_by(ano) %>%
  summarise(soma_individuos = sum(soma_individuos)) %>%
  ungroup() %>%
  mutate(tribo = 'Borboletas_fechadas') %>%
  left_join(df_agregado %>% filter(tribo %in% c('Brassolini', 'Morphini', 'Haeterini')) %>% select(ano, esforco_total_anual) %>% distinct(), by = "ano")

# Somando os grupos de borboletas_abertas
borboletas_abertas <- df_agregado %>%
  filter(tribo %in% c('Ageroniini', 'Callicorini', 'Biblidini')) %>%
  group_by(ano) %>%
  summarise(soma_individuos = sum(soma_individuos)) %>%
  ungroup() %>%
  mutate(tribo = 'Borboletas_abertas') %>%
  left_join(df_agregado %>% filter(tribo %in% c('Ageroniini', 'Callicorini', 'Biblidini')) %>% select(ano, esforco_total_anual) %>% distinct(), by = "ano")

# Adicionando as linhas de Borboletas_fechadas ao dataframe original
df_agregado <- bind_rows(df_agregado, borboletas_fechadas)

# Adicionando as linhas de Borboletas_abertas ao dataframe original
df_agregado <- bind_rows(df_agregado, borboletas_abertas)

#######################
# Calcular o índice de abundância referente ao ano anterior
df_agregado_1 <- df_agregado %>%
  group_by(tribo) %>%
  arrange(tribo, ano) %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         # log_frequencia_corrigida = log10(frequencia_corrigida),
         primeira_ocorrencia = which(soma_individuos >= 20)[1],
         indice_abundancia = if_else(row_number() == primeira_ocorrencia, 1, 
                                     if_else(row_number() < primeira_ocorrencia, NA_real_, 
                                             log10(frequencia_corrigida /lag(frequencia_corrigida))+1))) %>%
  ungroup() %>%
  select(-primeira_ocorrencia)

#Tabela completa
#write.table(df_agregado_1, "df_completo_mata_atlantica_ano_anterior.txt", sep = "\t", row.names = FALSE)

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado_1 %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo
df_tribo_ano_largo <- df_agregado_1 %>%
  select(tribo, ano, indice_abundancia) %>% 
  pivot_wider(names_from = ano, values_from = indice_abundancia) 

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))

#Tabela de índices de abundancia para o relatório
tab_boneco_mata_atlantica <- df_agregado_1 %>%
  filter(!(row_number() %in% 28:45))

df_tribo_ano_largo_tab <- tab_boneco_mata_atlantica %>%
  select(tribo, ano, indice_abundancia) %>% 
  pivot_wider(names_from = ano, values_from = indice_abundancia)

df_tribo_ano_largo_tab <- df_tribo_ano_largo_tab %>%
  mutate_if(is.numeric, ~ round(., 3))

#Salvar
#write.table(df_tribo_ano_largo_tab, "indice_abundancia_mata_atlantica_ano_anterior.txt", sep = "\t", row.names = FALSE)

# Filtrar as linhas desejadas
df_tribo_ano_largo_filtrado <- df_tribo_ano_largo %>%
  filter(row_number() %in% c(4, 5))

df_tribo_ano_largo_filtrado <- df_tribo_ano_largo_filtrado %>%
  mutate(tribo = ifelse(row_number() == 1, "Borboletas de florestas abertas/perturbadas", 
                        ifelse(row_number() == 2, "Borboletas de florestas fechadas/preservadas", tribo)))

## Tabela para colocar no relatório (índice referente aos valores do ano anterior)
#write.table(df_tribo_ano_largo_filtrado, "indice_abundancia_mata_atlantica_tab_indicadoras_ano_anterior.txt", sep = "\t", row.names = FALSE)

######################
# Calcular o índice de abundância referente ao ano de primeira ocorrencia
df_agregado_2 <- df_agregado %>%
  group_by(tribo) %>%
  arrange(tribo, ano) %>%
  mutate(frequencia_corrigida = (soma_individuos + 0.00001) / esforco_total_anual,
         #log_frequencia_corrigida = log10(frequencia_corrigida),
         primeira_ocorrencia = which(soma_individuos >= 20)[1],
         indice_abundancia = if_else(row_number() == primeira_ocorrencia, 1, 
                                     if_else(row_number() < primeira_ocorrencia, NA_real_, 
                                             log10(frequencia_corrigida / frequencia_corrigida[primeira_ocorrencia])+1))) %>%
  ungroup() %>%
  select(-primeira_ocorrencia)

#Tabela completa
#write.table(df_agregado_2, "df_completo_mata_atlantica_primeiro_ano.txt", sep = "\t", row.names = FALSE)

# Reestruturar para visualização
df_tribo_ano_largo <- df_agregado_2 %>%
  pivot_wider(names_from = ano, values_from = indice_abundancia)

# Reestruturar o dataframe para o formato largo
df_tribo_ano_largo <- df_agregado_2 %>%
  select(tribo, ano, indice_abundancia) %>% 
  pivot_wider(names_from = ano, values_from = indice_abundancia) 

# Limitar os valores a 3 casas decimais
df_tribo_ano_largo <- df_tribo_ano_largo %>%
  mutate_if(is.numeric, ~ round(., 3))

# Salvar
#write.table(df_tribo_ano_largo, "indice_abundancia_mata_atlantica_primeiro_ano.txt", sep = "\t", row.names = FALSE)

############
#Gráfico
library(ggplot2)

# Definir as cores e tipos de linha para cada tribo
cores_linhas <- c("Borboletas_fechadas" = "#23867E", "Borboletas_abertas" = "#CFA154")
tipos_linhas <- c("Borboletas_fechadas" = "solid","Borboletas_abertas" = "dashed")

dados_longos <- df_agregado_2 %>%
  filter(tribo %in% c('Borboletas_fechadas', 'Borboletas_abertas'))

# Criar uma sequência completa de anos, incluindo os anos sem dados (2014, 2015, 2020)
anos_completos <- factor(c(2014:2022, max(dados_longos$ano)))

dados_longos <- dados_longos %>%
  bind_rows(data.frame(tribo = rep(unique(dados_longos$tribo), 1),
                       ano = 2020, each = length(unique(dados_longos$tribo)),
                       indice_abundancia = NA))

# Criar uma sequência completa de anos
anos_completos <- factor(seq(min(dados_longos$ano), max(dados_longos$ano)))

# Grafico - referente ao primeiro ano de ocorrencia
gg_grafico_primeira_ocorrencia_mata_atlantica <- ggplot(dados_longos, aes(x = as.factor(ano), y = indice_abundancia, color = tribo, linetype = tribo)) +
  geom_line(aes(group = tribo), size = 1) +
  geom_hline(yintercept = 1, linetype = "dashed", color = "black", size = 0.5) +
  scale_color_manual(values = cores_linhas, labels = c("Borboletas_fechadas" = "Borboletas de áreas florestais fechadas/preservadas",
                                                       "Borboletas_abertas" = "Borboletas de áreas florestais abertas/perturbadas")) +
  scale_linetype_manual(values = tipos_linhas, labels = c("Borboletas_fechadas" = "Borboletas de áreas florestais fechadas/preservadas",
                                                          "Borboletas_abertas" = "Borboletas de áreas florestais abertas/perturbadas")) +
  theme_minimal() +
  labs(title = "Mata Atlântica",
       x = "",
       y = expression("Índice de Abundância (" * italic("i") * ")"),
       color = NULL,
       linetype = NULL) +
  theme(plot.title = element_text(hjust = 0.5, size = 20),
        axis.title = element_text(size = 18),
        axis.text = element_text(size = 16),
        legend.title = element_text(size = 16),
        legend.text = element_text(size = 12),
        axis.line = element_line(color = "black"),
        axis.line.x = element_blank(),
        legend.position = "bottom",
        axis.text.x = element_text(hjust = 0.5)) +
  scale_x_discrete(labels = as.character(anos_completos))+
  coord_cartesian(ylim = c(-0.5, 2)) 

# Exibir o gráfico
print(gg_grafico_primeira_ocorrencia_mata_atlantica)

# Salvar o gráfico em formato PNG
ggsave("imagens/cap04/bo-indice-abundancia-mata-atlantica.png",
       gg_grafico_primeira_ocorrencia_mata_atlantica,
       width = 10,
       height = 5, 
       units = "in") 


```

</br>

```{r grafico IA-mata-atlantica}
#| label: fig-ind-abund-mata-atlantica
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'
#| fig-cap: "Variação no índice de abundância das tribos de borboletas frugívoras do bioma Mata Atlântica em relação ao primeiro ano de ocorrência. Tribos de borboletas indicadoras de florestas fechadas/preservadas (Brassolini, Morphini e Haeterini) estão somadas e representadas pela linha contínua verde. As tribos de borboletas indicadoras de florestas abertas/perturbadas (Callicorini, Biblidini e Ageroniini) estão somadas e representadas pela linha pontilhada marrom."


knitr::include_graphics("imagens/cap04/bo-indice-abundancia-mata-atlantica.png")

```


</br>

### Destaques

</br>


#### Efeito da queda dos tabocais nas RESEXs do Cazumbá-Iracema, do Alto Tarauacá, Riozinho da Liberdade e Chico Mendes e no PARNA da Serra do Divisor



</br>


```{r grafico abundancia-resex-cazumba-iracema}
#| label: fig-abundancia-resex-cazumba-iracema
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'


# Análise  de efeito da queda do tabocal nas tribos de borboletas frugívoras - AUTOMATIZADO
# RESEX do Cazumbá-Iracema
# Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)
library(ggplot2)
library(car)

#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")

dados_borboletas <- read.table("dados/borboletas/dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
dados_borboletas$ano <- as.factor(dados_borboletas$ano)
dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]
dados_borboletas <- dados_borboletas[!is.na(dados_borboletas$tribo), ]


dados_regiao_especifica <- dados_borboletas %>%
  filter(uc == 'Resex_do_Cazumba-Iracema')

# Calcular o esforço amostral para cada combinação de uc_ea, expedicao e ano
esforco_por_expedicao <- dados_regiao_especifica %>%
  group_by(uc_ea, uc, expedicao, ano) %>%
  summarize(
    max_dia_amostragem = max(dia_amostragem) - 1,
    .groups = 'drop'
  ) %>%
  mutate(
    esforco_amostral = 16 * max_dia_amostragem
  )

# Agregar o esforço de amostragem para cada uc_ea e ano
esforco_total_por_ea_ano <- esforco_por_expedicao %>%
  group_by(uc_ea, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregar o esforço de amostragem para cada uc e ano
esforco_total_por_uc_ano <- esforco_por_expedicao %>%
  group_by(uc, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregação para obter o esforço total por ano
esforco_por_ano <- esforco_total_por_uc_ano %>%
  group_by(ano,uc) %>%
  summarize(
    esforco = sum(esforco_total_ano),
    .groups = 'drop'
  )

# Agregação para obter o número total de indivíduos por ano
num_ind_por_ano <- dados_regiao_especifica %>%
  group_by(ano) %>%
  summarize(
    num_ind = sum(individuos, na.rm = TRUE),
    .groups = 'drop'
  )

#criando uma coluna de UA e selecionando somente as colunas interessadas pra analise
dados_regiao_especifica <- dados_regiao_especifica %>%
  mutate(ua = paste(uc_ea, transeccao, sep = "_"))

#combinando os dados por UA por ano = 12 (3 ea x 4 parcelas)
df_abu_ano <- dados_regiao_especifica %>%
  group_by(tribo, ua, uc_ea,uc, ano) %>%
  summarise(abundancia = sum(individuos, na.rm = TRUE)) %>%
  ungroup()

# Transforma o df para colocar os zeros
df_tabocal <- df_abu_ano %>%
  spread(key = tribo, value = abundancia, fill = 0)

# Retorna ao formato longo para as análises
df_long <- df_tabocal %>%
  pivot_longer(cols = Ageroniini:Satyrini, names_to = "tribo", values_to = "individuos")

# Agregação para obter a abundância total de cada tribo por ano
abundancia_por_ano <- df_long %>%
  group_by(tribo, ano) %>%
  summarize(
    abundancia_total = sum(individuos)
  )

# Juntar as tabelas pela coluna 'ano' e 'uc'
df_long_com_esforco <- left_join(df_long, esforco_por_ano, by = c("ano", "uc"))


# Calcular a abundância padronizada pelo esforço amostral
df_long <- df_long_com_esforco %>%
  mutate(abundancia_padronizada = (individuos / esforco) * 100)
#

library(tidyverse)

# Realizar análise e gerar gráficos para cada tribo

tribos <- unique(df_long$tribo)

for (tribo_atual in tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
}
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Adicione o ano de 2020, mesmo que não haja dados
  medianas_anuais <- c(medianas_anuais, NA)
  names(medianas_anuais)[length(medianas_anuais)] <- "2020"
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = as.character(unique(c(names(medianas_anuais), "2020"))), MedianaAnual = c(medianas_anuais, NA))
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- c(erros_padrao, NA)
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup)*1.1
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = .7) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "Ano",
         y = "Mediana da Abundância / Esforço Amostral") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5.5),
          axis.text = element_text(size = 6),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Exiba o gráfico ajustado
  print(p_tribo)
  
  # Salvar a imagem usando ggsave()
#   ggsave(filename = paste("mediana_", gsub(" ", "_", tolower(tribo_atual)), "_ajustado_pontos_linha_2020.png", sep = ""),  # Escolha um nome adequado para o arquivo
#          plot = p_tribo,  # O objeto ggplot
#          device = "png",  # Pode ser "jpeg", "tiff", etc.
#          path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Cazumba-Iracema",  # Especifique o diretório onde você deseja salvar o gráfico
#          dpi = 300,  # Define a resolução (DPI)
#          width = 6, height = 5, units = "in")  # Define o tamanho da imagem
# }


library(gridExtra)

# Definir uma lista para armazenar os gráficos
lista_graficos <- list()

# Defina a ordem das tribos
ordem_tribos <- c("Brassolini", "Morphini", "Haeterini", "Preponini", "Melanitini", "Anaeini", 
                  "Epicaliini", "Epiphilini", "Coeini", "Satyrini", "Callicorini", "Biblidini", "Ageroniini")

for (tribo_atual in ordem_tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Adicione o ano de 2020, mesmo que não haja dados
  medianas_anuais <- c(medianas_anuais, NA)
  names(medianas_anuais)[length(medianas_anuais)] <- "2020"
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = as.character(unique(c(names(medianas_anuais), "2020"))), MedianaAnual = c(medianas_anuais, NA))
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- c(erros_padrao, NA)
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup) * 1.1
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "",
         y = "Mediana da Abundância 
 / Esforço Amostral") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5.5),
          axis.text = element_text(size = 6),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Adicionar o gráfico atual à lista
  lista_graficos[[tribo_atual]] <- p_tribo
}



```


```{r grafico abundancia-resex-cazumba-iracema-combinada}
#| label: fig-abundancia-resex-cazumba-iracema-combinada
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '90%'
#| fig-cap: "Variação na abundância das tribos de borboletas frugívoras na RESEX do Cazumbá-Iracema no período de 2020 a 2022. A linha pontilhada vermelha indica a mediana total (e.g., mediana de todos os anos). O asterisco indica que a mediana anual foi significativamente diferente da mediana total, considerando p ≤ 0.01."

# Combine todos os gráficos em uma única imagem
imagem_combinada <- grid.arrange(grobs = lista_graficos, ncol = 3)


# Salvar a imagem combinada usando ggsave()
# ggsave(filename = "todos_graficos_cazumba_iracema.png",  # Escolha um nome adequado para o arquivo
#        plot = imagem_combinada,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Cazumba-Iracema",  # Especifique o diretório onde você deseja salvar a imagem
#        dpi = 300,  # Define a resolução (DPI)
#        width = 14, height = 12, units = "in")  # Define o tamanho da imagem



```


</br>



```{r grafico abundancia-resex-alto-tarauaca}
#| label: fig-abundancia-resex-alto-tarauaca
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'



# Análise  de efeito da queda do tabocal nas tribos de borboletas frugívoras - AUTOMATIZADO
# RESEX do Alto Taraucá
# Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)
library(ggplot2)
library(car)

#setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")

# dados_borboletas <- read.table("dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
# dados_borboletas$ano <- as.factor(dados_borboletas$ano)
# dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]
# dados_borboletas <- dados_borboletas[!is.na(dados_borboletas$tribo), ]


dados_regiao_especifica <- dados_borboletas %>%
  filter(uc == 'Resex_do_Alto_Tarauaca')

# Calcular o esforço amostral para cada combinação de uc_ea, expedicao e ano
esforco_por_expedicao <- dados_regiao_especifica %>%
  group_by(uc_ea, uc, expedicao, ano) %>%
  summarize(
    max_dia_amostragem = max(dia_amostragem) - 1,
    .groups = 'drop'
  ) %>%
  mutate(
    esforco_amostral = 16 * max_dia_amostragem
  )

# Agregar o esforço de amostragem para cada uc_ea e ano
esforco_total_por_ea_ano <- esforco_por_expedicao %>%
  group_by(uc_ea, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregar o esforço de amostragem para cada uc e ano
esforco_total_por_uc_ano <- esforco_por_expedicao %>%
  group_by(uc, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregação para obter o esforço total por ano
esforco_por_ano <- esforco_total_por_uc_ano %>%
  group_by(ano,uc) %>%
  summarize(
    esforco = sum(esforco_total_ano),
    .groups = 'drop'
  )

# Agregação para obter o número total de indivíduos por ano
num_ind_por_ano <- dados_regiao_especifica %>%
  group_by(ano) %>%
  summarize(
    num_ind = sum(individuos, na.rm = TRUE),
    .groups = 'drop'
  )

#criando uma coluna de UA e selecionando somente as colunas interessadas pra analise
dados_regiao_especifica <- dados_regiao_especifica %>%
  mutate(ua = paste(uc_ea, transeccao, sep = "_"))

#combinando os dados por UA por ano = 12 (3 ea x 4 parcelas)
df_abu_ano <- dados_regiao_especifica %>%
  group_by(tribo, ua, uc_ea,uc, ano) %>%
  summarise(abundancia = sum(individuos, na.rm = TRUE)) %>%
  ungroup()

# Transforma o df para colocar os zeros
df_tabocal <- df_abu_ano %>%
  spread(key = tribo, value = abundancia, fill = 0)

# Retorna ao formato longo para as análises
df_long <- df_tabocal %>%
  pivot_longer(cols = Ageroniini:Satyrini, names_to = "tribo", values_to = "individuos")

# Agregação para obter a abundância total de cada tribo por ano
abundancia_por_ano <- df_long %>%
  group_by(tribo, ano) %>%
  summarize(
    abundancia_total = sum(individuos)
  )

# Juntar as tabelas pela coluna 'ano' e 'uc'
df_long_com_esforco <- left_join(df_long, esforco_por_ano, by = c("ano", "uc"))


# Calcular a abundância padronizada pelo esforço amostral
df_long <- df_long_com_esforco %>%
  mutate(abundancia_padronizada = (individuos / esforco) * 100)
#

library(tidyverse)

# Realizar análise e gerar gráficos para cada tribo

tribos <- unique(df_long$tribo)

for (tribo_atual in tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Adicione o ano de 2020, mesmo que não haja dados
  medianas_anuais <- c(medianas_anuais, NA)
  names(medianas_anuais)[length(medianas_anuais)] <- "2020"
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = as.character(unique(c(names(medianas_anuais), "2020"))), MedianaAnual = c(medianas_anuais, NA))
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- c(erros_padrao, NA)
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup)*1.2
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "Ano",
         y = "Mediana da Abundância / Esforço Amostral") +
    theme_minimal() +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Exiba o gráfico ajustado
  print(p_tribo)
  
  # Salvar a imagem usando ggsave()
  ggsave(filename = paste("mediana_", gsub(" ", "_", tolower(tribo_atual)), "_ajustado_pontos_linha_2020.png", sep = ""),  # Escolha um nome adequado para o arquivo
         plot = p_tribo,  # O objeto ggplot
         device = "png",  # Pode ser "jpeg", "tiff", etc.
         path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Alto Tarauaca",  # Especifique o diretório onde você deseja salvar o gráfico
         dpi = 300,  # Define a resolução (DPI)
         width = 6, height = 5, units = "in")  # Define o tamanho da imagem
}


library(gridExtra)

# Definir uma lista para armazenar os gráficos
lista_graficos <- list()

# Defina a ordem das tribos
ordem_tribos <- c("Brassolini", "Morphini", "Haeterini", "Preponini", "Melanitini", "Anaeini", 
                  "Epicaliini", "Epiphilini", "Coeini", "Satyrini", "Callicorini", "Biblidini", "Ageroniini")

for (tribo_atual in ordem_tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Adicione o ano de 2020, mesmo que não haja dados
  medianas_anuais <- c(medianas_anuais, NA)
  names(medianas_anuais)[length(medianas_anuais)] <- "2020"
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = as.character(unique(c(names(medianas_anuais), "2020"))), MedianaAnual = c(medianas_anuais, NA))
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- c(erros_padrao, NA)
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup) * 1.2
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "",
         y = "Mediana da Abundância 
 / Esforço Amostral") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Adicionar o gráfico atual à lista
  lista_graficos[[tribo_atual]] <- p_tribo
}


```

</br>


```{r grafico abundancia-resex-alto-tarauca-combinada}
#| label: fig-abundancia-resex-alto-tarauaca-combinada
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'
#| fig-cap: "Variação na abundância das tribos de borboletas frugívoras na RESEX do Alto Tarauacá no período de 2020 a 2022. A linha pontilhada vermelha indica a mediana total (e.g., mediana de todos os anos). O asterisco indica que a mediana anual foi significativamente diferente da mediana total, considerando p ≤ 0.01."

# Combine todos os gráficos em uma única imagem
imagem_combinada <- grid.arrange(grobs = lista_graficos, ncol = 3)

# Salvar a imagem combinada usando ggsave()
# ggsave(filename = "todos_graficos_alto_tarauaca.png",  # Escolha um nome adequado para o arquivo
#        plot = imagem_combinada,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Alto Tarauaca",  # Especifique o diretório onde você deseja salvar a imagem
#        dpi = 300,  # Define a resolução (DPI)
#        width = 14, height = 12, units = "in")  # Define o tamanho da imagem


```

</br>


```{r grafico abundancia-resex-riozinho-da-liberdade}
#| label: fig-abundancia-resex-riozinho-da-liberdade
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'



# Análise  de efeito da queda do tabocal nas tribos de borboletas frugívoras - AUTOMATIZADO
# RESEX Riozinho da Liberdade
# Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)
library(ggplot2)
library(car)

# setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
# 
# dados_borboletas <- read.table("dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
# dados_borboletas$ano <- as.factor(dados_borboletas$ano)
# dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]
# dados_borboletas <- dados_borboletas[!is.na(dados_borboletas$tribo), ]


dados_regiao_especifica <- dados_borboletas %>%
  filter(uc == 'Resex_Riozinho_da_Liberdade')

# Calcular o esforço amostral para cada combinação de uc_ea, expedicao e ano
esforco_por_expedicao <- dados_regiao_especifica %>%
  group_by(uc_ea, uc, expedicao, ano) %>%
  summarize(
    max_dia_amostragem = max(dia_amostragem) - 1,
    .groups = 'drop'
  ) %>%
  mutate(
    esforco_amostral = 16 * max_dia_amostragem
  )

# Agregar o esforço de amostragem para cada uc_ea e ano
esforco_total_por_ea_ano <- esforco_por_expedicao %>%
  group_by(uc_ea, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregar o esforço de amostragem para cada uc e ano
esforco_total_por_uc_ano <- esforco_por_expedicao %>%
  group_by(uc, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregação para obter o esforço total por ano
esforco_por_ano <- esforco_total_por_uc_ano %>%
  group_by(ano,uc) %>%
  summarize(
    esforco = sum(esforco_total_ano),
    .groups = 'drop'
  )

# Agregação para obter o número total de indivíduos por ano
num_ind_por_ano <- dados_regiao_especifica %>%
  group_by(ano) %>%
  summarize(
    num_ind = sum(individuos, na.rm = TRUE),
    .groups = 'drop'
  )

#criando uma coluna de UA e selecionando somente as colunas interessadas pra analise
dados_regiao_especifica <- dados_regiao_especifica %>%
  mutate(ua = paste(uc_ea, transeccao, sep = "_"))

#combinando os dados por UA por ano = 12 (3 ea x 4 parcelas)
df_abu_ano <- dados_regiao_especifica %>%
  group_by(tribo, ua, uc_ea,uc, ano) %>%
  summarise(abundancia = sum(individuos, na.rm = TRUE)) %>%
  ungroup()

# Transforma o df para colocar os zeros
df_tabocal <- df_abu_ano %>%
  spread(key = tribo, value = abundancia, fill = 0)

# Retorna ao formato longo para as análises
df_long <- df_tabocal %>%
  pivot_longer(cols = Ageroniini:Satyrini, names_to = "tribo", values_to = "individuos")

# Agregação para obter a abundância total de cada tribo por ano
abundancia_por_ano <- df_long %>%
  group_by(tribo, ano) %>%
  summarize(
    abundancia_total = sum(individuos)
  )

# Juntar as tabelas pela coluna 'ano' e 'uc'
df_long_com_esforco <- left_join(df_long, esforco_por_ano, by = c("ano", "uc"))


# Calcular a abundância padronizada pelo esforço amostral
df_long <- df_long_com_esforco %>%
  mutate(abundancia_padronizada = (individuos / esforco) * 100)
#

library(tidyverse)

# Realizar análise e gerar gráficos para cada tribo

tribos <- unique(df_long$tribo)

for (tribo_atual in tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = names(medianas_anuais), MedianaAnual = medianas_anuais)
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- erros_padrao
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup)*1.1
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "Ano",
         y = "Mediana da Abundância / Esforço Amostral") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Exiba o gráfico ajustado
  print(p_tribo)
  
  # Salvar a imagem usando ggsave()
  ggsave(filename = paste("mediana_", gsub(" ", "_", tolower(tribo_atual)), "_ajustado_pontos_linha_2020.png", sep = ""),  # Escolha um nome adequado para o arquivo
         plot = p_tribo,  # O objeto ggplot
         device = "png",  # Pode ser "jpeg", "tiff", etc.
         path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Riozinho da Liberdade",  # Especifique o diretório onde você deseja salvar o gráfico
         dpi = 300,  # Define a resolução (DPI)
         width = 6, height = 5, units = "in")  # Define o tamanho da imagem
}


library(gridExtra)

# Definir uma lista para armazenar os gráficos
lista_graficos <- list()

# Defina a ordem das tribos
ordem_tribos <- c("Brassolini", "Morphini", "Haeterini", "Preponini", "Melanitini", "Anaeini", 
                  "Epicaliini", "Epiphilini", "Coeini", "Satyrini", "Callicorini", "Biblidini", "Ageroniini")

for (tribo_atual in ordem_tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = names(medianas_anuais), MedianaAnual = medianas_anuais)
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- erros_padrao
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup) * 1.1
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "",
         y = "Mediana da Abundância 
 / Esforço Amostral") +
    theme_minimal() +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Adicionar o gráfico atual à lista
  lista_graficos[[tribo_atual]] <- p_tribo
}


```

</br>


```{r grafico abundancia-resex-riozinho-da-liberdade-combinada}
#| label: fig-abundancia-resex-riozinho-da-liberdade-combinada
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'
#| fig-cap: "Variação na abundância das tribos de borboletas frugívoras na RESEX do Riozinho da Liberdade no período de 2020 a 2022. A linha pontilhada vermelha indica a mediana total (e.g., mediana de todos os anos). O asterisco indica que a mediana anual foi significativamente diferente da mediana total, considerando p ≤ 0.01."

# Combine todos os gráficos em uma única imagem
imagem_combinada <- grid.arrange(grobs = lista_graficos, ncol = 3)

# Salvar a imagem combinada usando ggsave()
# ggsave(filename = "todos_graficos_riozinho_da_liberdade.png",  # Escolha um nome adequado para o arquivo
#        plot = imagem_combinada,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Riozinho da Liberdade",  # Especifique o diretório onde você deseja salvar a imagem
#        dpi = 300,  # Define a resolução (DPI)
#        width = 14, height = 12, units = "in")  # Define o tamanho da imagem

```

</br>


```{r grafico abundancia-resex-chico-mendes}
#| label: fig-abundancia-resex-chico-mendes
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'



# Análise  de efeito da queda do tabocal nas tribos de borboletas frugívoras - AUTOMATIZADO
# RESEX Chico Mendes
# Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)
library(ggplot2)
library(car)

# setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
# 
# dados_borboletas <- read.table("dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
# dados_borboletas$ano <- as.factor(dados_borboletas$ano)
# dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]
# dados_borboletas <- dados_borboletas[!is.na(dados_borboletas$tribo), ]


dados_regiao_especifica <- dados_borboletas %>%
  filter(uc == 'Resex_Chico_Mendes')

# Calcular o esforço amostral para cada combinação de uc_ea, expedicao e ano
esforco_por_expedicao <- dados_regiao_especifica %>%
  group_by(uc_ea, uc, expedicao, ano) %>%
  summarize(
    max_dia_amostragem = max(dia_amostragem) - 1,
    .groups = 'drop'
  ) %>%
  mutate(
    esforco_amostral = 16 * max_dia_amostragem
  )

# Agregar o esforço de amostragem para cada uc_ea e ano
esforco_total_por_ea_ano <- esforco_por_expedicao %>%
  group_by(uc_ea, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregar o esforço de amostragem para cada uc e ano
esforco_total_por_uc_ano <- esforco_por_expedicao %>%
  group_by(uc, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregação para obter o esforço total por ano
esforco_por_ano <- esforco_total_por_uc_ano %>%
  group_by(ano,uc) %>%
  summarize(
    esforco = sum(esforco_total_ano),
    .groups = 'drop'
  )

# Agregação para obter o número total de indivíduos por ano
num_ind_por_ano <- dados_regiao_especifica %>%
  group_by(ano) %>%
  summarize(
    num_ind = sum(individuos, na.rm = TRUE),
    .groups = 'drop'
  )

#criando uma coluna de UA e selecionando somente as colunas interessadas pra analise
dados_regiao_especifica <- dados_regiao_especifica %>%
  mutate(ua = paste(uc_ea, transeccao, sep = "_"))

#combinando os dados por UA por ano = 12 (3 ea x 4 parcelas)
df_abu_ano <- dados_regiao_especifica %>%
  group_by(tribo, ua, uc_ea,uc, ano) %>%
  summarise(abundancia = sum(individuos, na.rm = TRUE)) %>%
  ungroup()

# Transforma o df para colocar os zeros
df_tabocal <- df_abu_ano %>%
  spread(key = tribo, value = abundancia, fill = 0)

# Retorna ao formato longo para as análises
df_long <- df_tabocal %>%
  pivot_longer(cols = Ageroniini:Satyrini, names_to = "tribo", values_to = "individuos")

# Agregação para obter a abundância total de cada tribo por ano
abundancia_por_ano <- df_long %>%
  group_by(tribo, ano) %>%
  summarize(
    abundancia_total = sum(individuos)
  )

# Juntar as tabelas pela coluna 'ano' e 'uc'
df_long_com_esforco <- left_join(df_long, esforco_por_ano, by = c("ano", "uc"))


# Calcular a abundância padronizada pelo esforço amostral
df_long <- df_long_com_esforco %>%
  mutate(abundancia_padronizada = (individuos / esforco) * 100)
#

library(tidyverse)

# Realizar análise e gerar gráficos para cada tribo

tribos <- unique(df_long$tribo)

for (tribo_atual in tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = names(medianas_anuais), MedianaAnual = medianas_anuais)
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- erros_padrao
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup)*1.1
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "Ano",
         y = "Mediana da Abundância / Esforço Amostral") +
    theme_minimal() +
     theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Exiba o gráfico ajustado
  print(p_tribo)
  
  # Salvar a imagem usando ggsave()
  ggsave(filename = paste("mediana_", gsub(" ", "_", tolower(tribo_atual)), "_ajustado_pontos_linha_2020.png", sep = ""),  # Escolha um nome adequado para o arquivo
         plot = p_tribo,  # O objeto ggplot
         device = "png",  # Pode ser "jpeg", "tiff", etc.
         path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Chico Mendes",  # Especifique o diretório onde você deseja salvar o gráfico
         dpi = 300,  # Define a resolução (DPI)
         width = 6, height = 5, units = "in")  # Define o tamanho da imagem
}


library(gridExtra)

# Definir uma lista para armazenar os gráficos
lista_graficos <- list()

# Defina a ordem das tribos
ordem_tribos <- c("Brassolini", "Morphini", "Haeterini", "Preponini", "Melanitini", "Anaeini", 
                  "Epicaliini", "Epiphilini", "Coeini", "Satyrini", "Callicorini", "Biblidini", "Ageroniini")

for (tribo_atual in ordem_tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = names(medianas_anuais), MedianaAnual = medianas_anuais)
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- erros_padrao
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup) * 1.1
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "",
         y = "Mediana da Abundância 
 / Esforço Amostral") +
    theme_minimal() +
     theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Adicionar o gráfico atual à lista
  lista_graficos[[tribo_atual]] <- p_tribo
}


```

</br>


```{r grafico abundancia-resex-chico-mendes-combinada}
#| label: fig-abundancia-resex-chico-mendes-combinada
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'
#| fig-cap: "Variação na abundância das tribos de borboletas frugívoras na RESEX Chico Mendes no período de 2020 a 2022. A linha pontilhada vermelha indica a mediana total (e.g., mediana de todos os anos). O asterisco indica que a mediana anual foi significativamente diferente da mediana total, considerando p ≤ 0.01."

# Combine todos os gráficos em uma única imagem
imagem_combinada <- grid.arrange(grobs = lista_graficos, ncol = 3)

# Salvar a imagem combinada usando ggsave()
# ggsave(filename = "todos_graficos_chico_mendes.png",  # Escolha um nome adequado para o arquivo
#        plot = imagem_combinada,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Chico Mendes",  # Especifique o diretório onde você deseja salvar a imagem
#        dpi = 300,  # Define a resolução (DPI)
#        width = 14, height = 12, units = "in")  # Define o tamanho da imagem

```

</br>

```{r grafico abundancia-parna-serra-divisor}
#| label: fig-abundancia-parna-serra-divisor
#| echo: false
#| include: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '70%'



# Análise  de efeito da queda do tabocal nas tribos de borboletas frugívoras - AUTOMATIZADO
# PARANA Serra do Divisor
# Script: Isabela Freitas Oliveira

library(dplyr)
library(tidyr)
library(ggplot2)
library(car)

# setwd("~/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela")
# 
# dados_borboletas <- read.table("dados_analise_borboletas_Isabela_V2.txt", header = TRUE)
# dados_borboletas$ano <- as.factor(dados_borboletas$ano)
# dados_borboletas <- dados_borboletas[dados_borboletas$ano != "2023", ]
# dados_borboletas <- dados_borboletas[!is.na(dados_borboletas$tribo), ]


dados_regiao_especifica <- dados_borboletas %>%
  filter(uc == 'Parna_da_Serra_do_Divisor')

# Calcular o esforço amostral para cada combinação de uc_ea, expedicao e ano
esforco_por_expedicao <- dados_regiao_especifica %>%
  group_by(uc_ea, uc, expedicao, ano) %>%
  summarize(
    max_dia_amostragem = max(dia_amostragem) - 1,
    .groups = 'drop'
  ) %>%
  mutate(
    esforco_amostral = 16 * max_dia_amostragem
  )

# Agregar o esforço de amostragem para cada uc_ea e ano
esforco_total_por_ea_ano <- esforco_por_expedicao %>%
  group_by(uc_ea, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregar o esforço de amostragem para cada uc e ano
esforco_total_por_uc_ano <- esforco_por_expedicao %>%
  group_by(uc, ano) %>%
  summarize(
    esforco_total_ano = sum(esforco_amostral),
    .groups = 'drop'
  )

# Agregação para obter o esforço total por ano
esforco_por_ano <- esforco_total_por_uc_ano %>%
  group_by(ano,uc) %>%
  summarize(
    esforco = sum(esforco_total_ano),
    .groups = 'drop'
  )

# Agregação para obter o número total de indivíduos por ano
num_ind_por_ano <- dados_regiao_especifica %>%
  group_by(ano) %>%
  summarize(
    num_ind = sum(individuos, na.rm = TRUE),
    .groups = 'drop'
  )

#criando uma coluna de UA e selecionando somente as colunas interessadas pra analise
dados_regiao_especifica <- dados_regiao_especifica %>%
  mutate(ua = paste(uc_ea, transeccao, sep = "_"))

#combinando os dados por UA por ano = 12 (3 ea x 4 parcelas)
df_abu_ano <- dados_regiao_especifica %>%
  group_by(tribo, ua, uc_ea,uc, ano) %>%
  summarise(abundancia = sum(individuos, na.rm = TRUE)) %>%
  ungroup()

# Transforma o df para colocar os zeros
df_tabocal <- df_abu_ano %>%
  spread(key = tribo, value = abundancia, fill = 0)

# Retorna ao formato longo para as análises
df_long <- df_tabocal %>%
  pivot_longer(cols = Ageroniini:Satyrini, names_to = "tribo", values_to = "individuos")

# Agregação para obter a abundância total de cada tribo por ano
abundancia_por_ano <- df_long %>%
  group_by(tribo, ano) %>%
  summarize(
    abundancia_total = sum(individuos)
  )

# Juntar as tabelas pela coluna 'ano' e 'uc'
df_long_com_esforco <- left_join(df_long, esforco_por_ano, by = c("ano", "uc"))


# Calcular a abundância padronizada pelo esforço amostral
df_long <- df_long_com_esforco %>%
  mutate(abundancia_padronizada = (individuos / esforco) * 100)
#

library(tidyverse)

# Realizar análise e gerar gráficos para cada tribo

tribos <- unique(df_long$tribo)

for (tribo_atual in tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Adicione o ano de 2020, mesmo que não haja dados
  medianas_anuais <- c(medianas_anuais, NA)
  names(medianas_anuais)[length(medianas_anuais)] <- "2020"
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = as.character(unique(c(names(medianas_anuais), "2020"))), MedianaAnual = c(medianas_anuais, NA))
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- c(erros_padrao, NA)
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup)*1.2
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "Ano",
         y = "Mediana da Abundância / Esforço Amostral") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Exiba o gráfico ajustado
  print(p_tribo)
  
  # Salvar a imagem usando ggsave()
  ggsave(filename = paste("mediana_", gsub(" ", "_", tolower(tribo_atual)), "_ajustado_pontos_linha_2020.png", sep = ""),  # Escolha um nome adequado para o arquivo
         plot = p_tribo,  # O objeto ggplot
         device = "png",  # Pode ser "jpeg", "tiff", etc.
         path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Serra do Divisor",  # Especifique o diretório onde você deseja salvar o gráfico
         dpi = 300,  # Define a resolução (DPI)
         width = 6, height = 5, units = "in")  # Define o tamanho da imagem
}


library(gridExtra)

# Definir uma lista para armazenar os gráficos
lista_graficos <- list()

# Defina a ordem das tribos
ordem_tribos <- c("Brassolini", "Morphini", "Haeterini", "Preponini", "Melanitini", "Anaeini", 
                  "Epicaliini", "Epiphilini", "Coeini", "Satyrini", "Callicorini", "Biblidini", "Ageroniini")

for (tribo_atual in ordem_tribos) {
  cat("Realizando análise e gerando gráfico para a tribo:", tribo_atual, "\n")
  
  # Filtrar os dados para a tribo atual
  df_tribo <- df_long %>%
    filter(tribo == tribo_atual)
  
  # Verificar se há dados para a tribo atual
  if (nrow(df_tribo) == 0) {
    cat("Não há dados para a tribo:", tribo_atual, "\n")
    cat("Nenhuma análise ou gráfico gerado para a tribo:", tribo_atual, "\n")
    next
  }
  
  # Calcular a mediana anual para cada ano
  medianas_anuais <- tapply(df_tribo$abundancia_padronizada, df_tribo$ano, median)
  
  # Adicione o ano de 2020, mesmo que não haja dados
  medianas_anuais <- c(medianas_anuais, NA)
  names(medianas_anuais)[length(medianas_anuais)] <- "2020"
  
  # Calcular a mediana geral das medianas anuais
  mediana_geral_anual <- median(medianas_anuais, na.rm = TRUE)
  
  # Remover os anos com NA das medianas anuais
  medianas_anuais <- medianas_anuais[!is.na(medianas_anuais)]
  
  # Crie um vetor para armazenar os resultados dos testes
  resultados_teste_anual <- numeric(length(medianas_anuais))
  
  # Faça um loop pelos anos e realize o teste de Wilcoxon para cada ano
  for (ano_atual in names(medianas_anuais)) {
    # Realiza o teste de Wilcoxon comparando as medianas do ano atual com a mediana geral
    wilcox_test_resultado <- wilcox.test(df_tribo$abundancia_padronizada[df_tribo$ano == ano_atual], mu = mediana_geral_anual, exact = FALSE)
    
    # Armazena o valor p do teste no vetor de resultados
    resultados_teste_anual[ano_atual] <- wilcox_test_resultado$p.value
  }
  
  # Crie um data frame com as medianas anuais, a mediana geral anual e os valores-p
  df_plot <- data.frame(Ano = as.character(unique(c(names(medianas_anuais), "2020"))), MedianaAnual = c(medianas_anuais, NA))
  df_plot$MedianaGeral <- mediana_geral_anual
  df_plot$ValorP <- resultados_teste_anual[match(df_plot$Ano, names(resultados_teste_anual))]
  
  # Calcule os erros padrão para cada ano
  erros_padrao <- sapply(names(medianas_anuais), function(ano) {
    dados_ano <- df_tribo$abundancia_padronizada[df_tribo$ano == ano]
    desvio_padrao_ano <- sd(dados_ano, na.rm = TRUE)
    erro_padrao_ano <- desvio_padrao_ano / sqrt(length(dados_ano))
    return(erro_padrao_ano)
  })
  
  # Adicione os intervalos de confiança ao data frame
  df_plot$ErroPadrao <- c(erros_padrao, NA)
  df_plot$IntervaloConfiancaInf <- pmax(df_plot$MedianaAnual - 1.96 * df_plot$ErroPadrao, 0)
  df_plot$IntervaloConfiancaSup <- df_plot$MedianaAnual + 1.96 * df_plot$ErroPadrao
  
  # Definir os limites do eixo y de acordo com os valores das medianas
  y_limit <- max(df_plot$IntervaloConfiancaSup) * 1.2
  
  # Definir a cor de acordo com a tribo
  cor_tribo <- if (tribo_atual %in% c("Brassolini", "Haeterini", "Morphini")) {
    "#35978f"
  } else if (tribo_atual %in% c("Satyrini", "Coeini", "Epiphilini", "Epicaliini", "Anaeini", "Melanitini", "Preponini")) {
    "gray40"
  } else {
    "#bf812d"
  }
  
  # Crie o gráfico ajustado com pontos e linhas
  p_tribo <- ggplot(df_plot, aes(x = Ano, y = MedianaAnual)) +
    geom_point(color = cor_tribo, size = 1) +
    geom_line(size = 0.5, group = 1, color = cor_tribo) +  # Use group = 1 para conectar todos os pontos
    geom_errorbar(aes(ymin = IntervaloConfiancaInf, ymax = IntervaloConfiancaSup), width = 0.2, color = cor_tribo) +
    geom_hline(yintercept = mediana_geral_anual, linetype = "dashed", color = "red") +
    labs(title = paste("", tribo_atual),
         x = "",
         y = "Mediana da Abundância 
 / Esforço Amostral") +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 8),
          axis.title = element_text(size = 5),
          axis.text = element_text(size = 5),
          axis.line = element_line(color = "black"),
          axis.ticks.y = element_line(color = "black"),
          panel.grid.minor = element_blank(),
          axis.line.x = element_blank(),
          legend.position = "none") +  # Remover a legenda
    ylim(0, y_limit) +  # Ajuste os limites conforme necessário
    geom_text(data = df_plot[df_plot$ValorP < 0.05, ], 
              aes(x = Ano, y = IntervaloConfiancaSup, label = "*"), 
              vjust = -0.5,  
              size = 3)
  
  # Adicionar o gráfico atual à lista
  lista_graficos[[tribo_atual]] <- p_tribo
}


```

</br>


```{r grafico abundancia-parna-serra-divisor-combinada}
#| label: fig-abundancia-parana-serra-divisor-combinada
#| echo: false
#| message: false
#| warning: false
#| cache: true
#| fig.pos: 'H'
#| out.width: '75%'
#| fig-cap: "Variação na abundância das tribos de borboletas frugívoras no PARNA Serra do Divisor no período de 2020 a 2022. A linha pontilhada vermelha indica a mediana total (e.g., mediana de todos os anos). O asterisco indica que a mediana anual foi significativamente diferente da mediana total, considerando p ≤ 0.01."

# Combine todos os gráficos em uma única imagem
imagem_combinada <- grid.arrange(grobs = lista_graficos, ncol = 3)

# Salvar a imagem combinada usando ggsave()
# ggsave(filename = "todos_graficos_serra_do_divisor.png",  # Escolha um nome adequado para o arquivo
#        plot = imagem_combinada,  # O objeto ggplot
#        device = "png",  # Pode ser "jpeg", "tiff", etc.
#        path = "/Users/isabelafreitasoliveira/Documents/ICMBIO-COMOB/Dados_Monitora/Análise de dados/Monitora_Borboletas_Isabela/Destaque/Serra do Divisor",  # Especifique o diretório onde você deseja salvar a imagem
#        dpi = 300,  # Define a resolução (DPI)
#        width = 14, height = 12, units = "in")  # Define o tamanho da imagem

```



## Discussão


</br>




## Recomendações

</br>

::: callout-tip

## Boas práticas para aprimorar o Programa

</br>

- Ampliar o número de unidades de conservação com aplicação do protocolo de borboletas frugívoras (Básico e Avançado) nos biomas Mata Atlântica e Cerrado; 

- Na Região Climática Noroeste da Amazônia, implementar o protocolo de borboletas frugívoras em pelo menos três UCs, preferencialmente na ESEC Juami-Japurá, no PARNA do Pico da Neblina e na RESEX Auatí-Paraná;  

- Ampliar o número de UCs com aplicação do protocolo de borboletas frugívoras nas regiões do médio e baixo rio Juruá, regiões carentes de amostragem de borboletas e de extrema importância biológica. É sugerida a implementação nas RESEX Médio e Baixo Juruá e na FLONA de Tefé;  

- Ampliar o número de UCs com aplicação do protocolo de borboletas frugívoras na Região Climática Sudeste Amazônica. Sugere-se a implementação na FLONA de Carajás, na REBIO Nascentes da Serra do Cachimbo e na ESEC Iquê; 

- Consolidar a implantação do protocolo de borboletas frugívoras naquelas unidades de conservação ainda não consolidadas, de forma que as UCs contem com pelo menos três estações amostrais implantadas e em operação; 

- Assegurar que durante as campanhas de campo as amostragens sejam realizadas de acordo com as diretrizes estabelecidas no protocolo amostral, em especial quanto ao respeito aos períodos de coleta definidos para cada região e em relação ao esforço amostral (número de dias de amostragens em cada EA); 

- Assegurar que os dados coletados sejam repassados à COMOB de acordo com as orientações definidas pela Coordenação e num prazo razoável após a realização da campanha de campo. 

::: 